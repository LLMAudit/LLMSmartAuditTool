Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses low-level calls to transfer tokens and withdraw fees without checking the success of these calls. Specifically, the following instances are identified:

1. In the `withdrawStake` function:
   ```solidity
   minter().trustedTransferTokens(msg.sender, amount);
   ```
   If the `trustedTransferTokens` function fails, the transaction will not revert, and the user may lose their funds without any indication of failure.

2. In the `withdrawFees` function:
   ```solidity
   minter().trustedWithdrawETH(msg.sender, amount);
   ```
   Similar to the previous case, if the `trustedWithdrawETH` function fails, the transaction will not revert, leading to potential loss of funds.

Recommended Mitigation:
To mitigate this vulnerability, it is essential to check the return value of low-level calls and revert the transaction if the call fails. This can be done by using the following pattern:

```solidity
(bool success, ) = address(minter()).call(abi.encodeWithSignature(""trustedTransferTokens(address,uint256)"", msg.sender, amount));
require(success, ""Transfer failed"");
```

This ensures that if the call fails, the transaction will revert, preventing any loss of funds and maintaining the integrity of the contract's operations.
'''
```

[2024-10-08 17:17:21 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses low-level calls to transfer tokens and withdraw fees without checking the success of these calls. Specifically, the following instances are identified:

1. In the `withdrawStake` function:
   ```solidity
   minter().trustedTransferTokens(msg.sender, amount);
   ```
   If the `trustedTransferTokens` function fails, the transaction will not revert, and the user may lose their funds without any indication of failure.

2. In the `withdrawFees` function:
   ```solidity
   minter().trustedWithdrawETH(msg.sender, amount);
   ```
   Similar to the previous case, if the `trustedWithdrawETH` function fails, the transaction will not revert, leading to potential loss of funds.

Recommended Mitigation:
To mitigate this vulnerability, it is essential to check the return value of low-level calls and revert the transaction if the call fails. This can be done by using the following pattern:

```solidity
(bool success, ) = address(minter()).call(abi.encodeWithSignature(""trustedTransferTokens(address,uint256)"", msg.sender, amount));
require(success, ""Transfer failed"");
```

This ensures that if the call fails, the transaction will revert, preventing any loss of funds and maintaining the integrity of the contract's operations.
'''
```

[2024-10-08 17:17:21 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-10-08 17:17:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.11; import ""../../ManagerProxyTarget.sol""; import ""../IBondingManager.sol""; import ""../../libraries/SortedDoublyLL.sol""; import ""../../libraries/MathUtils.sol""; import ""./EarningsPoolPreLIP36.sol""; import ""../../token/ILivepeerToken.sol""; import ""../../token/IMinter.sol""; import ""../../rounds/IRoundsManager.sol""; import ""openzeppelin-solidity/contracts/math/SafeMath.sol""; /*  * @title BondingManager  * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol  / contract BondingManagerPreLIP36 is ManagerProxyTarget, IBondingManager {     using SafeMath for uint256;     using SortedDoublyLL for SortedDoublyLL.Data;     using EarningsPool for EarningsPool.Data; // Constants // Occurances are replaced at compile time // and computed to a single value if possible by the optimizer uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;  // Time between unbonding and possible withdrawl in rounds uint64 public unbondingPeriod; // DEPRECATED - DO NOT USE uint256 public numActiveTranscodersDEPRECATED; // Max number of rounds that a caller can claim earnings for at once uint256 public maxEarningsClaimsRounds;  // Represents a transcoder's current state struct Transcoder {     uint256 lastRewardRound; // Last round that the transcoder called reward     uint256 rewardCut; // % of reward paid to transcoder by a delegator     uint256 feeShare; // % of fees paid to delegators by transcoder     uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     mapping(uint256 =&gt; EarningsPool.Data) earningsPoolPerRound; // Mapping of round =&gt; earnings pool for the round     uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active     uint256 activationRound; // Round in which the transcoder became active - 0 if inactive     uint256 deactivationRound; // Round in which the transcoder will become inactive }  // The various states a transcoder can be in enum TranscoderStatus {     NotRegistered,     Registered }  // Represents a delegator's current state struct Delegator {     uint256 bondedAmount; // The amount of bonded tokens     uint256 fees; // The amount of fees collected     address delegateAddress; // The address delegated to     uint256 delegatedAmount; // The amount of tokens delegated to the delegator     uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone     uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE     uint256 lastClaimRound; // The last round during which the delegator claimed its earnings     uint256 nextUnbondingLockId; // ID for the next unbonding lock created     mapping(uint256 =&gt; UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID =&gt; unbonding lock }  // The various states a delegator can be in enum DelegatorStatus {     Pending,     Bonded,     Unbonded }  // Represents an amount of tokens that are being unbonded struct UnbondingLock {     uint256 amount; // Amount of tokens being unbonded     uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn }  // Keep track of the known transcoders and delegators mapping(address =&gt; Delegator) private delegators; mapping(address =&gt; Transcoder) private transcoders;  // DEPRECATED - DO NOT USE // The function getTotalBonded() no longer uses this variable // and instead calculates the total bonded value separately uint256 private totalBondedDEPRECATED;  // DEPRECATED - DO NOT USE SortedDoublyLL.Data private transcoderPoolDEPRECATED;  // DEPRECATED - DO NOT USE struct ActiveTranscoderSetDEPRECATED {     address[] transcoders;     mapping(address =&gt; bool) isActive;     uint256 totalStake; }  // DEPRECATED - DO NOT USE mapping(uint256 =&gt; ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;  // The total active stake (sum of the stake of active set members) for the current round uint256 public currentRoundTotalActiveStake; // The total active stake (sum of the stake of active set members) for the next round uint256 public nextRoundTotalActiveStake;  // The transcoder pool is used to keep track of the transcoders that are eligible for activation. // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders // in the pool are locked into the active set for round N + 1 SortedDoublyLL.Data private transcoderPoolV2;  // Check if sender is TicketBroker modifier onlyTicketBroker() {     require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");     _; }  // Check if sender is RoundsManager modifier onlyRoundsManager() {     require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");     _; }  // Check if sender is Verifier modifier onlyVerifier() {     require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");     _; }  // Check if current round is initialized modifier currentRoundInitialized() {     require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");     _; }  // Automatically claim earnings from lastClaimRound through the current round modifier autoClaimEarnings() {     uint256 currentRound = roundsManager().currentRound();     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     if (lastClaimRound &lt; currentRound) {         updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);     }     _; }  /**  * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address  * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions  * should be used to initialize state variables post-deployment:  * - setUnbondingPeriod()  * - setNumActiveTranscoders()  * - setMaxEarningsClaimsRounds()  * @param _controller Address of Controller that this contract will be registered with  */ constructor(address _controller) public Manager(_controller) {}  /**  * @notice Set unbonding period. Only callable by Controller owner  * @param _unbondingPeriod Rounds between unbonding and possible withdrawal  */ function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {     unbondingPeriod = _unbondingPeriod;      emit ParameterUpdate(""unbondingPeriod""); }  /**  * @notice Set maximum number of active transcoders. Only callable by Controller owner  * @param _numActiveTranscoders Number of active transcoders  */ function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {     transcoderPoolV2.setMaxSize(_numActiveTranscoders);      emit ParameterUpdate(""numActiveTranscoders""); }  /**  * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner  * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once  */ function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {     maxEarningsClaimsRounds = _maxEarningsClaimsRounds;      emit ParameterUpdate(""maxEarningsClaimsRounds""); }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  */ function transcoder(uint256 _rewardCut, uint256 _feeShare) external {     transcoderWithHint(_rewardCut, _feeShare, address(0), address(0)); }  /**  * @notice Delegate stake towards a specific address  * @param _amount The amount of tokens to stake  * @param _to The address of the transcoder to stake towards  */ function bond(uint256 _amount, address _to) external {     bondWithHint(_amount, _to, address(0), address(0), address(0), address(0)); }  /**  * @notice Unbond an amount of the delegator's bonded stake  * @param _amount Amount of tokens to unbond  */ function unbond(uint256 _amount) external {     unbondWithHint(_amount, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebond(uint256 _unbondingLockId) external {     rebondWithHint(_unbondingLockId, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {     rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0)); }  /**  * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period  * @param _unbondingLockId ID of unbonding lock to withdraw with  */ function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {     Delegator storage del = delegators[msg.sender];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");     require(         lock.withdrawRound &lt;= roundsManager().currentRound(),         ""withdraw round must be before or equal to the current round""     );      uint256 amount = lock.amount;     uint256 withdrawRound = lock.withdrawRound;     // Delete unbonding lock     delete del.unbondingLocks[_unbondingLockId];      // Tell Minter to transfer stake (LPT) to the delegator     minter().trustedTransferTokens(msg.sender, amount);      emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound); }  /**  * @notice Withdraws fees to the caller  */ function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegators[msg.sender].fees &gt; 0, ""no fees to withdraw"");      uint256 amount = delegators[msg.sender].fees;     delegators[msg.sender].fees = 0;      // Tell Minter to transfer fees (ETH) to the delegator     minter().trustedWithdrawETH(msg.sender, amount);      emit WithdrawFees(msg.sender); }  /**  * @notice Mint token rewards for an active transcoder and its delegators  */ function reward() external {     rewardWithHint(address(0), address(0)); }  /**  * @notice Update transcoder's fee pool. Only callable by the TicketBroker  * @param _transcoder Transcoder address  * @param _fees Fees to be added to the fee pool  */ function updateTranscoderWithFees(     address _transcoder,     uint256 _fees,     uint256 _round ) external whenSystemNotPaused onlyTicketBroker {     require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");      Transcoder storage t = transcoders[_transcoder];      EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];      // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare' and 'transcoderRewardCut'     // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected     if (_round &gt; t.lastRewardRound) {         earningsPool.setCommission(t.rewardCut, t.feeShare);     }      // Add fees to fee pool     earningsPool.addToFeePool(_fees); }  /**  * @notice Slash a transcoder. Only callable by the Verifier  * @param _transcoder Transcoder address  * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder  * @param _slashAmount Percentage of transcoder bond to be slashed  * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder  */ function slashTranscoder(     address _transcoder,     address _finder,     uint256 _slashAmount,     uint256 _finderFee ) external whenSystemNotPaused onlyVerifier {     Delegator storage del = delegators[_transcoder];      if (del.bondedAmount &gt; 0) {         uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);          // If active transcoder, resign it         if (transcoderPoolV2.contains(_transcoder)) {             resignTranscoder(_transcoder);         }          // Decrease bonded stake         del.bondedAmount = del.bondedAmount.sub(penalty);          // If still bonded decrease delegate's delegated amount         if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {             delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(                 penalty             );         }          // Account for penalty         uint256 burnAmount = penalty;          // Award finder fee if there is a finder address         if (_finder != address(0)) {             uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);             minter().trustedTransferTokens(_finder, finderAmount);              // Minter burns the slashed funds - finder reward             minter().trustedBurnTokens(burnAmount.sub(finderAmount));              emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);         } else {             // Minter burns the slashed funds             minter().trustedBurnTokens(burnAmount);              emit TranscoderSlashed(_transcoder, address(0), penalty, 0);         }     } else {         emit TranscoderSlashed(_transcoder, _finder, 0, 0);     } }  /**  * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round  * @param _endRound The last round for which to claim token pools shares for a delegator  */ function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     require(lastClaimRound &lt; _endRound, ""end round must be after last claim round"");     require(_endRound &lt;= roundsManager().currentRound(), ""end round must be before or equal to current round"");      updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound); }  /**  * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager  */ function setCurrentRoundTotalActiveStake() external onlyRoundsManager {     currentRoundTotalActiveStake = nextRoundTotalActiveStake; }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the  * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will  * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.  * See SortedDoublyLL.sol for details on list hints  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool  * @param _newPosNext Address of next transcoder in pool if the caller joins the pool  */ function transcoderWithHint(     uint256 _rewardCut,     uint256 _feeShare,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized {     require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");     require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");     require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");     require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");      Transcoder storage t = transcoders[msg.sender];     uint256 currentRound = roundsManager().currentRound();      require(         !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,         ""caller can't be active or must have already called reward for the current round""     );      t.rewardCut = _rewardCut;     t.feeShare = _feeShare;      if (!transcoderPoolV2.contains(msg.sender)) {         tryToJoinActiveSet(             msg.sender,             delegators[msg.sender].delegatedAmount,             currentRound.add(1),             _newPosPrev,             _newPosNext         );     }      emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare); }  /**  * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed  * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint  * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.  * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the  * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.  * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint  * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _amount The amount of tokens to stake.  * @param _to The address of the transcoder to stake towards  * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate  * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate  * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate  * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate  */ function bondWithHint(     uint256 _amount,     address _to,     address _oldDelegateNewPosPrev,     address _oldDelegateNewPosNext,     address _currDelegateNewPosPrev,     address _currDelegateNewPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     Delegator storage del = delegators[msg.sender];      uint256 currentRound = roundsManager().currentRound();     // Amount to delegate     uint256 delegationAmount = _amount;     // Current delegate     address currentDelegate = del.delegateAddress;      if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {         // New delegate         // Set start round         // Don't set start round if delegator is in pending state because the start round would not change         del.startRound = currentRound.add(1);         // Unbonded state = no existing delegate and no bonded stake         // Thus, delegation amount = provided amount     } else if (currentDelegate != address(0) &amp;&amp; currentDelegate != _to) {         // A registered transcoder cannot delegate its bonded stake toward another address         // because it can only be delegated toward itself         // In the future, if delegation towards another registered transcoder as an already         // registered transcoder becomes useful (i.e. for transitive delegation), this restriction         // could be removed         require(             !isRegisteredTranscoder(msg.sender),             ""registered transcoders can't delegate towards other addresses""         );         // Changing delegate         // Set start round         del.startRound = currentRound.add(1);         // Update amount to delegate with previous delegation amount         delegationAmount = delegationAmount.add(del.bondedAmount);          decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);     }      // cannot delegate to someone without having bonded stake     require(delegationAmount &gt; 0, ""delegation amount must be greater than 0"");     // Update delegate     del.delegateAddress = _to;     // Update bonded amount     del.bondedAmount = del.bondedAmount.add(_amount);      increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);      if (_amount &gt; 0) {         // Transfer the LPT to the Minter         livepeerToken().transferFrom(msg.sender, address(minter()), _amount);     }      emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount); }  /**  * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed  * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _amount Amount of tokens to unbond  * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool  * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool  */ function unbondWithHint(     uint256 _amount,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");      Delegator storage del = delegators[msg.sender];      require(_amount &gt; 0, ""unbond amount must be greater than 0"");     require(_amount &lt;= del.bondedAmount, ""amount is greater than bonded amount"");      address currentDelegate = del.delegateAddress;     uint256 currentRound = roundsManager().currentRound();     uint256 withdrawRound = currentRound.add(unbondingPeriod);     uint256 unbondingLockId = del.nextUnbondingLockId;      // Create new unbonding lock     del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });     // Increment ID for next unbonding lock     del.nextUnbondingLockId = unbondingLockId.add(1);     // Decrease delegator's bonded amount     del.bondedAmount = del.bondedAmount.sub(_amount);      if (del.bondedAmount == 0) {         // Delegator no longer delegated to anyone if it does not have a bonded amount         del.delegateAddress = address(0);         // Delegator does not have a start round if it is no longer delegated to anyone         del.startRound = 0;          if (transcoderPoolV2.contains(msg.sender)) {             resignTranscoder(msg.sender);         }     }      // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount     decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);      emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates  * the transcoder pool using an optional list hint if needed  * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool  */ function rebondWithHint(     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");      // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using  * an optional list hint if needed  * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool  */ function rebondFromUnbondedWithHint(     address _to,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");      // Set delegator's start round and transition into Pending state     delegators[msg.sender].startRound = roundsManager().currentRound().add(1);     // Set delegator's delegate     delegators[msg.sender].delegateAddress = _to;     // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed  * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool  * @param _newPosNext Address of next transcoder in pool if the caller is in the pool  */ function rewardWithHint(address _newPosPrev, address _newPosNext)     public     whenSystemNotPaused     currentRoundInitialized {     uint256 currentRound = roundsManager().currentRound();      require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");     require(         transcoders[msg.sender].lastRewardRound != currentRound,         ""caller has already called reward for the current round""     );      Transcoder storage t = transcoders[msg.sender];     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];      // Set last round that transcoder called reward     t.lastRewardRound = currentRound;     earningsPool.setCommission(t.rewardCut, t.feeShare);      // If transcoder didn't receive stake updates during the previous round and hasn't called reward for &gt; 1 round     // the 'totalStake' and 'claimableStake' on its 'EarningsPool' for the current round wouldn't be initialized     // Thus we sync the the transcoder's stake to when it was last updated     // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently     uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;     if (lastUpdateRound &lt; currentRound) {         earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);     }      // Create reward based on active transcoder's stake relative to the total active stake     // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake     uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);      updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);      emit Reward(msg.sender, rewardTokens); }  /**  * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending stake from  * @return Pending bonded stake for '_delegator' since last claiming rewards  */ function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {     uint256 currentRound = roundsManager().currentRound();     uint256 endRound = _endRound;      if (endRound &gt; currentRound) {         // Highest round we can calculate up to is the current round         endRound = currentRound;     }      Delegator storage del = delegators[_delegator];     uint256 currentBondedAmount = del.bondedAmount;      for (uint256 i = del.lastClaimRound + 1; i &lt;= _endRound; i++) {         EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];          bool isTranscoder = _delegator == del.delegateAddress;         if (earningsPool.hasClaimableShares()) {             // Calculate and add reward pool share from this round             currentBondedAmount = currentBondedAmount.add(                 earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)             );         }     }      return currentBondedAmount; }  /**  * @notice Returns pending fees for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending fees from  * @return Pending fees for '_delegator' since last claiming fees  */ function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {     uint256 currentRound = roundsManager().currentRound();     uint256 endRound = _endRound;      if (endRound &gt; currentRound) {         // Highest round we can calculate up to is the current round         endRound = currentRound;     }      Delegator storage del = delegators[_delegator];     uint256 currentFees = del.fees;     uint256 currentBondedAmount = del.bondedAmount;      for (uint256 i = del.lastClaimRound + 1; i &lt;= _endRound; i++) {         EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];          if (earningsPool.hasClaimableShares()) {             bool isTranscoder = _delegator == del.delegateAddress;             // Calculate and add fee pool share from this round             currentFees = currentFees.add(earningsPool.feePoolShare(currentBondedAmount, isTranscoder));             // Calculate new bonded amount with rewards from this round. Updated bonded amount used             // to calculate fee pool share in next round             currentBondedAmount = currentBondedAmount.add(                 earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)             );         }     }      return currentFees; }  /**  * @notice Returns total bonded stake for a transcoder  * @param _transcoder Address of transcoder  * @return total bonded stake for a delegator  */ function transcoderTotalStake(address _transcoder) public view returns (uint256) {     return delegators[_transcoder].delegatedAmount; }  /**  * @notice Computes transcoder status  * @param _transcoder Address of transcoder  * @return registered or not registered transcoder status  */ function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {     if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;     return TranscoderStatus.NotRegistered; }  /**  * @notice Computes delegator status  * @param _delegator Address of delegator  * @return bonded, unbonded or pending delegator status  */ function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {     Delegator storage del = delegators[_delegator];      if (del.bondedAmount == 0) {         // Delegator unbonded all its tokens         return DelegatorStatus.Unbonded;     } else if (del.startRound &gt; roundsManager().currentRound()) {         // Delegator round start is in the future         return DelegatorStatus.Pending;     } else {         // Delegator round start is now or in the past         // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which         // would trigger the first if clause         return DelegatorStatus.Bonded;     } }  /**  * @notice Return transcoder information  * @param _transcoder Address of transcoder  * @return trancoder's last reward round  * @return transcoder's reward cut  * @return transcoder's fee share  * @return round in which transcoder's stake was last updated while active  * @return round in which transcoder became active  * @return round in which transcoder will no longer be active  */ function getTranscoder(address _transcoder)     public     view     returns (         uint256 lastRewardRound,         uint256 rewardCut,         uint256 feeShare,         uint256 lastActiveStakeUpdateRound,         uint256 activationRound,         uint256 deactivationRound     ) {     Transcoder storage t = transcoders[_transcoder];      lastRewardRound = t.lastRewardRound;     rewardCut = t.rewardCut;     feeShare = t.feeShare;     lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;     activationRound = t.activationRound;     deactivationRound = t.deactivationRound; }  /**  * @notice Return transcoder's token pools for a given round  * @param _transcoder Address of transcoder  * @param _round Round number  * @return reward pool for delegates to '_transcoder'  * @return fee pool for delegates to '_trancoder'  * @return transcoder's total stake  * @return claimable stake left on transcoder's earningspool for '_round'  * @return transcoder's reward cut for '_round'  * @return transcoder's fee share for '_round'  * @return transcoder's rewards for '_round'  * @return transcoder's fees for '_round'  * @return true if transcoder has a split reward and fee pool  */ function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)     public     view     returns (         uint256 rewardPool,         uint256 feePool,         uint256 totalStake,         uint256 claimableStake,         uint256 transcoderRewardCut,         uint256 transcoderFeeShare,         uint256 transcoderRewardPool,         uint256 transcoderFeePool,         bool hasTranscoderRewardFeePool     ) {     EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];      rewardPool = earningsPool.rewardPool;     feePool = earningsPool.feePool;     totalStake = earningsPool.totalStake;     claimableStake = earningsPool.claimableStake;     transcoderRewardCut = earningsPool.transcoderRewardCut;     transcoderFeeShare = earningsPool.transcoderFeeShare;     transcoderRewardPool = earningsPool.transcoderRewardPool;     transcoderFeePool = earningsPool.transcoderFeePool;     hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool; }  /**  * @notice Return delegator info  * @param _delegator Address of delegator  * @return total amount bonded by '_delegator'  * @return amount of fees collected by '_delegator'  * @return address '_delegator' has bonded to  * @return total amount delegated to '_delegator'  * @return round in which bond for '_delegator' became effective  * @return round for which '_delegator' has last claimed earnings  * @return ID for the next unbonding lock created for '_delegator'  */ function getDelegator(address _delegator)     public     view     returns (         uint256 bondedAmount,         uint256 fees,         address delegateAddress,         uint256 delegatedAmount,         uint256 startRound,         uint256 lastClaimRound,         uint256 nextUnbondingLockId     ) {     Delegator storage del = delegators[_delegator];      bondedAmount = del.bondedAmount;     fees = del.fees;     delegateAddress = del.delegateAddress;     delegatedAmount = del.delegatedAmount;     startRound = del.startRound;     lastClaimRound = del.lastClaimRound;     nextUnbondingLockId = del.nextUnbondingLockId; }  /**  * @notice Return delegator's unbonding lock info  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return amount of stake locked up by unbonding lock  * @return round in which 'amount' becomes available for withdrawal  */ function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)     public     view     returns (uint256 amount, uint256 withdrawRound) {     UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];      return (lock.amount, lock.withdrawRound); }  /**  * @notice Returns max size of transcoder pool  * @return transcoder pool max size  */ function getTranscoderPoolMaxSize() public view returns (uint256) {     return transcoderPoolV2.getMaxSize(); }  /**  * @notice Returns size of transcoder pool  * @return transcoder pool current size  */ function getTranscoderPoolSize() public view returns (uint256) {     return transcoderPoolV2.getSize(); }  /**  * @notice Returns transcoder with most stake in pool  * @return address for transcoder with highest stake in transcoder pool  */ function getFirstTranscoderInPool() public view returns (address) {     return transcoderPoolV2.getFirst(); }  /**  * @notice Returns next transcoder in pool for a given transcoder  * @param _transcoder Address of a transcoder in the pool  * @return address for the transcoder after '_transcoder' in transcoder pool  */ function getNextTranscoderInPool(address _transcoder) public view returns (address) {     return transcoderPoolV2.getNext(_transcoder); }  /**  * @notice Return total bonded tokens  * @return total active stake for the current round  */ function getTotalBonded() public view returns (uint256) {     return currentRoundTotalActiveStake; }  /**  * @notice Return whether a transcoder is active for the current round  * @param _transcoder Transcoder address  * @return true if transcoder is active  */ function isActiveTranscoder(address _transcoder) public view returns (bool) {     Transcoder storage t = transcoders[_transcoder];     uint256 currentRound = roundsManager().currentRound();     return t.activationRound &lt;= currentRound &amp;&amp; currentRound &lt; t.deactivationRound; }  /**  * @notice Return whether a transcoder is registered  * @param _transcoder Transcoder address  * @return true if transcoder is self-bonded  */ function isRegisteredTranscoder(address _transcoder) public view returns (bool) {     Delegator storage d = delegators[_transcoder];     return d.delegateAddress == _transcoder &amp;&amp; d.bondedAmount &gt; 0; }  /**  * @notice Return whether an unbonding lock for a delegator is valid  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return true if unbondingLock for ID has a non-zero withdraw round  */ function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {     // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)     return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound &gt; 0; }  /**  * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The delegate to increase the stake for  * @param _amount The amount to increase the stake for '_delegate' by  */ function increaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (isRegisteredTranscoder(_delegate)) {         uint256 newStake = transcoderTotalStake(_delegate).add(_amount);         uint256 nextRound = roundsManager().currentRound().add(1);          // If the transcoder is already in the active set update its stake and return         if (transcoderPoolV2.contains(_delegate)) {             transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);             nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);             Transcoder storage t = transcoders[_delegate];             t.earningsPoolPerRound[nextRound].setStake(newStake);             t.lastActiveStakeUpdateRound = nextRound;         } else {             // Check if the transcoder is eligible to join the active set in the update round             tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);         }     }      // Increase delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount); }  /**  * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The transcoder to decrease the stake for  * @param _amount The amount to decrease the stake for '_delegate' by  */ function decreaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (transcoderPoolV2.contains(_delegate)) {         uint256 newStake = transcoderTotalStake(_delegate).sub(_amount);         uint256 nextRound = roundsManager().currentRound().add(1);          transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);         nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);         Transcoder storage t = transcoders[_delegate];         t.lastActiveStakeUpdateRound = nextRound;         t.earningsPoolPerRound[nextRound].setStake(newStake);     }      // Decrease old delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount); }  /**  * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full  * @param _transcoder The transcoder to insert into the transcoder pool  * @param _totalStake The total stake for '_transcoder'  * @param _activationRound The round in which the transcoder should become active  */ function tryToJoinActiveSet(     address _transcoder,     uint256 _totalStake,     uint256 _activationRound,     address _newPosPrev,     address _newPosNext ) internal {     uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;      if (transcoderPoolV2.isFull()) {         address lastTranscoder = transcoderPoolV2.getLast();         uint256 lastStake = transcoderTotalStake(lastTranscoder);          // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool         // then the transcoder is unable to join the active set for the next round         if (_totalStake &lt;= lastStake) {             return;         }          // Evict the least stake transcoder from the active set for the next round         // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)         // There should be no side-effects as long as the value is properly updated on stake updates         // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as         // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.         transcoderPoolV2.remove(lastTranscoder);         transcoders[lastTranscoder].deactivationRound = _activationRound;         pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);          emit TranscoderDeactivated(lastTranscoder, _activationRound);     }      transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);     pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);     Transcoder storage t = transcoders[_transcoder];     t.lastActiveStakeUpdateRound = _activationRound;     t.activationRound = _activationRound;     t.deactivationRound = MAX_FUTURE_ROUND;     t.earningsPoolPerRound[_activationRound].setStake(_totalStake);     nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;     emit TranscoderActivated(_transcoder, _activationRound); }  /**  * @dev Remove a transcoder from the pool and deactivate it  */ function resignTranscoder(address _transcoder) internal {     // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)     // There should be no side-effects as long as the value is properly updated on stake updates     // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as     // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.     transcoderPoolV2.remove(_transcoder);     nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));     uint256 deactivationRound = roundsManager().currentRound().add(1);     transcoders[_transcoder].deactivationRound = deactivationRound;     emit TranscoderDeactivated(_transcoder, deactivationRound); }  /**  * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.  * See SortedDoublyLL.sol for details on list hints  * @param _transcoder Address of transcoder  * @param _rewards Amount of rewards  * @param _round Round that transcoder is updated  * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool  * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool  */ function updateTranscoderWithRewards(     address _transcoder,     uint256 _rewards,     uint256 _round,     address _newPosPrev,     address _newPosNext ) internal {     EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];     // Add rewards to reward pool     earningsPool.addToRewardPool(_rewards);     // Update transcoder's total stake with rewards     increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext); }  /**  * @dev Update a delegator with token pools shares from its lastClaimRound through a given round  * @param _delegator Delegator address  * @param _endRound The last round for which to update a delegator's stake with token pools shares  * @param _lastClaimRound The round for which a delegator has last claimed earnings  */ function updateDelegatorWithEarnings(     address _delegator,     uint256 _endRound,     uint256 _lastClaimRound ) internal {     Delegator storage del = delegators[_delegator];     uint256 startRound = _lastClaimRound.add(1);     uint256 currentBondedAmount = del.bondedAmount;     uint256 currentFees = del.fees;      // Only will have earnings to claim if you have a delegate     // If not delegated, skip the earnings claim process     if (del.delegateAddress != address(0)) {         // Cannot claim earnings for more than maxEarningsClaimsRounds         // This is a number to cause transactions to fail early if         // we know they will require too much gas to loop through all the necessary rounds to claim earnings         // The user should instead manually invoke `claimEarnings` to split up the claiming process         // across multiple transactions         require(_endRound.sub(_lastClaimRound) &lt;= maxEarningsClaimsRounds, ""too many rounds to claim through"");          for (uint256 i = startRound; i &lt;= _endRound; i++) {             EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];              if (earningsPool.hasClaimableShares()) {                 (uint256 fees, uint256 rewards) = earningsPool.claimShare(                     currentBondedAmount,                     _delegator == del.delegateAddress                 );                  currentFees = currentFees.add(fees);                 currentBondedAmount = currentBondedAmount.add(rewards);             }         }     }      emit EarningsClaimed(         del.delegateAddress,         _delegator,         currentBondedAmount.sub(del.bondedAmount),         currentFees.sub(del.fees),         startRound,         _endRound     );      del.lastClaimRound = _endRound;     // Rewards are bonded by default     del.bondedAmount = currentBondedAmount;     del.fees = currentFees; }  /**  * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional  * list hint if needed. See SortedDoublyLL.sol for details on list hints  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool  */ function processRebond(     address _delegator,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) internal {     Delegator storage del = delegators[_delegator];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");      uint256 amount = lock.amount;     // Increase delegator's bonded amount     del.bondedAmount = del.bondedAmount.add(amount);      // Delete lock     delete del.unbondingLocks[_unbondingLockId];      increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);      emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount); }  /**  * @dev Return LivepeerToken interface  * @return Livepeer token contract registered with Controller  */ function livepeerToken() internal view returns (ILivepeerToken) {     return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken""))); }  /**  * @dev Return Minter interface  * @return Minter contract registered with Controller  */ function minter() internal view returns (IMinter) {     return IMinter(controller.getContract(keccak256(""Minter""))); }  /**  * @dev Return RoundsManager interface  * @return RoundsManager contract registered with Controller  */ function roundsManager() internal view returns (IRoundsManager) {     return IRoundsManager(controller.getContract(keccak256(""RoundsManager""))); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': 'pragma solidity ^0.5.11;\n\nimport ""../../ManagerProxyTarget.sol"";\nimport ""../IBondingManager.sol"";\nimport ""../../libraries/SortedDoublyLL.sol"";\nimport ""../../libraries/MathUtils.sol"";\nimport ""./EarningsPoolPreLIP36.sol"";\nimport ""../../token/ILivepeerToken.sol"";\nimport ""../../token/IMinter.sol"";\nimport ""../../rounds/IRoundsManager.sol"";\n\nimport ""openzeppelin-solidity/contracts/math/SafeMath.sol"";\n\n/\n * @title BondingManager\n * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\n */\ncontract BondingManagerPreLIP36 is ManagerProxyTarget, IBondingManager {\n    using SafeMath for uint256;\n    using SortedDoublyLL for SortedDoublyLL.Data;\n    using EarningsPool for EarningsPool.Data;\n\n    // Constants\n    // Occurances are replaced at compile time\n    // and computed to a single value if possible by the optimizer\n    uint256 constant MAX_FUTURE_ROUND = 2256 - 1;\n\n    // Time between unbonding and possible withdrawl in rounds\n    uint64 public unbondingPeriod;\n    // DEPRECATED - DO NOT USE\n    uint256 public numActiveTranscodersDEPRECATED;\n    // Max number of rounds that a caller can claim earnings for at once\n    uint256 public maxEarningsClaimsRounds;\n\n    // Represents a transcoder\'s current state\n    struct Transcoder {\n        uint256 lastRewardRound; // Last round that the transcoder called reward\n        uint256 rewardCut; // % of reward paid to transcoder by a delegator\n        uint256 feeShare; // % of fees paid to delegators by transcoder\n        uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE\n        mapping(uint256 =&gt; EarningsPool.Data) earningsPoolPerRound; // Mapping of round =&gt; earnings pool for the round\n        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active\n        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive\n        uint256 deactivationRound; // Round in which the transcoder will become inactive\n    }\n\n    // The various states a transcoder can be in\n    enum TranscoderStatus {\n        NotRegistered,\n        Registered\n    }\n\n    // Represents a delegator\'s current state\n    struct Delegator {\n        uint256 bondedAmount; // The amount of bonded tokens\n        uint256 fees; // The amount of fees collected\n        address delegateAddress; // The address delegated to\n        uint256 delegatedAmount; // The amount of tokens delegated to the delegator\n        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone\n        uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings\n        uint256 nextUnbondingLockId; // ID for the next unbonding lock created\n        mapping(uint256 =&gt; UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID =&gt; unbonding lock\n    }\n\n    // The various states a delegator can be in\n    enum DelegatorStatus {\n        Pending,\n        Bonded,\n        Unbonded\n    }\n\n    // Represents an amount of tokens that are being unbonded\n    struct UnbondingLock {\n        uint256 amount; // Amount of tokens being unbonded\n        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn\n    }\n\n    // Keep track of the known transcoders and delegators\n    mapping(address =&gt; Delegator) private delegators;\n    mapping(address =&gt; Transcoder) private transcoders;\n\n    // DEPRECATED - DO NOT USE\n    // The function getTotalBonded() no longer uses this variable\n    // and instead calculates the total bonded value separately\n    uint256 private totalBondedDEPRECATED;\n\n    // DEPRECATED - DO NOT USE\n    SortedDoublyLL.Data private transcoderPoolDEPRECATED;\n\n    // DEPRECATED - DO NOT USE\n    struct ActiveTranscoderSetDEPRECATED {\n        address[] transcoders;\n        mapping(address =&gt; bool) isActive;\n        uint256 totalStake;\n    }\n\n    // DEPRECATED - DO NOT USE\n    mapping(uint256 =&gt; ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;\n\n    // The total active stake (sum of the stake of active set members) for the current round\n    uint256 public currentRoundTotalActiveStake;\n    // The total active stake (sum of the stake of active set members) for the next round\n    uint256 public nextRoundTotalActiveStake;\n\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\n    // in the pool are locked into the active set for round N + 1\n    SortedDoublyLL.Data private transcoderPoolV2;\n\n    // Check if sender is TicketBroker\n    modifier onlyTicketBroker() {\n        require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");\n        ;\n    }\n\n    // Check if sender is RoundsManager\n    modifier onlyRoundsManager() {\n        require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");\n        ;\n    }\n\n    // Check if sender is Verifier\n    modifier onlyVerifier() {\n        require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");\n        ;\n    }\n\n    // Check if current round is initialized\n    modifier currentRoundInitialized() {\n        require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");\n        ;\n    }\n\n    // Automatically claim earnings from lastClaimRound through the current round\n    modifier autoClaimEarnings() {\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n        if (lastClaimRound &lt; currentRound) {\n            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);\n        }\n        _;\n    }\n\n    /\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides controller. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setUnbondingPeriod()\n     * - setNumActiveTranscoders()\n     * - setMaxEarningsClaimsRounds()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) public Manager(_controller) {}\n\n    /\n     * @notice Set unbonding period. Only callable by Controller owner\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\n     /\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n        unbondingPeriod = _unbondingPeriod;\n\n        emit ParameterUpdate(""unbondingPeriod"");\n    }\n\n    /\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\n     * @param _numActiveTranscoders Number of active transcoders\n     /\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n        transcoderPoolV2.setMaxSize(_numActiveTranscoders);\n\n        emit ParameterUpdate(""numActiveTranscoders"");\n    }\n\n    /\n     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner\n     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once\n     */\n    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {\n        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;\n\n        emit ParameterUpdate(""maxEarningsClaimsRounds"");\n    }\n\n    /\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     /\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\n    }\n\n    /\n     * @notice Delegate stake towards a specific address\n     * @param _amount The amount of tokens to stake\n     * @param _to The address of the transcoder to stake towards\n     /\n    function bond(uint256 _amount, address _to) external {\n        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));\n    }\n\n    /\n     * @notice Unbond an amount of the delegator\'s bonded stake\n     * @param _amount Amount of tokens to unbond\n     */\n    function unbond(uint256 _amount) external {\n        unbondWithHint(_amount, address(0), address(0));\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegator\'s current delegate while a delegator is in the Bonded or Pending status\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     /\n    function rebond(uint256 _unbondingLockId) external {\n        rebondWithHint(_unbondingLockId, address(0), address(0));\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     /\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\n    }\n\n    /\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\n     */\n    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");\n        require(\n            lock.withdrawRound &lt;= roundsManager().currentRound(),\n            ""withdraw round must be before or equal to the current round""\n        );\n\n        uint256 amount = lock.amount;\n        uint256 withdrawRound = lock.withdrawRound;\n        // Delete unbonding lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        // Tell Minter to transfer stake (LPT) to the delegator\n        minter().trustedTransferTokens(msg.sender, amount);\n\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\n    }\n\n    /\n     * @notice Withdraws fees to the caller\n     /\n    function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegators[msg.sender].fees &gt; 0, ""no fees to withdraw"");\n\n        uint256 amount = delegators[msg.sender].fees;\n        delegators[msg.sender].fees = 0;\n\n        // Tell Minter to transfer fees (ETH) to the delegator\n        minter().trustedWithdrawETH(msg.sender, amount);\n\n        emit WithdrawFees(msg.sender);\n    }\n\n    /\n     * @notice Mint token rewards for an active transcoder and its delegators\n     /\n    function reward() external {\n        rewardWithHint(address(0), address(0));\n    }\n\n    /\n     * @notice Update transcoder\'s fee pool. Only callable by the TicketBroker\n     * @param _transcoder Transcoder address\n     * @param _fees Fees to be added to the fee pool\n     */\n    function updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n        require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");\n\n        Transcoder storage t = transcoders[_transcoder];\n\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\n\n        // if transcoder hasn\'t called \'reward()\' for \'_round\' its \'transcoderFeeShare\' and \'transcoderRewardCut\'\n        // on the \'EarningsPool\' for \'_round\' would not be initialized and the fee distribution wouldn\'t happen as expected\n        if (_round &gt; t.lastRewardRound) {\n            earningsPool.setCommission(t.rewardCut, t.feeShare);\n        }\n\n        // Add fees to fee pool\n        earningsPool.addToFeePool(_fees);\n    }\n\n    /\n     * @notice Slash a transcoder. Only callable by the Verifier\n     * @param _transcoder Transcoder address\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\n     * @param _slashAmount Percentage of transcoder bond to be slashed\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\n     /\n    function slashTranscoder(\n        address _transcoder,\n        address _finder,\n        uint256 _slashAmount,\n        uint256 _finderFee\n    ) external whenSystemNotPaused onlyVerifier {\n        Delegator storage del = delegators[_transcoder];\n\n        if (del.bondedAmount &gt; 0) {\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n\n            // If active transcoder, resign it\n            if (transcoderPoolV2.contains(_transcoder)) {\n                resignTranscoder(_transcoder);\n            }\n\n            // Decrease bonded stake\n            del.bondedAmount = del.bondedAmount.sub(penalty);\n\n            // If still bonded decrease delegate\'s delegated amount\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\n                    penalty\n                );\n            }\n\n            // Account for penalty\n            uint256 burnAmount = penalty;\n\n            // Award finder fee if there is a finder address\n            if (_finder != address(0)) {\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\n                minter().trustedTransferTokens(_finder, finderAmount);\n\n                // Minter burns the slashed funds - finder reward\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\n\n                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\n            } else {\n                // Minter burns the slashed funds\n                minter().trustedBurnTokens(burnAmount);\n\n                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\n            }\n        } else {\n            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\n        }\n    }\n\n    /\n     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\n     * @param _endRound The last round for which to claim token pools shares for a delegator\n     /\n    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n        require(lastClaimRound &lt; _endRound, ""end round must be after last claim round"");\n        require(_endRound &lt;= roundsManager().currentRound(), ""end round must be before or equal to current round"");\n\n        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);\n    }\n\n    /\n     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\n     */\n    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\n        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\n    }\n\n    /\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\n     * caller can provide an optional hint for the insertion position in the pool via the _newPosPrev and _newPosNext params. A linear search will\n     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\n     /\n    function transcoderWithHint(\n        uint256 _rewardCut,\n        uint256 _feeShare,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        require(!roundsManager().currentRoundLocked(), ""can\'t update transcoder params, current round is locked"");\n        require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");\n        require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");\n        require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");\n\n        Transcoder storage t = transcoders[msg.sender];\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(\n            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n            ""caller can\'t be active or must have already called reward for the current round""\n        );\n\n        t.rewardCut = _rewardCut;\n        t.feeShare = _feeShare;\n\n        if (!transcoderPoolV2.contains(msg.sender)) {\n            tryToJoinActiveSet(\n                msg.sender,\n                delegators[msg.sender].delegatedAmount,\n                currentRound.add(1),\n                _newPosPrev,\n                _newPosNext\n            );\n        }\n\n        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\n    }\n\n    /\n     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n     * for the insertion position of the old delegate via the _oldDelegateNewPosPrev and _oldDelegateNewPosNext params.\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the _currDelegateNewPosPrev and _currDelegateNewPosNext params.\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _amount The amount of tokens to stake.\n     * @param _to The address of the transcoder to stake towards\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n     /\n    function bondWithHint(\n        uint256 _amount,\n        address _to,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _currDelegateNewPosPrev,\n        address _currDelegateNewPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        Delegator storage del = delegators[msg.sender];\n\n        uint256 currentRound = roundsManager().currentRound();\n        // Amount to delegate\n        uint256 delegationAmount = _amount;\n        // Current delegate\n        address currentDelegate = del.delegateAddress;\n\n        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {\n            // New delegate\n            // Set start round\n            // Don\'t set start round if delegator is in pending state because the start round would not change\n            del.startRound = currentRound.add(1);\n            // Unbonded state = no existing delegate and no bonded stake\n            // Thus, delegation amount = provided amount\n        } else if (currentDelegate != address(0) &amp;&amp; currentDelegate != _to) {\n            // A registered transcoder cannot delegate its bonded stake toward another address\n            // because it can only be delegated toward itself\n            // In the future, if delegation towards another registered transcoder as an already\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\n            // could be removed\n            require(\n                !isRegisteredTranscoder(msg.sender),\n                ""registered transcoders can\'t delegate towards other addresses""\n            );\n            // Changing delegate\n            // Set start round\n            del.startRound = currentRound.add(1);\n            // Update amount to delegate with previous delegation amount\n            delegationAmount = delegationAmount.add(del.bondedAmount);\n\n            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\n        }\n\n        // cannot delegate to someone without having bonded stake\n        require(delegationAmount &gt; 0, ""delegation amount must be greater than 0"");\n        // Update delegate\n        del.delegateAddress = _to;\n        // Update bonded amount\n        del.bondedAmount = del.bondedAmount.add(_amount);\n\n        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\n\n        if (_amount &gt; 0) {\n            // Transfer the LPT to the Minter\n            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\n        }\n\n        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);\n    }\n\n    /\n     * @notice Unbond an amount of the delegator\'s bonded stake and updates the transcoder pool using an optional list hint if needed\n     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n     * @param _amount Amount of tokens to unbond\n     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool\n     */\n    function unbondWithHint(\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");\n\n        Delegator storage del = delegators[msg.sender];\n\n        require(_amount &gt; 0, ""unbond amount must be greater than 0"");\n        require(_amount &lt;= del.bondedAmount, ""amount is greater than bonded amount"");\n\n        address currentDelegate = del.delegateAddress;\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 withdrawRound = currentRound.add(unbondingPeriod);\n        uint256 unbondingLockId = del.nextUnbondingLockId;\n\n        // Create new unbonding lock\n        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });\n        // Increment ID for next unbonding lock\n        del.nextUnbondingLockId = unbondingLockId.add(1);\n        // Decrease delegator\'s bonded amount\n        del.bondedAmount = del.bondedAmount.sub(_amount);\n\n        if (del.bondedAmount == 0) {\n            // Delegator no longer delegated to anyone if it does not have a bonded amount\n            del.delegateAddress = address(0);\n            // Delegator does not have a start round if it is no longer delegated to anyone\n            del.startRound = 0;\n\n            if (transcoderPoolV2.contains(msg.sender)) {\n                resignTranscoder(msg.sender);\n            }\n        }\n\n        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount\n        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);\n\n        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegator\'s current delegate while a delegator is in the Bonded or Pending status and updates\n     * the transcoder pool using an optional list hint if needed\n     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate\'s insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool\n     /\n    function rebondWithHint(\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");\n\n        // Process rebond using unbonding lock\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using\n     * an optional list hint if needed\n     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate\'s insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool\n     /\n    function rebondFromUnbondedWithHint(\n        address _to,\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");\n\n        // Set delegator\'s start round and transition into Pending state\n        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);\n        // Set delegator\'s delegate\n        delegators[msg.sender].delegateAddress = _to;\n        // Process rebond using unbonding lock\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n    }\n\n    /\n     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed\n     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool\n     */\n    function rewardWithHint(address _newPosPrev, address _newPosNext)\n        public\n        whenSystemNotPaused\n        currentRoundInitialized\n    {\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");\n        require(\n            transcoders[msg.sender].lastRewardRound != currentRound,\n            ""caller has already called reward for the current round""\n        );\n\n        Transcoder storage t = transcoders[msg.sender];\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n\n        // Set last round that transcoder called reward\n        t.lastRewardRound = currentRound;\n        earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n        // If transcoder didn\'t receive stake updates during the previous round and hasn\'t called reward for &gt; 1 round\n        // the \'totalStake\' and \'claimableStake\' on its \'EarningsPool\' for the current round wouldn\'t be initialized\n        // Thus we sync the the transcoder\'s stake to when it was last updated\n        // \'updateTrancoderWithRewards()\' will set the update round to \'currentRound +1\' so this synchronization shouldn\'t occur frequently\n        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n        if (lastUpdateRound &lt; currentRound) {\n            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n        }\n\n        // Create reward based on active transcoder\'s stake relative to the total active stake\n        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake\n        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);\n\n        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);\n\n        emit Reward(msg.sender, rewardTokens);\n    }\n\n    /\n     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round\n     * @param _delegator Address of delegator\n     * @param _endRound The last round to compute pending stake from\n     * @return Pending bonded stake for \'_delegator\' since last claiming rewards\n     /\n    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 endRound = _endRound;\n\n        if (endRound &gt; currentRound) {\n            // Highest round we can calculate up to is the current round\n            endRound = currentRound;\n        }\n\n        Delegator storage del = delegators[_delegator];\n        uint256 currentBondedAmount = del.bondedAmount;\n\n        for (uint256 i = del.lastClaimRound + 1; i &lt;= _endRound; i++) {\n            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];\n\n            bool isTranscoder = _delegator == del.delegateAddress;\n            if (earningsPool.hasClaimableShares()) {\n                // Calculate and add reward pool share from this round\n                currentBondedAmount = currentBondedAmount.add(\n                    earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)\n                );\n            }\n        }\n\n        return currentBondedAmount;\n    }\n\n    /\n     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round\n     * @param _delegator Address of delegator\n     * @param _endRound The last round to compute pending fees from\n     * @return Pending fees for \'_delegator\' since last claiming fees\n     /\n    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 endRound = _endRound;\n\n        if (endRound &gt; currentRound) {\n            // Highest round we can calculate up to is the current round\n            endRound = currentRound;\n        }\n\n        Delegator storage del = delegators[_delegator];\n        uint256 currentFees = del.fees;\n        uint256 currentBondedAmount = del.bondedAmount;\n\n        for (uint256 i = del.lastClaimRound + 1; i &lt;= _endRound; i++) {\n            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];\n\n            if (earningsPool.hasClaimableShares()) {\n                bool isTranscoder = _delegator == del.delegateAddress;\n                // Calculate and add fee pool share from this round\n                currentFees = currentFees.add(earningsPool.feePoolShare(currentBondedAmount, isTranscoder));\n                // Calculate new bonded amount with rewards from this round. Updated bonded amount used\n                // to calculate fee pool share in next round\n                currentBondedAmount = currentBondedAmount.add(\n                    earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)\n                );\n            }\n        }\n\n        return currentFees;\n    }\n\n    /\n     * @notice Returns total bonded stake for a transcoder\n     * @param _transcoder Address of transcoder\n     * @return total bonded stake for a delegator\n     */\n    function transcoderTotalStake(address _transcoder) public view returns (uint256) {\n        return delegators[_transcoder].delegatedAmount;\n    }\n\n    /\n     * @notice Computes transcoder status\n     * @param _transcoder Address of transcoder\n     * @return registered or not registered transcoder status\n     /\n    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {\n        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;\n        return TranscoderStatus.NotRegistered;\n    }\n\n    /\n     * @notice Computes delegator status\n     * @param _delegator Address of delegator\n     * @return bonded, unbonded or pending delegator status\n     /\n    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\n        Delegator storage del = delegators[_delegator];\n\n        if (del.bondedAmount == 0) {\n            // Delegator unbonded all its tokens\n            return DelegatorStatus.Unbonded;\n        } else if (del.startRound &gt; roundsManager().currentRound()) {\n            // Delegator round start is in the future\n            return DelegatorStatus.Pending;\n        } else {\n            // Delegator round start is now or in the past\n            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\n            // would trigger the first if clause\n            return DelegatorStatus.Bonded;\n        }\n    }\n\n    /\n     * @notice Return transcoder information\n     * @param _transcoder Address of transcoder\n     * @return trancoder\'s last reward round\n     * @return transcoder\'s reward cut\n     * @return transcoder\'s fee share\n     * @return round in which transcoder\'s stake was last updated while active\n     * @return round in which transcoder became active\n     * @return round in which transcoder will no longer be active\n     */\n    function getTranscoder(address _transcoder)\n        public\n        view\n        returns (\n            uint256 lastRewardRound,\n            uint256 rewardCut,\n            uint256 feeShare,\n            uint256 lastActiveStakeUpdateRound,\n            uint256 activationRound,\n            uint256 deactivationRound\n        )\n    {\n        Transcoder storage t = transcoders[_transcoder];\n\n        lastRewardRound = t.lastRewardRound;\n        rewardCut = t.rewardCut;\n        feeShare = t.feeShare;\n        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;\n        activationRound = t.activationRound;\n        deactivationRound = t.deactivationRound;\n    }\n\n    /\n     * @notice Return transcoder\'s token pools for a given round\n     * @param _transcoder Address of transcoder\n     * @param _round Round number\n     * @return reward pool for delegates to \'_transcoder\'\n     * @return fee pool for delegates to \'_trancoder\'\n     * @return transcoder\'s total stake\n     * @return claimable stake left on transcoder\'s earningspool for \'_round\'\n     * @return transcoder\'s reward cut for \'_round\'\n     * @return transcoder\'s fee share for \'_round\'\n     * @return transcoder\'s rewards for \'_round\'\n     * @return transcoder\'s fees for \'_round\'\n     * @return true if transcoder has a split reward and fee pool\n     /\n    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)\n        public\n        view\n        returns (\n            uint256 rewardPool,\n            uint256 feePool,\n            uint256 totalStake,\n            uint256 claimableStake,\n            uint256 transcoderRewardCut,\n            uint256 transcoderFeeShare,\n            uint256 transcoderRewardPool,\n            uint256 transcoderFeePool,\n            bool hasTranscoderRewardFeePool\n        )\n    {\n        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\n\n        rewardPool = earningsPool.rewardPool;\n        feePool = earningsPool.feePool;\n        totalStake = earningsPool.totalStake;\n        claimableStake = earningsPool.claimableStake;\n        transcoderRewardCut = earningsPool.transcoderRewardCut;\n        transcoderFeeShare = earningsPool.transcoderFeeShare;\n        transcoderRewardPool = earningsPool.transcoderRewardPool;\n        transcoderFeePool = earningsPool.transcoderFeePool;\n        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;\n    }\n\n    /\n     * @notice Return delegator info\n     * @param _delegator Address of delegator\n     * @return total amount bonded by \'_delegator\'\n     * @return amount of fees collected by \'_delegator\'\n     * @return address \'_delegator\' has bonded to\n     * @return total amount delegated to \'_delegator\'\n     * @return round in which bond for \'_delegator\' became effective\n     * @return round for which \'_delegator\' has last claimed earnings\n     * @return ID for the next unbonding lock created for \'_delegator\'\n     /\n    function getDelegator(address _delegator)\n        public\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        )\n    {\n        Delegator storage del = delegators[_delegator];\n\n        bondedAmount = del.bondedAmount;\n        fees = del.fees;\n        delegateAddress = del.delegateAddress;\n        delegatedAmount = del.delegatedAmount;\n        startRound = del.startRound;\n        lastClaimRound = del.lastClaimRound;\n        nextUnbondingLockId = del.nextUnbondingLockId;\n    }\n\n    /\n     * @notice Return delegator\'s unbonding lock info\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock\n     * @return amount of stake locked up by unbonding lock\n     * @return round in which \'amount\' becomes available for withdrawal\n     */\n    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)\n        public\n        view\n        returns (uint256 amount, uint256 withdrawRound)\n    {\n        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];\n\n        return (lock.amount, lock.withdrawRound);\n    }\n\n    /\n     * @notice Returns max size of transcoder pool\n     * @return transcoder pool max size\n     /\n    function getTranscoderPoolMaxSize() public view returns (uint256) {\n        return transcoderPoolV2.getMaxSize();\n    }\n\n    /\n     * @notice Returns size of transcoder pool\n     * @return transcoder pool current size\n     /\n    function getTranscoderPoolSize() public view returns (uint256) {\n        return transcoderPoolV2.getSize();\n    }\n\n    /\n     * @notice Returns transcoder with most stake in pool\n     * @return address for transcoder with highest stake in transcoder pool\n     */\n    function getFirstTranscoderInPool() public view returns (address) {\n        return transcoderPoolV2.getFirst();\n    }\n\n    /\n     * @notice Returns next transcoder in pool for a given transcoder\n     * @param _transcoder Address of a transcoder in the pool\n     * @return address for the transcoder after \'_transcoder\' in transcoder pool\n     /\n    function getNextTranscoderInPool(address _transcoder) public view returns (address) {\n        return transcoderPoolV2.getNext(_transcoder);\n    }\n\n    /\n     * @notice Return total bonded tokens\n     * @return total active stake for the current round\n     /\n    function getTotalBonded() public view returns (uint256) {\n        return currentRoundTotalActiveStake;\n    }\n\n    /\n     * @notice Return whether a transcoder is active for the current round\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is active\n     */\n    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n        Transcoder storage t = transcoders[_transcoder];\n        uint256 currentRound = roundsManager().currentRound();\n        return t.activationRound &lt;= currentRound &amp;&amp; currentRound &lt; t.deactivationRound;\n    }\n\n    /\n     * @notice Return whether a transcoder is registered\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is self-bonded\n     /\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n        Delegator storage d = delegators[_transcoder];\n        return d.delegateAddress == _transcoder &amp;&amp; d.bondedAmount &gt; 0;\n    }\n\n    /\n     * @notice Return whether an unbonding lock for a delegator is valid\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock\n     * @return true if unbondingLock for ID has a non-zero withdraw round\n     /\n    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\n        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\n        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound &gt; 0;\n    }\n\n    /\n     * @dev Increase the total stake for a delegate and updates its \'lastActiveStakeUpdateRound\'\n     * @param _delegate The delegate to increase the stake for\n     * @param _amount The amount to increase the stake for \'_delegate\' by\n     */\n    function increaseTotalStake(\n        address _delegate,\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        if (isRegisteredTranscoder(_delegate)) {\n            uint256 newStake = transcoderTotalStake(_delegate).add(_amount);\n            uint256 nextRound = roundsManager().currentRound().add(1);\n\n            // If the transcoder is already in the active set update its stake and return\n            if (transcoderPoolV2.contains(_delegate)) {\n                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);\n                Transcoder storage t = transcoders[_delegate];\n                t.earningsPoolPerRound[nextRound].setStake(newStake);\n                t.lastActiveStakeUpdateRound = nextRound;\n            } else {\n                // Check if the transcoder is eligible to join the active set in the update round\n                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);\n            }\n        }\n\n        // Increase delegate\'s delegated amount\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);\n    }\n\n    /\n     * @dev Decrease the total stake for a delegate and updates its \'lastActiveStakeUpdateRound\'\n     * @param _delegate The transcoder to decrease the stake for\n     * @param _amount The amount to decrease the stake for \'_delegate\' by\n     /\n    function decreaseTotalStake(\n        address _delegate,\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        if (transcoderPoolV2.contains(_delegate)) {\n            uint256 newStake = transcoderTotalStake(_delegate).sub(_amount);\n            uint256 nextRound = roundsManager().currentRound().add(1);\n\n            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);\n            Transcoder storage t = transcoders[_delegate];\n            t.lastActiveStakeUpdateRound = nextRound;\n            t.earningsPoolPerRound[nextRound].setStake(newStake);\n        }\n\n        // Decrease old delegate\'s delegated amount\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);\n    }\n\n    /\n     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full\n     * @param _transcoder The transcoder to insert into the transcoder pool\n     * @param _totalStake The total stake for \'_transcoder\'\n     * @param _activationRound The round in which the transcoder should become active\n     /\n    function tryToJoinActiveSet(\n        address _transcoder,\n        uint256 _totalStake,\n        uint256 _activationRound,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;\n\n        if (transcoderPoolV2.isFull()) {\n            address lastTranscoder = transcoderPoolV2.getLast();\n            uint256 lastStake = transcoderTotalStake(lastTranscoder);\n\n            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool\n            // then the transcoder is unable to join the active set for the next round\n            if (_totalStake &lt;= lastStake) {\n                return;\n            }\n\n            // Evict the least stake transcoder from the active set for the next round\n            // Not zeroing \'Transcoder.lastActiveStakeUpdateRound\' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n            // There should be no side-effects as long as the value is properly updated on stake updates\n            // Not zeroing the stake on the current round\'s \'EarningsPool\' saves gas and should have no side effects as long as\n            // \'EarningsPool.setStake()\' is called whenever a transcoder becomes active again.\n            transcoderPoolV2.remove(lastTranscoder);\n            transcoders[lastTranscoder].deactivationRound = _activationRound;\n            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);\n\n            emit TranscoderDeactivated(lastTranscoder, _activationRound);\n        }\n\n        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);\n        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);\n        Transcoder storage t = transcoders[_transcoder];\n        t.lastActiveStakeUpdateRound = _activationRound;\n        t.activationRound = _activationRound;\n        t.deactivationRound = MAX_FUTURE_ROUND;\n        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);\n        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;\n        emit TranscoderActivated(_transcoder, _activationRound);\n    }\n\n    /\n     * @dev Remove a transcoder from the pool and deactivate it\n     */\n    function resignTranscoder(address _transcoder) internal {\n        // Not zeroing \'Transcoder.lastActiveStakeUpdateRound\' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n        // There should be no side-effects as long as the value is properly updated on stake updates\n        // Not zeroing the stake on the current round\'s \'EarningsPool\' saves gas and should have no side effects as long as\n        // \'EarningsPool.setStake()\' is called whenever a transcoder becomes active again.\n        transcoderPoolV2.remove(_transcoder);\n        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));\n        uint256 deactivationRound = roundsManager().currentRound().add(1);\n        transcoders[_transcoder].deactivationRound = deactivationRound;\n        emit TranscoderDeactivated(_transcoder, deactivationRound);\n    }\n\n    /\n     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _transcoder Address of transcoder\n     * @param _rewards Amount of rewards\n     * @param _round Round that transcoder is updated\n     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool\n     /\n    function updateTranscoderWithRewards(\n        address _transcoder,\n        uint256 _rewards,\n        uint256 _round,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\n        // Add rewards to reward pool\n        earningsPool.addToRewardPool(_rewards);\n        // Update transcoder\'s total stake with rewards\n        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);\n    }\n\n    /\n     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round\n     * @param _delegator Delegator address\n     * @param _endRound The last round for which to update a delegator\'s stake with token pools shares\n     * @param _lastClaimRound The round for which a delegator has last claimed earnings\n     /\n    function updateDelegatorWithEarnings(\n        address _delegator,\n        uint256 _endRound,\n        uint256 _lastClaimRound\n    ) internal {\n        Delegator storage del = delegators[_delegator];\n        uint256 startRound = _lastClaimRound.add(1);\n        uint256 currentBondedAmount = del.bondedAmount;\n        uint256 currentFees = del.fees;\n\n        // Only will have earnings to claim if you have a delegate\n        // If not delegated, skip the earnings claim process\n        if (del.delegateAddress != address(0)) {\n            // Cannot claim earnings for more than maxEarningsClaimsRounds\n            // This is a number to cause transactions to fail early if\n            // we know they will require too much gas to loop through all the necessary rounds to claim earnings\n            // The user should instead manually invoke claimEarnings to split up the claiming process\n            // across multiple transactions\n            require(_endRound.sub(_lastClaimRound) &lt;= maxEarningsClaimsRounds, ""too many rounds to claim through"");\n\n            for (uint256 i = startRound; i &lt;= _endRound; i++) {\n                EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];\n\n                if (earningsPool.hasClaimableShares()) {\n                    (uint256 fees, uint256 rewards) = earningsPool.claimShare(\n                        currentBondedAmount,\n                        _delegator == del.delegateAddress\n                    );\n\n                    currentFees = currentFees.add(fees);\n                    currentBondedAmount = currentBondedAmount.add(rewards);\n                }\n            }\n        }\n\n        emit EarningsClaimed(\n            del.delegateAddress,\n            _delegator,\n            currentBondedAmount.sub(del.bondedAmount),\n            currentFees.sub(del.fees),\n            startRound,\n            _endRound\n        );\n\n        del.lastClaimRound = _endRound;\n        // Rewards are bonded by default\n        del.bondedAmount = currentBondedAmount;\n        del.fees = currentFees;\n    }\n\n    /\n     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional\n     * list hint if needed. See SortedDoublyLL.sol for details on list hints\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool\n     */\n    function processRebond(\n        address _delegator,\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        Delegator storage del = delegators[_delegator];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");\n\n        uint256 amount = lock.amount;\n        // Increase delegator\'s bonded amount\n        del.bondedAmount = del.bondedAmount.add(amount);\n\n        // Delete lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);\n\n        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);\n    }\n\n    /\n     * @dev Return LivepeerToken interface\n     * @return Livepeer token contract registered with Controller\n     /\n    function livepeerToken() internal view returns (ILivepeerToken) {\n        return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken"")));\n    }\n\n    /\n     * @dev Return Minter interface\n     * @return Minter contract registered with Controller\n     /\n    function minter() internal view returns (IMinter) {\n        return IMinter(controller.getContract(keccak256(""Minter"")));\n    }\n\n    /*\n     * @dev Return RoundsManager interface\n     * @return RoundsManager contract registered with Controller\n     /\n    function roundsManager() internal view returns (IRoundsManager) {\n        return IRoundsManager(controller.getContract(keccak256(""RoundsManager"")));\n    }\n}\n', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nThe contract uses low-level calls to transfer tokens and withdraw fees without checking the success of these calls. Specifically, the following instances are identified:\n\n1. In the `withdrawStake` function:\nsolidity\n   minter().trustedTransferTokens(msg.sender, amount);\n   \n   If the `trustedTransferTokens` function fails, the transaction will not revert, and the user may lose their funds without any indication of failure.\n\n2. In the `withdrawFees` function:\nsolidity\n   minter().trustedWithdrawETH(msg.sender, amount);\n   \n   Similar to the previous case, if the `trustedWithdrawETH` function fails, the transaction will not revert, leading to potential loss of funds.\n\nRecommended Mitigation:\nTo mitigate this vulnerability, it is essential to check the return value of low-level calls and revert the transaction if the call fails. This can be done by using the following pattern:\n\nsolidity\n(bool success, ) = address(minter()).call(abi.encodeWithSignature(""trustedTransferTokens(address,uint256)"", msg.sender, amount));\nrequire(success, ""Transfer failed"");\n\n\nThis ensures that if the call fails, the transaction will revert, preventing any loss of funds and maintaining the integrity of the contract\'s operations.\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-10-08 17:17:21 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | pragma solidity ^0.5.11; import ""../../ManagerProxyTarget.sol""; import ""../IBondingManager.sol""; import ""../../libraries/SortedDoublyLL.sol""; import ""../../libraries/MathUtils.sol""; import ""./EarningsPoolPreLIP36.sol""; import ""../../token/ILivepeerToken.sol""; import ""../../token/IMinter.sol""; import ""../../rounds/IRoundsManager.sol""; import ""openzeppelin-solidity/contracts/math/SafeMath.sol""; /*  * @title BondingManager  * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol  / contract BondingManagerPreLIP36 is ManagerProxyTarget, IBondingManager {     using SafeMath for uint256;     using SortedDoublyLL for SortedDoublyLL.Data;     using EarningsPool for EarningsPool.Data; // Constants // Occurances are replaced at compile time // and computed to a single value if possible by the optimizer uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;  // Time between unbonding and possible withdrawl in rounds uint64 public unbondingPeriod; // DEPRECATED - DO NOT USE uint256 public numActiveTranscodersDEPRECATED; // Max number of rounds that a caller can claim earnings for at once uint256 public maxEarningsClaimsRounds;  // Represents a transcoder's current state struct Transcoder {     uint256 lastRewardRound; // Last round that the transcoder called reward     uint256 rewardCut; // % of reward paid to transcoder by a delegator     uint256 feeShare; // % of fees paid to delegators by transcoder     uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     mapping(uint256 =&gt; EarningsPool.Data) earningsPoolPerRound; // Mapping of round =&gt; earnings pool for the round     uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active     uint256 activationRound; // Round in which the transcoder became active - 0 if inactive     uint256 deactivationRound; // Round in which the transcoder will become inactive }  // The various states a transcoder can be in enum TranscoderStatus {     NotRegistered,     Registered }  // Represents a delegator's current state struct Delegator {     uint256 bondedAmount; // The amount of bonded tokens     uint256 fees; // The amount of fees collected     address delegateAddress; // The address delegated to     uint256 delegatedAmount; // The amount of tokens delegated to the delegator     uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone     uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE     uint256 lastClaimRound; // The last round during which the delegator claimed its earnings     uint256 nextUnbondingLockId; // ID for the next unbonding lock created     mapping(uint256 =&gt; UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID =&gt; unbonding lock }  // The various states a delegator can be in enum DelegatorStatus {     Pending,     Bonded,     Unbonded }  // Represents an amount of tokens that are being unbonded struct UnbondingLock {     uint256 amount; // Amount of tokens being unbonded     uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn }  // Keep track of the known transcoders and delegators mapping(address =&gt; Delegator) private delegators; mapping(address =&gt; Transcoder) private transcoders;  // DEPRECATED - DO NOT USE // The function getTotalBonded() no longer uses this variable // and instead calculates the total bonded value separately uint256 private totalBondedDEPRECATED;  // DEPRECATED - DO NOT USE SortedDoublyLL.Data private transcoderPoolDEPRECATED;  // DEPRECATED - DO NOT USE struct ActiveTranscoderSetDEPRECATED {     address[] transcoders;     mapping(address =&gt; bool) isActive;     uint256 totalStake; }  // DEPRECATED - DO NOT USE mapping(uint256 =&gt; ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;  // The total active stake (sum of the stake of active set members) for the current round uint256 public currentRoundTotalActiveStake; // The total active stake (sum of the stake of active set members) for the next round uint256 public nextRoundTotalActiveStake;  // The transcoder pool is used to keep track of the transcoders that are eligible for activation. // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders // in the pool are locked into the active set for round N + 1 SortedDoublyLL.Data private transcoderPoolV2;  // Check if sender is TicketBroker modifier onlyTicketBroker() {     require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");     _; }  // Check if sender is RoundsManager modifier onlyRoundsManager() {     require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");     _; }  // Check if sender is Verifier modifier onlyVerifier() {     require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");     _; }  // Check if current round is initialized modifier currentRoundInitialized() {     require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");     _; }  // Automatically claim earnings from lastClaimRound through the current round modifier autoClaimEarnings() {     uint256 currentRound = roundsManager().currentRound();     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     if (lastClaimRound &lt; currentRound) {         updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);     }     _; }  /**  * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address  * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions  * should be used to initialize state variables post-deployment:  * - setUnbondingPeriod()  * - setNumActiveTranscoders()  * - setMaxEarningsClaimsRounds()  * @param _controller Address of Controller that this contract will be registered with  */ constructor(address _controller) public Manager(_controller) {}  /**  * @notice Set unbonding period. Only callable by Controller owner  * @param _unbondingPeriod Rounds between unbonding and possible withdrawal  */ function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {     unbondingPeriod = _unbondingPeriod;      emit ParameterUpdate(""unbondingPeriod""); }  /**  * @notice Set maximum number of active transcoders. Only callable by Controller owner  * @param _numActiveTranscoders Number of active transcoders  */ function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {     transcoderPoolV2.setMaxSize(_numActiveTranscoders);      emit ParameterUpdate(""numActiveTranscoders""); }  /**  * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner  * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once  */ function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {     maxEarningsClaimsRounds = _maxEarningsClaimsRounds;      emit ParameterUpdate(""maxEarningsClaimsRounds""); }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  */ function transcoder(uint256 _rewardCut, uint256 _feeShare) external {     transcoderWithHint(_rewardCut, _feeShare, address(0), address(0)); }  /**  * @notice Delegate stake towards a specific address  * @param _amount The amount of tokens to stake  * @param _to The address of the transcoder to stake towards  */ function bond(uint256 _amount, address _to) external {     bondWithHint(_amount, _to, address(0), address(0), address(0), address(0)); }  /**  * @notice Unbond an amount of the delegator's bonded stake  * @param _amount Amount of tokens to unbond  */ function unbond(uint256 _amount) external {     unbondWithHint(_amount, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebond(uint256 _unbondingLockId) external {     rebondWithHint(_unbondingLockId, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {     rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0)); }  /**  * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period  * @param _unbondingLockId ID of unbonding lock to withdraw with  */ function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {     Delegator storage del = delegators[msg.sender];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");     require(         lock.withdrawRound &lt;= roundsManager().currentRound(),         ""withdraw round must be before or equal to the current round""     );      uint256 amount = lock.amount;     uint256 withdrawRound = lock.withdrawRound;     // Delete unbonding lock     delete del.unbondingLocks[_unbondingLockId];      // Tell Minter to transfer stake (LPT) to the delegator     minter().trustedTransferTokens(msg.sender, amount);      emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound); }  /**  * @notice Withdraws fees to the caller  */ function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegators[msg.sender].fees &gt; 0, ""no fees to withdraw"");      uint256 amount = delegators[msg.sender].fees;     delegators[msg.sender].fees = 0;      // Tell Minter to transfer fees (ETH) to the delegator     minter().trustedWithdrawETH(msg.sender, amount);      emit WithdrawFees(msg.sender); }  /**  * @notice Mint token rewards for an active transcoder and its delegators  */ function reward() external {     rewardWithHint(address(0), address(0)); }  /**  * @notice Update transcoder's fee pool. Only callable by the TicketBroker  * @param _transcoder Transcoder address  * @param _fees Fees to be added to the fee pool  */ function updateTranscoderWithFees(     address _transcoder,     uint256 _fees,     uint256 _round ) external whenSystemNotPaused onlyTicketBroker {     require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");      Transcoder storage t = transcoders[_transcoder];      EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];      // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare' and 'transcoderRewardCut'     // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected     if (_round &gt; t.lastRewardRound) {         earningsPool.setCommission(t.rewardCut, t.feeShare);     }      // Add fees to fee pool     earningsPool.addToFeePool(_fees); }  /**  * @notice Slash a transcoder. Only callable by the Verifier  * @param _transcoder Transcoder address  * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder  * @param _slashAmount Percentage of transcoder bond to be slashed  * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder  */ function slashTranscoder(     address _transcoder,     address _finder,     uint256 _slashAmount,     uint256 _finderFee ) external whenSystemNotPaused onlyVerifier {     Delegator storage del = delegators[_transcoder];      if (del.bondedAmount &gt; 0) {         uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);          // If active transcoder, resign it         if (transcoderPoolV2.contains(_transcoder)) {             resignTranscoder(_transcoder);         }          // Decrease bonded stake         del.bondedAmount = del.bondedAmount.sub(penalty);          // If still bonded decrease delegate's delegated amount         if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {             delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(                 penalty             );         }          // Account for penalty         uint256 burnAmount = penalty;          // Award finder fee if there is a finder address         if (_finder != address(0)) {             uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);             minter().trustedTransferTokens(_finder, finderAmount);              // Minter burns the slashed funds - finder reward             minter().trustedBurnTokens(burnAmount.sub(finderAmount));              emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);         } else {             // Minter burns the slashed funds             minter().trustedBurnTokens(burnAmount);              emit TranscoderSlashed(_transcoder, address(0), penalty, 0);         }     } else {         emit TranscoderSlashed(_transcoder, _finder, 0, 0);     } }  /**  * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round  * @param _endRound The last round for which to claim token pools shares for a delegator  */ function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     require(lastClaimRound &lt; _endRound, ""end round must be after last claim round"");     require(_endRound &lt;= roundsManager().currentRound(), ""end round must be before or equal to current round"");      updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound); }  /**  * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager  */ function setCurrentRoundTotalActiveStake() external onlyRoundsManager {     currentRoundTotalActiveStake = nextRoundTotalActiveStake; }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the  * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will  * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.  * See SortedDoublyLL.sol for details on list hints  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool  * @param _newPosNext Address of next transcoder in pool if the caller joins the pool  */ function transcoderWithHint(     uint256 _rewardCut,     uint256 _feeShare,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized {     require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");     require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");     require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");     require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");      Transcoder storage t = transcoders[msg.sender];     uint256 currentRound = roundsManager().currentRound();      require(         !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,         ""caller can't be active or must have already called reward for the current round""     );      t.rewardCut = _rewardCut;     t.feeShare = _feeShare;      if (!transcoderPoolV2.contains(msg.sender)) {         tryToJoinActiveSet(             msg.sender,             delegators[msg.sender].delegatedAmount,             currentRound.add(1),             _newPosPrev,             _newPosNext         );     }      emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare); }  /**  * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed  * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint  * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.  * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the  * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.  * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint  * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _amount The amount of tokens to stake.  * @param _to The address of the transcoder to stake towards  * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate  * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate  * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate  * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate  */ function bondWithHint(     uint256 _amount,     address _to,     address _oldDelegateNewPosPrev,     address _oldDelegateNewPosNext,     address _currDelegateNewPosPrev,     address _currDelegateNewPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     Delegator storage del = delegators[msg.sender];      uint256 currentRound = roundsManager().currentRound();     // Amount to delegate     uint256 delegationAmount = _amount;     // Current delegate     address currentDelegate = del.delegateAddress;      if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {         // New delegate         // Set start round         // Don't set start round if delegator is in pending state because the start round would not change         del.startRound = currentRound.add(1);         // Unbonded state = no existing delegate and no bonded stake         // Thus, delegation amount = provided amount     } else if (currentDelegate != address(0) &amp;&amp; currentDelegate != _to) {         // A registered transcoder cannot delegate its bonded stake toward another address         // because it can only be delegated toward itself         // In the future, if delegation towards another registered transcoder as an already         // registered transcoder becomes useful (i.e. for transitive delegation), this restriction         // could be removed         require(             !isRegisteredTranscoder(msg.sender),             ""registered transcoders can't delegate towards other addresses""         );         // Changing delegate         // Set start round         del.startRound = currentRound.add(1);         // Update amount to delegate with previous delegation amount         delegationAmount = delegationAmount.add(del.bondedAmount);          decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);     }      // cannot delegate to someone without having bonded stake     require(delegationAmount &gt; 0, ""delegation amount must be greater than 0"");     // Update delegate     del.delegateAddress = _to;     // Update bonded amount     del.bondedAmount = del.bondedAmount.add(_amount);      increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);      if (_amount &gt; 0) {         // Transfer the LPT to the Minter         livepeerToken().transferFrom(msg.sender, address(minter()), _amount);     }      emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount); }  /**  * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed  * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _amount Amount of tokens to unbond  * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool  * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool  */ function unbondWithHint(     uint256 _amount,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");      Delegator storage del = delegators[msg.sender];      require(_amount &gt; 0, ""unbond amount must be greater than 0"");     require(_amount &lt;= del.bondedAmount, ""amount is greater than bonded amount"");      address currentDelegate = del.delegateAddress;     uint256 currentRound = roundsManager().currentRound();     uint256 withdrawRound = currentRound.add(unbondingPeriod);     uint256 unbondingLockId = del.nextUnbondingLockId;      // Create new unbonding lock     del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });     // Increment ID for next unbonding lock     del.nextUnbondingLockId = unbondingLockId.add(1);     // Decrease delegator's bonded amount     del.bondedAmount = del.bondedAmount.sub(_amount);      if (del.bondedAmount == 0) {         // Delegator no longer delegated to anyone if it does not have a bonded amount         del.delegateAddress = address(0);         // Delegator does not have a start round if it is no longer delegated to anyone         del.startRound = 0;          if (transcoderPoolV2.contains(msg.sender)) {             resignTranscoder(msg.sender);         }     }      // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount     decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);      emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates  * the transcoder pool using an optional list hint if needed  * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool  */ function rebondWithHint(     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");      // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using  * an optional list hint if needed  * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool  */ function rebondFromUnbondedWithHint(     address _to,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");      // Set delegator's start round and transition into Pending state     delegators[msg.sender].startRound = roundsManager().currentRound().add(1);     // Set delegator's delegate     delegators[msg.sender].delegateAddress = _to;     // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed  * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool  * @param _newPosNext Address of next transcoder in pool if the caller is in the pool  */ function rewardWithHint(address _newPosPrev, address _newPosNext)     public     whenSystemNotPaused     currentRoundInitialized {     uint256 currentRound = roundsManager().currentRound();      require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");     require(         transcoders[msg.sender].lastRewardRound != currentRound,         ""caller has already called reward for the current round""     );      Transcoder storage t = transcoders[msg.sender];     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];      // Set last round that transcoder called reward     t.lastRewardRound = currentRound;     earningsPool.setCommission(t.rewardCut, t.feeShare);      // If transcoder didn't receive stake updates during the previous round and hasn't called reward for &gt; 1 round     // the 'totalStake' and 'claimableStake' on its 'EarningsPool' for the current round wouldn't be initialized     // Thus we sync the the transcoder's stake to when it was last updated     // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently     uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;     if (lastUpdateRound &lt; currentRound) {         earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);     }      // Create reward based on active transcoder's stake relative to the total active stake     // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake     uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);      updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);      emit Reward(msg.sender, rewardTokens); }  /**  * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending stake from  * @return Pending bonded stake for '_delegator' since last claiming rewards  */ function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {     uint256 currentRound = roundsManager().currentRound();     uint256 endRound = _endRound;      if (endRound &gt; currentRound) {         // Highest round we can calculate up to is the current round         endRound = currentRound;     }      Delegator storage del = delegators[_delegator];     uint256 currentBondedAmount = del.bondedAmount;      for (uint256 i = del.lastClaimRound + 1; i &lt;= _endRound; i++) {         EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];          bool isTranscoder = _delegator == del.delegateAddress;         if (earningsPool.hasClaimableShares()) {             // Calculate and add reward pool share from this round             currentBondedAmount = currentBondedAmount.add(                 earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)             );         }     }      return currentBondedAmount; }  /**  * @notice Returns pending fees for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending fees from  * @return Pending fees for '_delegator' since last claiming fees  */ function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {     uint256 currentRound = roundsManager().currentRound();     uint256 endRound = _endRound;      if (endRound &gt; currentRound) {         // Highest round we can calculate up to is the current round         endRound = currentRound;     }      Delegator storage del = delegators[_delegator];     uint256 currentFees = del.fees;     uint256 currentBondedAmount = del.bondedAmount;      for (uint256 i = del.lastClaimRound + 1; i &lt;= _endRound; i++) {         EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];          if (earningsPool.hasClaimableShares()) {             bool isTranscoder = _delegator == del.delegateAddress;             // Calculate and add fee pool share from this round             currentFees = currentFees.add(earningsPool.feePoolShare(currentBondedAmount, isTranscoder));             // Calculate new bonded amount with rewards from this round. Updated bonded amount used             // to calculate fee pool share in next round             currentBondedAmount = currentBondedAmount.add(                 earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)             );         }     }      return currentFees; }  /**  * @notice Returns total bonded stake for a transcoder  * @param _transcoder Address of transcoder  * @return total bonded stake for a delegator  */ function transcoderTotalStake(address _transcoder) public view returns (uint256) {     return delegators[_transcoder].delegatedAmount; }  /**  * @notice Computes transcoder status  * @param _transcoder Address of transcoder  * @return registered or not registered transcoder status  */ function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {     if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;     return TranscoderStatus.NotRegistered; }  /**  * @notice Computes delegator status  * @param _delegator Address of delegator  * @return bonded, unbonded or pending delegator status  */ function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {     Delegator storage del = delegators[_delegator];      if (del.bondedAmount == 0) {         // Delegator unbonded all its tokens         return DelegatorStatus.Unbonded;     } else if (del.startRound &gt; roundsManager().currentRound()) {         // Delegator round start is in the future         return DelegatorStatus.Pending;     } else {         // Delegator round start is now or in the past         // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which         // would trigger the first if clause         return DelegatorStatus.Bonded;     } }  /**  * @notice Return transcoder information  * @param _transcoder Address of transcoder  * @return trancoder's last reward round  * @return transcoder's reward cut  * @return transcoder's fee share  * @return round in which transcoder's stake was last updated while active  * @return round in which transcoder became active  * @return round in which transcoder will no longer be active  */ function getTranscoder(address _transcoder)     public     view     returns (         uint256 lastRewardRound,         uint256 rewardCut,         uint256 feeShare,         uint256 lastActiveStakeUpdateRound,         uint256 activationRound,         uint256 deactivationRound     ) {     Transcoder storage t = transcoders[_transcoder];      lastRewardRound = t.lastRewardRound;     rewardCut = t.rewardCut;     feeShare = t.feeShare;     lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;     activationRound = t.activationRound;     deactivationRound = t.deactivationRound; }  /**  * @notice Return transcoder's token pools for a given round  * @param _transcoder Address of transcoder  * @param _round Round number  * @return reward pool for delegates to '_transcoder'  * @return fee pool for delegates to '_trancoder'  * @return transcoder's total stake  * @return claimable stake left on transcoder's earningspool for '_round'  * @return transcoder's reward cut for '_round'  * @return transcoder's fee share for '_round'  * @return transcoder's rewards for '_round'  * @return transcoder's fees for '_round'  * @return true if transcoder has a split reward and fee pool  */ function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)     public     view     returns (         uint256 rewardPool,         uint256 feePool,         uint256 totalStake,         uint256 claimableStake,         uint256 transcoderRewardCut,         uint256 transcoderFeeShare,         uint256 transcoderRewardPool,         uint256 transcoderFeePool,         bool hasTranscoderRewardFeePool     ) {     EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];      rewardPool = earningsPool.rewardPool;     feePool = earningsPool.feePool;     totalStake = earningsPool.totalStake;     claimableStake = earningsPool.claimableStake;     transcoderRewardCut = earningsPool.transcoderRewardCut;     transcoderFeeShare = earningsPool.transcoderFeeShare;     transcoderRewardPool = earningsPool.transcoderRewardPool;     transcoderFeePool = earningsPool.transcoderFeePool;     hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool; }  /**  * @notice Return delegator info  * @param _delegator Address of delegator  * @return total amount bonded by '_delegator'  * @return amount of fees collected by '_delegator'  * @return address '_delegator' has bonded to  * @return total amount delegated to '_delegator'  * @return round in which bond for '_delegator' became effective  * @return round for which '_delegator' has last claimed earnings  * @return ID for the next unbonding lock created for '_delegator'  */ function getDelegator(address _delegator)     public     view     returns (         uint256 bondedAmount,         uint256 fees,         address delegateAddress,         uint256 delegatedAmount,         uint256 startRound,         uint256 lastClaimRound,         uint256 nextUnbondingLockId     ) {     Delegator storage del = delegators[_delegator];      bondedAmount = del.bondedAmount;     fees = del.fees;     delegateAddress = del.delegateAddress;     delegatedAmount = del.delegatedAmount;     startRound = del.startRound;     lastClaimRound = del.lastClaimRound;     nextUnbondingLockId = del.nextUnbondingLockId; }  /**  * @notice Return delegator's unbonding lock info  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return amount of stake locked up by unbonding lock  * @return round in which 'amount' becomes available for withdrawal  */ function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)     public     view     returns (uint256 amount, uint256 withdrawRound) {     UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];      return (lock.amount, lock.withdrawRound); }  /**  * @notice Returns max size of transcoder pool  * @return transcoder pool max size  */ function getTranscoderPoolMaxSize() public view returns (uint256) {     return transcoderPoolV2.getMaxSize(); }  /**  * @notice Returns size of transcoder pool  * @return transcoder pool current size  */ function getTranscoderPoolSize() public view returns (uint256) {     return transcoderPoolV2.getSize(); }  /**  * @notice Returns transcoder with most stake in pool  * @return address for transcoder with highest stake in transcoder pool  */ function getFirstTranscoderInPool() public view returns (address) {     return transcoderPoolV2.getFirst(); }  /**  * @notice Returns next transcoder in pool for a given transcoder  * @param _transcoder Address of a transcoder in the pool  * @return address for the transcoder after '_transcoder' in transcoder pool  */ function getNextTranscoderInPool(address _transcoder) public view returns (address) {     return transcoderPoolV2.getNext(_transcoder); }  /**  * @notice Return total bonded tokens  * @return total active stake for the current round  */ function getTotalBonded() public view returns (uint256) {     return currentRoundTotalActiveStake; }  /**  * @notice Return whether a transcoder is active for the current round  * @param _transcoder Transcoder address  * @return true if transcoder is active  */ function isActiveTranscoder(address _transcoder) public view returns (bool) {     Transcoder storage t = transcoders[_transcoder];     uint256 currentRound = roundsManager().currentRound();     return t.activationRound &lt;= currentRound &amp;&amp; currentRound &lt; t.deactivationRound; }  /**  * @notice Return whether a transcoder is registered  * @param _transcoder Transcoder address  * @return true if transcoder is self-bonded  */ function isRegisteredTranscoder(address _transcoder) public view returns (bool) {     Delegator storage d = delegators[_transcoder];     return d.delegateAddress == _transcoder &amp;&amp; d.bondedAmount &gt; 0; }  /**  * @notice Return whether an unbonding lock for a delegator is valid  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return true if unbondingLock for ID has a non-zero withdraw round  */ function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {     // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)     return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound &gt; 0; }  /**  * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The delegate to increase the stake for  * @param _amount The amount to increase the stake for '_delegate' by  */ function increaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (isRegisteredTranscoder(_delegate)) {         uint256 newStake = transcoderTotalStake(_delegate).add(_amount);         uint256 nextRound = roundsManager().currentRound().add(1);          // If the transcoder is already in the active set update its stake and return         if (transcoderPoolV2.contains(_delegate)) {             transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);             nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);             Transcoder storage t = transcoders[_delegate];             t.earningsPoolPerRound[nextRound].setStake(newStake);             t.lastActiveStakeUpdateRound = nextRound;         } else {             // Check if the transcoder is eligible to join the active set in the update round             tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);         }     }      // Increase delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount); }  /**  * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The transcoder to decrease the stake for  * @param _amount The amount to decrease the stake for '_delegate' by  */ function decreaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (transcoderPoolV2.contains(_delegate)) {         uint256 newStake = transcoderTotalStake(_delegate).sub(_amount);         uint256 nextRound = roundsManager().currentRound().add(1);          transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);         nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);         Transcoder storage t = transcoders[_delegate];         t.lastActiveStakeUpdateRound = nextRound;         t.earningsPoolPerRound[nextRound].setStake(newStake);     }      // Decrease old delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount); }  /**  * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full  * @param _transcoder The transcoder to insert into the transcoder pool  * @param _totalStake The total stake for '_transcoder'  * @param _activationRound The round in which the transcoder should become active  */ function tryToJoinActiveSet(     address _transcoder,     uint256 _totalStake,     uint256 _activationRound,     address _newPosPrev,     address _newPosNext ) internal {     uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;      if (transcoderPoolV2.isFull()) {         address lastTranscoder = transcoderPoolV2.getLast();         uint256 lastStake = transcoderTotalStake(lastTranscoder);          // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool         // then the transcoder is unable to join the active set for the next round         if (_totalStake &lt;= lastStake) {             return;         }          // Evict the least stake transcoder from the active set for the next round         // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)         // There should be no side-effects as long as the value is properly updated on stake updates         // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as         // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.         transcoderPoolV2.remove(lastTranscoder);         transcoders[lastTranscoder].deactivationRound = _activationRound;         pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);          emit TranscoderDeactivated(lastTranscoder, _activationRound);     }      transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);     pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);     Transcoder storage t = transcoders[_transcoder];     t.lastActiveStakeUpdateRound = _activationRound;     t.activationRound = _activationRound;     t.deactivationRound = MAX_FUTURE_ROUND;     t.earningsPoolPerRound[_activationRound].setStake(_totalStake);     nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;     emit TranscoderActivated(_transcoder, _activationRound); }  /**  * @dev Remove a transcoder from the pool and deactivate it  */ function resignTranscoder(address _transcoder) internal {     // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)     // There should be no side-effects as long as the value is properly updated on stake updates     // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as     // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.     transcoderPoolV2.remove(_transcoder);     nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));     uint256 deactivationRound = roundsManager().currentRound().add(1);     transcoders[_transcoder].deactivationRound = deactivationRound;     emit TranscoderDeactivated(_transcoder, deactivationRound); }  /**  * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.  * See SortedDoublyLL.sol for details on list hints  * @param _transcoder Address of transcoder  * @param _rewards Amount of rewards  * @param _round Round that transcoder is updated  * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool  * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool  */ function updateTranscoderWithRewards(     address _transcoder,     uint256 _rewards,     uint256 _round,     address _newPosPrev,     address _newPosNext ) internal {     EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];     // Add rewards to reward pool     earningsPool.addToRewardPool(_rewards);     // Update transcoder's total stake with rewards     increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext); }  /**  * @dev Update a delegator with token pools shares from its lastClaimRound through a given round  * @param _delegator Delegator address  * @param _endRound The last round for which to update a delegator's stake with token pools shares  * @param _lastClaimRound The round for which a delegator has last claimed earnings  */ function updateDelegatorWithEarnings(     address _delegator,     uint256 _endRound,     uint256 _lastClaimRound ) internal {     Delegator storage del = delegators[_delegator];     uint256 startRound = _lastClaimRound.add(1);     uint256 currentBondedAmount = del.bondedAmount;     uint256 currentFees = del.fees;      // Only will have earnings to claim if you have a delegate     // If not delegated, skip the earnings claim process     if (del.delegateAddress != address(0)) {         // Cannot claim earnings for more than maxEarningsClaimsRounds         // This is a number to cause transactions to fail early if         // we know they will require too much gas to loop through all the necessary rounds to claim earnings         // The user should instead manually invoke `claimEarnings` to split up the claiming process         // across multiple transactions         require(_endRound.sub(_lastClaimRound) &lt;= maxEarningsClaimsRounds, ""too many rounds to claim through"");          for (uint256 i = startRound; i &lt;= _endRound; i++) {             EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];              if (earningsPool.hasClaimableShares()) {                 (uint256 fees, uint256 rewards) = earningsPool.claimShare(                     currentBondedAmount,                     _delegator == del.delegateAddress                 );                  currentFees = currentFees.add(fees);                 currentBondedAmount = currentBondedAmount.add(rewards);             }         }     }      emit EarningsClaimed(         del.delegateAddress,         _delegator,         currentBondedAmount.sub(del.bondedAmount),         currentFees.sub(del.fees),         startRound,         _endRound     );      del.lastClaimRound = _endRound;     // Rewards are bonded by default     del.bondedAmount = currentBondedAmount;     del.fees = currentFees; }  /**  * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional  * list hint if needed. See SortedDoublyLL.sol for details on list hints  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool  */ function processRebond(     address _delegator,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) internal {     Delegator storage del = delegators[_delegator];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");      uint256 amount = lock.amount;     // Increase delegator's bonded amount     del.bondedAmount = del.bondedAmount.add(amount);      // Delete lock     delete del.unbondingLocks[_unbondingLockId];      increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);      emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount); }  /**  * @dev Return LivepeerToken interface  * @return Livepeer token contract registered with Controller  */ function livepeerToken() internal view returns (ILivepeerToken) {     return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken""))); }  /**  * @dev Return Minter interface  * @return Minter contract registered with Controller  */ function minter() internal view returns (IMinter) {     return IMinter(controller.getContract(keccak256(""Minter""))); }  /**  * @dev Return RoundsManager interface  * @return RoundsManager contract registered with Controller  */ function roundsManager() internal view returns (IRoundsManager) {     return IRoundsManager(controller.getContract(keccak256(""RoundsManager""))); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-10-08 17:17:21 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.11;

import ""../../ManagerProxyTarget.sol"";
import ""../IBondingManager.sol"";
import ""../../libraries/SortedDoublyLL.sol"";
import ""../../libraries/MathUtils.sol"";
import ""./EarningsPoolPreLIP36.sol"";
import ""../../token/ILivepeerToken.sol"";
import ""../../token/IMinter.sol"";
import ""../../rounds/IRoundsManager.sol"";

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

/**
 * @title BondingManager
 * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol
 */
contract BondingManagerPreLIP36 is ManagerProxyTarget, IBondingManager {
    using SafeMath for uint256;
    using SortedDoublyLL for SortedDoublyLL.Data;
    using EarningsPool for EarningsPool.Data;

    // Constants
    // Occurances are replaced at compile time
    // and computed to a single value if possible by the optimizer
    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;

    // Time between unbonding and possible withdrawl in rounds
    uint64 public unbondingPeriod;
    // DEPRECATED - DO NOT USE
    uint256 public numActiveTranscodersDEPRECATED;
    // Max number of rounds that a caller can claim earnings for at once
    uint256 public maxEarningsClaimsRounds;

    // Represents a transcoder's current state
    struct Transcoder {
        uint256 lastRewardRound; // Last round that the transcoder called reward
        uint256 rewardCut; // % of reward paid to transcoder by a delegator
        uint256 feeShare; // % of fees paid to delegators by transcoder
        uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round
        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active
        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive
        uint256 deactivationRound; // Round in which the transcoder will become inactive
    }

    // The various states a transcoder can be in
    enum TranscoderStatus {
        NotRegistered,
        Registered
    }

    // Represents a delegator's current state
    struct Delegator {
        uint256 bondedAmount; // The amount of bonded tokens
        uint256 fees; // The amount of fees collected
        address delegateAddress; // The address delegated to
        uint256 delegatedAmount; // The amount of tokens delegated to the delegator
        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone
        uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings
        uint256 nextUnbondingLockId; // ID for the next unbonding lock created
        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock
    }

    // The various states a delegator can be in
    enum DelegatorStatus {
        Pending,
        Bonded,
        Unbonded
    }

    // Represents an amount of tokens that are being unbonded
    struct UnbondingLock {
        uint256 amount; // Amount of tokens being unbonded
        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn
    }

    // Keep track of the known transcoders and delegators
    mapping(address => Delegator) private delegators;
    mapping(address => Transcoder) private transcoders;

    // DEPRECATED - DO NOT USE
    // The function getTotalBonded() no longer uses this variable
    // and instead calculates the total bonded value separately
    uint256 private totalBondedDEPRECATED;

    // DEPRECATED - DO NOT USE
    SortedDoublyLL.Data private transcoderPoolDEPRECATED;

    // DEPRECATED - DO NOT USE
    struct ActiveTranscoderSetDEPRECATED {
        address[] transcoders;
        mapping(address => bool) isActive;
        uint256 totalStake;
    }

    // DEPRECATED - DO NOT USE
    mapping(uint256 => ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;

    // The total active stake (sum of the stake of active set members) for the current round
    uint256 public currentRoundTotalActiveStake;
    // The total active stake (sum of the stake of active set members) for the next round
    uint256 public nextRoundTotalActiveStake;

    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.
    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders
    // in the pool are locked into the active set for round N + 1
    SortedDoublyLL.Data private transcoderPoolV2;

    // Check if sender is TicketBroker
    modifier onlyTicketBroker() {
        require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");
        _;
    }

    // Check if sender is RoundsManager
    modifier onlyRoundsManager() {
        require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");
        _;
    }

    // Check if sender is Verifier
    modifier onlyVerifier() {
        require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");
        _;
    }

    // Check if current round is initialized
    modifier currentRoundInitialized() {
        require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");
        _;
    }

    // Automatically claim earnings from lastClaimRound through the current round
    modifier autoClaimEarnings() {
        uint256 currentRound = roundsManager().currentRound();
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        if (lastClaimRound < currentRound) {
            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);
        }
        _;
    }

    /**
     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address
     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions
     * should be used to initialize state variables post-deployment:
     * - setUnbondingPeriod()
     * - setNumActiveTranscoders()
     * - setMaxEarningsClaimsRounds()
     * @param _controller Address of Controller that this contract will be registered with
     */
    constructor(address _controller) public Manager(_controller) {}

    /**
     * @notice Set unbonding period. Only callable by Controller owner
     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal
     */
    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {
        unbondingPeriod = _unbondingPeriod;

        emit ParameterUpdate(""unbondingPeriod"");
    }

    /**
     * @notice Set maximum number of active transcoders. Only callable by Controller owner
     * @param _numActiveTranscoders Number of active transcoders
     */
    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {
        transcoderPoolV2.setMaxSize(_numActiveTranscoders);

        emit ParameterUpdate(""numActiveTranscoders"");
    }

    /**
     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner
     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once
     */
    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {
        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;

        emit ParameterUpdate(""maxEarningsClaimsRounds"");
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     */
    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {
        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));
    }

    /**
     * @notice Delegate stake towards a specific address
     * @param _amount The amount of tokens to stake
     * @param _to The address of the transcoder to stake towards
     */
    function bond(uint256 _amount, address _to) external {
        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake
     * @param _amount Amount of tokens to unbond
     */
    function unbond(uint256 _amount) external {
        unbondWithHint(_amount, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebond(uint256 _unbondingLockId) external {
        rebondWithHint(_unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {
        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period
     * @param _unbondingLockId ID of unbonding lock to withdraw with
     */
    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {
        Delegator storage del = delegators[msg.sender];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");
        require(
            lock.withdrawRound <= roundsManager().currentRound(),
            ""withdraw round must be before or equal to the current round""
        );

        uint256 amount = lock.amount;
        uint256 withdrawRound = lock.withdrawRound;
        // Delete unbonding lock
        delete del.unbondingLocks[_unbondingLockId];

        // Tell Minter to transfer stake (LPT) to the delegator
        minter().trustedTransferTokens(msg.sender, amount);

        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);
    }

    /**
     * @notice Withdraws fees to the caller
     */
    function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegators[msg.sender].fees > 0, ""no fees to withdraw"");

        uint256 amount = delegators[msg.sender].fees;
        delegators[msg.sender].fees = 0;

        // Tell Minter to transfer fees (ETH) to the delegator
        minter().trustedWithdrawETH(msg.sender, amount);

        emit WithdrawFees(msg.sender);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators
     */
    function reward() external {
        rewardWithHint(address(0), address(0));
    }

    /**
     * @notice Update transcoder's fee pool. Only callable by the TicketBroker
     * @param _transcoder Transcoder address
     * @param _fees Fees to be added to the fee pool
     */
    function updateTranscoderWithFees(
        address _transcoder,
        uint256 _fees,
        uint256 _round
    ) external whenSystemNotPaused onlyTicketBroker {
        require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");

        Transcoder storage t = transcoders[_transcoder];

        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];

        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare' and 'transcoderRewardCut'
        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected
        if (_round > t.lastRewardRound) {
            earningsPool.setCommission(t.rewardCut, t.feeShare);
        }

        // Add fees to fee pool
        earningsPool.addToFeePool(_fees);
    }

    /**
     * @notice Slash a transcoder. Only callable by the Verifier
     * @param _transcoder Transcoder address
     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder
     * @param _slashAmount Percentage of transcoder bond to be slashed
     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder
     */
    function slashTranscoder(
        address _transcoder,
        address _finder,
        uint256 _slashAmount,
        uint256 _finderFee
    ) external whenSystemNotPaused onlyVerifier {
        Delegator storage del = delegators[_transcoder];

        if (del.bondedAmount > 0) {
            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);

            // If active transcoder, resign it
            if (transcoderPoolV2.contains(_transcoder)) {
                resignTranscoder(_transcoder);
            }

            // Decrease bonded stake
            del.bondedAmount = del.bondedAmount.sub(penalty);

            // If still bonded decrease delegate's delegated amount
            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {
                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(
                    penalty
                );
            }

            // Account for penalty
            uint256 burnAmount = penalty;

            // Award finder fee if there is a finder address
            if (_finder != address(0)) {
                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);
                minter().trustedTransferTokens(_finder, finderAmount);

                // Minter burns the slashed funds - finder reward
                minter().trustedBurnTokens(burnAmount.sub(finderAmount));

                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);
            } else {
                // Minter burns the slashed funds
                minter().trustedBurnTokens(burnAmount);

                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);
            }
        } else {
            emit TranscoderSlashed(_transcoder, _finder, 0, 0);
        }
    }

    /**
     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round
     * @param _endRound The last round for which to claim token pools shares for a delegator
     */
    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        require(lastClaimRound < _endRound, ""end round must be after last claim round"");
        require(_endRound <= roundsManager().currentRound(), ""end round must be before or equal to current round"");

        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);
    }

    /**
     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager
     */
    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {
        currentRoundTotalActiveStake = nextRoundTotalActiveStake;
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the
     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will
     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool
     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool
     */
    function transcoderWithHint(
        uint256 _rewardCut,
        uint256 _feeShare,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized {
        require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");
        require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");
        require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");
        require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");

        Transcoder storage t = transcoders[msg.sender];
        uint256 currentRound = roundsManager().currentRound();

        require(
            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,
            ""caller can't be active or must have already called reward for the current round""
        );

        t.rewardCut = _rewardCut;
        t.feeShare = _feeShare;

        if (!transcoderPoolV2.contains(msg.sender)) {
            tryToJoinActiveSet(
                msg.sender,
                delegators[msg.sender].delegatedAmount,
                currentRound.add(1),
                _newPosPrev,
                _newPosNext
            );
        }

        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);
    }

    /**
     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed
     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint
     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.
     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the
     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.
     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint
     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _amount The amount of tokens to stake.
     * @param _to The address of the transcoder to stake towards
     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate
     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate
     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate
     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate
     */
    function bondWithHint(
        uint256 _amount,
        address _to,
        address _oldDelegateNewPosPrev,
        address _oldDelegateNewPosNext,
        address _currDelegateNewPosPrev,
        address _currDelegateNewPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        Delegator storage del = delegators[msg.sender];

        uint256 currentRound = roundsManager().currentRound();
        // Amount to delegate
        uint256 delegationAmount = _amount;
        // Current delegate
        address currentDelegate = del.delegateAddress;

        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {
            // New delegate
            // Set start round
            // Don't set start round if delegator is in pending state because the start round would not change
            del.startRound = currentRound.add(1);
            // Unbonded state = no existing delegate and no bonded stake
            // Thus, delegation amount = provided amount
        } else if (currentDelegate != address(0) && currentDelegate != _to) {
            // A registered transcoder cannot delegate its bonded stake toward another address
            // because it can only be delegated toward itself
            // In the future, if delegation towards another registered transcoder as an already
            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction
            // could be removed
            require(
                !isRegisteredTranscoder(msg.sender),
                ""registered transcoders can't delegate towards other addresses""
            );
            // Changing delegate
            // Set start round
            del.startRound = currentRound.add(1);
            // Update amount to delegate with previous delegation amount
            delegationAmount = delegationAmount.add(del.bondedAmount);

            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);
        }

        // cannot delegate to someone without having bonded stake
        require(delegationAmount > 0, ""delegation amount must be greater than 0"");
        // Update delegate
        del.delegateAddress = _to;
        // Update bonded amount
        del.bondedAmount = del.bondedAmount.add(_amount);

        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);

        if (_amount > 0) {
            // Transfer the LPT to the Minter
            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);
        }

        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed
     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _amount Amount of tokens to unbond
     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool
     */
    function unbondWithHint(
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");

        Delegator storage del = delegators[msg.sender];

        require(_amount > 0, ""unbond amount must be greater than 0"");
        require(_amount <= del.bondedAmount, ""amount is greater than bonded amount"");

        address currentDelegate = del.delegateAddress;
        uint256 currentRound = roundsManager().currentRound();
        uint256 withdrawRound = currentRound.add(unbondingPeriod);
        uint256 unbondingLockId = del.nextUnbondingLockId;

        // Create new unbonding lock
        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });
        // Increment ID for next unbonding lock
        del.nextUnbondingLockId = unbondingLockId.add(1);
        // Decrease delegator's bonded amount
        del.bondedAmount = del.bondedAmount.sub(_amount);

        if (del.bondedAmount == 0) {
            // Delegator no longer delegated to anyone if it does not have a bonded amount
            del.delegateAddress = address(0);
            // Delegator does not have a start round if it is no longer delegated to anyone
            del.startRound = 0;

            if (transcoderPoolV2.contains(msg.sender)) {
                resignTranscoder(msg.sender);
            }
        }

        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount
        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);

        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates
     * the transcoder pool using an optional list hint if needed
     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool
     */
    function rebondWithHint(
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");

        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using
     * an optional list hint if needed
     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool
     */
    function rebondFromUnbondedWithHint(
        address _to,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");

        // Set delegator's start round and transition into Pending state
        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);
        // Set delegator's delegate
        delegators[msg.sender].delegateAddress = _to;
        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed
     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool
     */
    function rewardWithHint(address _newPosPrev, address _newPosNext)
        public
        whenSystemNotPaused
        currentRoundInitialized
    {
        uint256 currentRound = roundsManager().currentRound();

        require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");
        require(
            transcoders[msg.sender].lastRewardRound != currentRound,
            ""caller has already called reward for the current round""
        );

        Transcoder storage t = transcoders[msg.sender];
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];

        // Set last round that transcoder called reward
        t.lastRewardRound = currentRound;
        earningsPool.setCommission(t.rewardCut, t.feeShare);

        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round
        // the 'totalStake' and 'claimableStake' on its 'EarningsPool' for the current round wouldn't be initialized
        // Thus we sync the the transcoder's stake to when it was last updated
        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently
        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;
        if (lastUpdateRound < currentRound) {
            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);
        }

        // Create reward based on active transcoder's stake relative to the total active stake
        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake
        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);

        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);

        emit Reward(msg.sender, rewardTokens);
    }

    /**
     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending stake from
     * @return Pending bonded stake for '_delegator' since last claiming rewards
     */
    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {
        uint256 currentRound = roundsManager().currentRound();
        uint256 endRound = _endRound;

        if (endRound > currentRound) {
            // Highest round we can calculate up to is the current round
            endRound = currentRound;
        }

        Delegator storage del = delegators[_delegator];
        uint256 currentBondedAmount = del.bondedAmount;

        for (uint256 i = del.lastClaimRound + 1; i <= _endRound; i++) {
            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];

            bool isTranscoder = _delegator == del.delegateAddress;
            if (earningsPool.hasClaimableShares()) {
                // Calculate and add reward pool share from this round
                currentBondedAmount = currentBondedAmount.add(
                    earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)
                );
            }
        }

        return currentBondedAmount;
    }

    /**
     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending fees from
     * @return Pending fees for '_delegator' since last claiming fees
     */
    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {
        uint256 currentRound = roundsManager().currentRound();
        uint256 endRound = _endRound;

        if (endRound > currentRound) {
            // Highest round we can calculate up to is the current round
            endRound = currentRound;
        }

        Delegator storage del = delegators[_delegator];
        uint256 currentFees = del.fees;
        uint256 currentBondedAmount = del.bondedAmount;

        for (uint256 i = del.lastClaimRound + 1; i <= _endRound; i++) {
            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];

            if (earningsPool.hasClaimableShares()) {
                bool isTranscoder = _delegator == del.delegateAddress;
                // Calculate and add fee pool share from this round
                currentFees = currentFees.add(earningsPool.feePoolShare(currentBondedAmount, isTranscoder));
                // Calculate new bonded amount with rewards from this round. Updated bonded amount used
                // to calculate fee pool share in next round
                currentBondedAmount = currentBondedAmount.add(
                    earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)
                );
            }
        }

        return currentFees;
    }

    /**
     * @notice Returns total bonded stake for a transcoder
     * @param _transcoder Address of transcoder
     * @return total bonded stake for a delegator
     */
    function transcoderTotalStake(address _transcoder) public view returns (uint256) {
        return delegators[_transcoder].delegatedAmount;
    }

    /**
     * @notice Computes transcoder status
     * @param _transcoder Address of transcoder
     * @return registered or not registered transcoder status
     */
    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {
        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;
        return TranscoderStatus.NotRegistered;
    }

    /**
     * @notice Computes delegator status
     * @param _delegator Address of delegator
     * @return bonded, unbonded or pending delegator status
     */
    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {
        Delegator storage del = delegators[_delegator];

        if (del.bondedAmount == 0) {
            // Delegator unbonded all its tokens
            return DelegatorStatus.Unbonded;
        } else if (del.startRound > roundsManager().currentRound()) {
            // Delegator round start is in the future
            return DelegatorStatus.Pending;
        } else {
            // Delegator round start is now or in the past
            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which
            // would trigger the first if clause
            return DelegatorStatus.Bonded;
        }
    }

    /**
     * @notice Return transcoder information
     * @param _transcoder Address of transcoder
     * @return trancoder's last reward round
     * @return transcoder's reward cut
     * @return transcoder's fee share
     * @return round in which transcoder's stake was last updated while active
     * @return round in which transcoder became active
     * @return round in which transcoder will no longer be active
     */
    function getTranscoder(address _transcoder)
        public
        view
        returns (
            uint256 lastRewardRound,
            uint256 rewardCut,
            uint256 feeShare,
            uint256 lastActiveStakeUpdateRound,
            uint256 activationRound,
            uint256 deactivationRound
        )
    {
        Transcoder storage t = transcoders[_transcoder];

        lastRewardRound = t.lastRewardRound;
        rewardCut = t.rewardCut;
        feeShare = t.feeShare;
        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;
        activationRound = t.activationRound;
        deactivationRound = t.deactivationRound;
    }

    /**
     * @notice Return transcoder's token pools for a given round
     * @param _transcoder Address of transcoder
     * @param _round Round number
     * @return reward pool for delegates to '_transcoder'
     * @return fee pool for delegates to '_trancoder'
     * @return transcoder's total stake
     * @return claimable stake left on transcoder's earningspool for '_round'
     * @return transcoder's reward cut for '_round'
     * @return transcoder's fee share for '_round'
     * @return transcoder's rewards for '_round'
     * @return transcoder's fees for '_round'
     * @return true if transcoder has a split reward and fee pool
     */
    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)
        public
        view
        returns (
            uint256 rewardPool,
            uint256 feePool,
            uint256 totalStake,
            uint256 claimableStake,
            uint256 transcoderRewardCut,
            uint256 transcoderFeeShare,
            uint256 transcoderRewardPool,
            uint256 transcoderFeePool,
            bool hasTranscoderRewardFeePool
        )
    {
        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];

        rewardPool = earningsPool.rewardPool;
        feePool = earningsPool.feePool;
        totalStake = earningsPool.totalStake;
        claimableStake = earningsPool.claimableStake;
        transcoderRewardCut = earningsPool.transcoderRewardCut;
        transcoderFeeShare = earningsPool.transcoderFeeShare;
        transcoderRewardPool = earningsPool.transcoderRewardPool;
        transcoderFeePool = earningsPool.transcoderFeePool;
        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;
    }

    /**
     * @notice Return delegator info
     * @param _delegator Address of delegator
     * @return total amount bonded by '_delegator'
     * @return amount of fees collected by '_delegator'
     * @return address '_delegator' has bonded to
     * @return total amount delegated to '_delegator'
     * @return round in which bond for '_delegator' became effective
     * @return round for which '_delegator' has last claimed earnings
     * @return ID for the next unbonding lock created for '_delegator'
     */
    function getDelegator(address _delegator)
        public
        view
        returns (
            uint256 bondedAmount,
            uint256 fees,
            address delegateAddress,
            uint256 delegatedAmount,
            uint256 startRound,
            uint256 lastClaimRound,
            uint256 nextUnbondingLockId
        )
    {
        Delegator storage del = delegators[_delegator];

        bondedAmount = del.bondedAmount;
        fees = del.fees;
        delegateAddress = del.delegateAddress;
        delegatedAmount = del.delegatedAmount;
        startRound = del.startRound;
        lastClaimRound = del.lastClaimRound;
        nextUnbondingLockId = del.nextUnbondingLockId;
    }

    /**
     * @notice Return delegator's unbonding lock info
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return amount of stake locked up by unbonding lock
     * @return round in which 'amount' becomes available for withdrawal
     */
    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)
        public
        view
        returns (uint256 amount, uint256 withdrawRound)
    {
        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];

        return (lock.amount, lock.withdrawRound);
    }

    /**
     * @notice Returns max size of transcoder pool
     * @return transcoder pool max size
     */
    function getTranscoderPoolMaxSize() public view returns (uint256) {
        return transcoderPoolV2.getMaxSize();
    }

    /**
     * @notice Returns size of transcoder pool
     * @return transcoder pool current size
     */
    function getTranscoderPoolSize() public view returns (uint256) {
        return transcoderPoolV2.getSize();
    }

    /**
     * @notice Returns transcoder with most stake in pool
     * @return address for transcoder with highest stake in transcoder pool
     */
    function getFirstTranscoderInPool() public view returns (address) {
        return transcoderPoolV2.getFirst();
    }

    /**
     * @notice Returns next transcoder in pool for a given transcoder
     * @param _transcoder Address of a transcoder in the pool
     * @return address for the transcoder after '_transcoder' in transcoder pool
     */
    function getNextTranscoderInPool(address _transcoder) public view returns (address) {
        return transcoderPoolV2.getNext(_transcoder);
    }

    /**
     * @notice Return total bonded tokens
     * @return total active stake for the current round
     */
    function getTotalBonded() public view returns (uint256) {
        return currentRoundTotalActiveStake;
    }

    /**
     * @notice Return whether a transcoder is active for the current round
     * @param _transcoder Transcoder address
     * @return true if transcoder is active
     */
    function isActiveTranscoder(address _transcoder) public view returns (bool) {
        Transcoder storage t = transcoders[_transcoder];
        uint256 currentRound = roundsManager().currentRound();
        return t.activationRound <= currentRound && currentRound < t.deactivationRound;
    }

    /**
     * @notice Return whether a transcoder is registered
     * @param _transcoder Transcoder address
     * @return true if transcoder is self-bonded
     */
    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {
        Delegator storage d = delegators[_transcoder];
        return d.delegateAddress == _transcoder && d.bondedAmount > 0;
    }

    /**
     * @notice Return whether an unbonding lock for a delegator is valid
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return true if unbondingLock for ID has a non-zero withdraw round
     */
    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {
        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)
        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;
    }

    /**
     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The delegate to increase the stake for
     * @param _amount The amount to increase the stake for '_delegate' by
     */
    function increaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (isRegisteredTranscoder(_delegate)) {
            uint256 newStake = transcoderTotalStake(_delegate).add(_amount);
            uint256 nextRound = roundsManager().currentRound().add(1);

            // If the transcoder is already in the active set update its stake and return
            if (transcoderPoolV2.contains(_delegate)) {
                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);
                Transcoder storage t = transcoders[_delegate];
                t.earningsPoolPerRound[nextRound].setStake(newStake);
                t.lastActiveStakeUpdateRound = nextRound;
            } else {
                // Check if the transcoder is eligible to join the active set in the update round
                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);
            }
        }

        // Increase delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);
    }

    /**
     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The transcoder to decrease the stake for
     * @param _amount The amount to decrease the stake for '_delegate' by
     */
    function decreaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (transcoderPoolV2.contains(_delegate)) {
            uint256 newStake = transcoderTotalStake(_delegate).sub(_amount);
            uint256 nextRound = roundsManager().currentRound().add(1);

            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);
            Transcoder storage t = transcoders[_delegate];
            t.lastActiveStakeUpdateRound = nextRound;
            t.earningsPoolPerRound[nextRound].setStake(newStake);
        }

        // Decrease old delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);
    }

    /**
     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full
     * @param _transcoder The transcoder to insert into the transcoder pool
     * @param _totalStake The total stake for '_transcoder'
     * @param _activationRound The round in which the transcoder should become active
     */
    function tryToJoinActiveSet(
        address _transcoder,
        uint256 _totalStake,
        uint256 _activationRound,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;

        if (transcoderPoolV2.isFull()) {
            address lastTranscoder = transcoderPoolV2.getLast();
            uint256 lastStake = transcoderTotalStake(lastTranscoder);

            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool
            // then the transcoder is unable to join the active set for the next round
            if (_totalStake <= lastStake) {
                return;
            }

            // Evict the least stake transcoder from the active set for the next round
            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
            // There should be no side-effects as long as the value is properly updated on stake updates
            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
            transcoderPoolV2.remove(lastTranscoder);
            transcoders[lastTranscoder].deactivationRound = _activationRound;
            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);

            emit TranscoderDeactivated(lastTranscoder, _activationRound);
        }

        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);
        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);
        Transcoder storage t = transcoders[_transcoder];
        t.lastActiveStakeUpdateRound = _activationRound;
        t.activationRound = _activationRound;
        t.deactivationRound = MAX_FUTURE_ROUND;
        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);
        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;
        emit TranscoderActivated(_transcoder, _activationRound);
    }

    /**
     * @dev Remove a transcoder from the pool and deactivate it
     */
    function resignTranscoder(address _transcoder) internal {
        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
        // There should be no side-effects as long as the value is properly updated on stake updates
        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
        transcoderPoolV2.remove(_transcoder);
        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));
        uint256 deactivationRound = roundsManager().currentRound().add(1);
        transcoders[_transcoder].deactivationRound = deactivationRound;
        emit TranscoderDeactivated(_transcoder, deactivationRound);
    }

    /**
     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _transcoder Address of transcoder
     * @param _rewards Amount of rewards
     * @param _round Round that transcoder is updated
     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool
     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool
     */
    function updateTranscoderWithRewards(
        address _transcoder,
        uint256 _rewards,
        uint256 _round,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];
        // Add rewards to reward pool
        earningsPool.addToRewardPool(_rewards);
        // Update transcoder's total stake with rewards
        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);
    }

    /**
     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round
     * @param _delegator Delegator address
     * @param _endRound The last round for which to update a delegator's stake with token pools shares
     * @param _lastClaimRound The round for which a delegator has last claimed earnings
     */
    function updateDelegatorWithEarnings(
        address _delegator,
        uint256 _endRound,
        uint256 _lastClaimRound
    ) internal {
        Delegator storage del = delegators[_delegator];
        uint256 startRound = _lastClaimRound.add(1);
        uint256 currentBondedAmount = del.bondedAmount;
        uint256 currentFees = del.fees;

        // Only will have earnings to claim if you have a delegate
        // If not delegated, skip the earnings claim process
        if (del.delegateAddress != address(0)) {
            // Cannot claim earnings for more than maxEarningsClaimsRounds
            // This is a number to cause transactions to fail early if
            // we know they will require too much gas to loop through all the necessary rounds to claim earnings
            // The user should instead manually invoke `claimEarnings` to split up the claiming process
            // across multiple transactions
            require(_endRound.sub(_lastClaimRound) <= maxEarningsClaimsRounds, ""too many rounds to claim through"");

            for (uint256 i = startRound; i <= _endRound; i++) {
                EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];

                if (earningsPool.hasClaimableShares()) {
                    (uint256 fees, uint256 rewards) = earningsPool.claimShare(
                        currentBondedAmount,
                        _delegator == del.delegateAddress
                    );

                    currentFees = currentFees.add(fees);
                    currentBondedAmount = currentBondedAmount.add(rewards);
                }
            }
        }

        emit EarningsClaimed(
            del.delegateAddress,
            _delegator,
            currentBondedAmount.sub(del.bondedAmount),
            currentFees.sub(del.fees),
            startRound,
            _endRound
        );

        del.lastClaimRound = _endRound;
        // Rewards are bonded by default
        del.bondedAmount = currentBondedAmount;
        del.fees = currentFees;
    }

    /**
     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional
     * list hint if needed. See SortedDoublyLL.sol for details on list hints
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool
     */
    function processRebond(
        address _delegator,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        Delegator storage del = delegators[_delegator];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");

        uint256 amount = lock.amount;
        // Increase delegator's bonded amount
        del.bondedAmount = del.bondedAmount.add(amount);

        // Delete lock
        delete del.unbondingLocks[_unbondingLockId];

        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);

        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);
    }

    /**
     * @dev Return LivepeerToken interface
     * @return Livepeer token contract registered with Controller
     */
    function livepeerToken() internal view returns (ILivepeerToken) {
        return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken"")));
    }

    /**
     * @dev Return Minter interface
     * @return Minter contract registered with Controller
     */
    function minter() internal view returns (IMinter) {
        return IMinter(controller.getContract(keccak256(""Minter"")));
    }

    /**
     * @dev Return RoundsManager interface
     * @return RoundsManager contract registered with Controller
     */
    function roundsManager() internal view returns (IRoundsManager) {
        return IRoundsManager(controller.getContract(keccak256(""RoundsManager"")));
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""pragma solidity ^0.5.11;

import ""../../ManagerProxyTarget.sol"";
import ""../IBondingManager.sol"";
import ""../../libraries/SortedDoublyLL.sol"";
import ""../../libraries/MathUtils.sol"";
import ""./EarningsPoolPreLIP36.sol"";
import ""../../token/ILivepeerToken.sol"";
import ""../../token/IMinter.sol"";
import ""../../rounds/IRoundsManager.sol"";

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

/**
 * @title BondingManager
 * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol
 */
contract BondingManagerPreLIP36 is ManagerProxyTarget, IBondingManager {
    using SafeMath for uint256;
    using SortedDoublyLL for SortedDoublyLL.Data;
    using EarningsPool for EarningsPool.Data;

    // Constants
    // Occurances are replaced at compile time
    // and computed to a single value if possible by the optimizer
    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;

    // Time between unbonding and possible withdrawl in rounds
    uint64 public unbondingPeriod;
    // DEPRECATED - DO NOT USE
    uint256 public numActiveTranscodersDEPRECATED;
    // Max number of rounds that a caller can claim earnings for at once
    uint256 public maxEarningsClaimsRounds;

    // Represents a transcoder's current state
    struct Transcoder {
        uint256 lastRewardRound; // Last round that the transcoder called reward
        uint256 rewardCut; // % of reward paid to transcoder by a delegator
        uint256 feeShare; // % of fees paid to delegators by transcoder
        uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round
        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active
        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive
        uint256 deactivationRound; // Round in which the transcoder will become inactive
    }

    // The various states a transcoder can be in
    enum TranscoderStatus {
        NotRegistered,
        Registered
    }

    // Represents a delegator's current state
    struct Delegator {
        uint256 bondedAmount; // The amount of bonded tokens
        uint256 fees; // The amount of fees collected
        address delegateAddress; // The address delegated to
        uint256 delegatedAmount; // The amount of tokens delegated to the delegator
        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone
        uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings
        uint256 nextUnbondingLockId; // ID for the next unbonding lock created
        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock
    }

    // The various states a delegator can be in
    enum DelegatorStatus {
        Pending,
        Bonded,
        Unbonded
    }

    // Represents an amount of tokens that are being unbonded
    struct UnbondingLock {
        uint256 amount; // Amount of tokens being unbonded
        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn
    }

    // Keep track of the known transcoders and delegators
    mapping(address => Delegator) private delegators;
    mapping(address => Transcoder) private transcoders;

    // DEPRECATED - DO NOT USE
    // The function getTotalBonded() no longer uses this variable
    // and instead calculates the total bonded value separately
    uint256 private totalBondedDEPRECATED;

    // DEPRECATED - DO NOT USE
    SortedDoublyLL.Data private transcoderPoolDEPRECATED;

    // DEPRECATED - DO NOT USE
    struct ActiveTranscoderSetDEPRECATED {
        address[] transcoders;
        mapping(address => bool) isActive;
        uint256 totalStake;
    }

    // DEPRECATED - DO NOT USE
    mapping(uint256 => ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;

    // The total active stake (sum of the stake of active set members) for the current round
    uint256 public currentRoundTotalActiveStake;
    // The total active stake (sum of the stake of active set members) for the next round
    uint256 public nextRoundTotalActiveStake;

    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.
    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders
    // in the pool are locked into the active set for round N + 1
    SortedDoublyLL.Data private transcoderPoolV2;

    // Check if sender is TicketBroker
    modifier onlyTicketBroker() {
        require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");
        _;
    }

    // Check if sender is RoundsManager
    modifier onlyRoundsManager() {
        require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");
        _;
    }

    // Check if sender is Verifier
    modifier onlyVerifier() {
        require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");
        _;
    }

    // Check if current round is initialized
    modifier currentRoundInitialized() {
        require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");
        _;
    }

    // Automatically claim earnings from lastClaimRound through the current round
    modifier autoClaimEarnings() {
        uint256 currentRound = roundsManager().currentRound();
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        if (lastClaimRound < currentRound) {
            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);
        }
        _;
    }

    /**
     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address
     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions
     * should be used to initialize state variables post-deployment:
     * - setUnbondingPeriod()
     * - setNumActiveTranscoders()
     * - setMaxEarningsClaimsRounds()
     * @param _controller Address of Controller that this contract will be registered with
     */
    constructor(address _controller) public Manager(_controller) {}

    /**
     * @notice Set unbonding period. Only callable by Controller owner
     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal
     */
    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {
        unbondingPeriod = _unbondingPeriod;

        emit ParameterUpdate(""unbondingPeriod"");
    }

    /**
     * @notice Set maximum number of active transcoders. Only callable by Controller owner
     * @param _numActiveTranscoders Number of active transcoders
     */
    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {
        transcoderPoolV2.setMaxSize(_numActiveTranscoders);

        emit ParameterUpdate(""numActiveTranscoders"");
    }

    /**
     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner
     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once
     */
    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {
        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;

        emit ParameterUpdate(""maxEarningsClaimsRounds"");
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     */
    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {
        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));
    }

    /**
     * @notice Delegate stake towards a specific address
     * @param _amount The amount of tokens to stake
     * @param _to The address of the transcoder to stake towards
     */
    function bond(uint256 _amount, address _to) external {
        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake
     * @param _amount Amount of tokens to unbond
     */
    function unbond(uint256 _amount) external {
        unbondWithHint(_amount, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebond(uint256 _unbondingLockId) external {
        rebondWithHint(_unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {
        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period
     * @param _unbondingLockId ID of unbonding lock to withdraw with
     */
    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {
        Delegator storage del = delegators[msg.sender];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");
        require(
            lock.withdrawRound <= roundsManager().currentRound(),
            ""withdraw round must be before or equal to the current round""
        );

        uint256 amount = lock.amount;
        uint256 withdrawRound = lock.withdrawRound;
        // Delete unbonding lock
        delete del.unbondingLocks[_unbondingLockId];

        // Tell Minter to transfer stake (LPT) to the delegator
        minter().trustedTransferTokens(msg.sender, amount);

        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);
    }

    /**
     * @notice Withdraws fees to the caller
     */
    function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegators[msg.sender].fees > 0, ""no fees to withdraw"");

        uint256 amount = delegators[msg.sender].fees;
        delegators[msg.sender].fees = 0;

        // Tell Minter to transfer fees (ETH) to the delegator
        minter().trustedWithdrawETH(msg.sender, amount);

        emit WithdrawFees(msg.sender);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators
     */
    function reward() external {
        rewardWithHint(address(0), address(0));
    }

    /**
     * @notice Update transcoder's fee pool. Only callable by the TicketBroker
     * @param _transcoder Transcoder address
     * @param _fees Fees to be added to the fee pool
     */
    function updateTranscoderWithFees(
        address _transcoder,
        uint256 _fees,
        uint256 _round
    ) external whenSystemNotPaused onlyTicketBroker {
        require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");

        Transcoder storage t = transcoders[_transcoder];

        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];

        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare' and 'transcoderRewardCut'
        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected
        if (_round > t.lastRewardRound) {
            earningsPool.setCommission(t.rewardCut, t.feeShare);
        }

        // Add fees to fee pool
        earningsPool.addToFeePool(_fees);
    }

    /**
     * @notice Slash a transcoder. Only callable by the Verifier
     * @param _transcoder Transcoder address
     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder
     * @param _slashAmount Percentage of transcoder bond to be slashed
     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder
     */
    function slashTranscoder(
        address _transcoder,
        address _finder,
        uint256 _slashAmount,
        uint256 _finderFee
    ) external whenSystemNotPaused onlyVerifier {
        Delegator storage del = delegators[_transcoder];

        if (del.bondedAmount > 0) {
            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);

            // If active transcoder, resign it
            if (transcoderPoolV2.contains(_transcoder)) {
                resignTranscoder(_transcoder);
            }

            // Decrease bonded stake
            del.bondedAmount = del.bondedAmount.sub(penalty);

            // If still bonded decrease delegate's delegated amount
            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {
                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(
                    penalty
                );
            }

            // Account for penalty
            uint256 burnAmount = penalty;

            // Award finder fee if there is a finder address
            if (_finder != address(0)) {
                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);
                minter().trustedTransferTokens(_finder, finderAmount);

                // Minter burns the slashed funds - finder reward
                minter().trustedBurnTokens(burnAmount.sub(finderAmount));

                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);
            } else {
                // Minter burns the slashed funds
                minter().trustedBurnTokens(burnAmount);

                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);
            }
        } else {
            emit TranscoderSlashed(_transcoder, _finder, 0, 0);
        }
    }

    /**
     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round
     * @param _endRound The last round for which to claim token pools shares for a delegator
     */
    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        require(lastClaimRound < _endRound, ""end round must be after last claim round"");
        require(_endRound <= roundsManager().currentRound(), ""end round must be before or equal to current round"");

        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);
    }

    /**
     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager
     */
    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {
        currentRoundTotalActiveStake = nextRoundTotalActiveStake;
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the
     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will
     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool
     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool
     */
    function transcoderWithHint(
        uint256 _rewardCut,
        uint256 _feeShare,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized {
        require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");
        require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");
        require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");
        require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");

        Transcoder storage t = transcoders[msg.sender];
        uint256 currentRound = roundsManager().currentRound();

        require(
            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,
            ""caller can't be active or must have already called reward for the current round""
        );

        t.rewardCut = _rewardCut;
        t.feeShare = _feeShare;

        if (!transcoderPoolV2.contains(msg.sender)) {
            tryToJoinActiveSet(
                msg.sender,
                delegators[msg.sender].delegatedAmount,
                currentRound.add(1),
                _newPosPrev,
                _newPosNext
            );
        }

        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);
    }

    /**
     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed
     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint
     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.
     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the
     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.
     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint
     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _amount The amount of tokens to stake.
     * @param _to The address of the transcoder to stake towards
     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate
     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate
     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate
     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate
     */
    function bondWithHint(
        uint256 _amount,
        address _to,
        address _oldDelegateNewPosPrev,
        address _oldDelegateNewPosNext,
        address _currDelegateNewPosPrev,
        address _currDelegateNewPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        Delegator storage del = delegators[msg.sender];

        uint256 currentRound = roundsManager().currentRound();
        // Amount to delegate
        uint256 delegationAmount = _amount;
        // Current delegate
        address currentDelegate = del.delegateAddress;

        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {
            // New delegate
            // Set start round
            // Don't set start round if delegator is in pending state because the start round would not change
            del.startRound = currentRound.add(1);
            // Unbonded state = no existing delegate and no bonded stake
            // Thus, delegation amount = provided amount
        } else if (currentDelegate != address(0) && currentDelegate != _to) {
            // A registered transcoder cannot delegate its bonded stake toward another address
            // because it can only be delegated toward itself
            // In the future, if delegation towards another registered transcoder as an already
            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction
            // could be removed
            require(
                !isRegisteredTranscoder(msg.sender),
                ""registered transcoders can't delegate towards other addresses""
            );
            // Changing delegate
            // Set start round
            del.startRound = currentRound.add(1);
            // Update amount to delegate with previous delegation amount
            delegationAmount = delegationAmount.add(del.bondedAmount);

            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);
        }

        // cannot delegate to someone without having bonded stake
        require(delegationAmount > 0, ""delegation amount must be greater than 0"");
        // Update delegate
        del.delegateAddress = _to;
        // Update bonded amount
        del.bondedAmount = del.bondedAmount.add(_amount);

        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);

        if (_amount > 0) {
            // Transfer the LPT to the Minter
            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);
        }

        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed
     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _amount Amount of tokens to unbond
     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool
     */
    function unbondWithHint(
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");

        Delegator storage del = delegators[msg.sender];

        require(_amount > 0, ""unbond amount must be greater than 0"");
        require(_amount <= del.bondedAmount, ""amount is greater than bonded amount"");

        address currentDelegate = del.delegateAddress;
        uint256 currentRound = roundsManager().currentRound();
        uint256 withdrawRound = currentRound.add(unbondingPeriod);
        uint256 unbondingLockId = del.nextUnbondingLockId;

        // Create new unbonding lock
        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });
        // Increment ID for next unbonding lock
        del.nextUnbondingLockId = unbondingLockId.add(1);
        // Decrease delegator's bonded amount
        del.bondedAmount = del.bondedAmount.sub(_amount);

        if (del.bondedAmount == 0) {
            // Delegator no longer delegated to anyone if it does not have a bonded amount
            del.delegateAddress = address(0);
            // Delegator does not have a start round if it is no longer delegated to anyone
            del.startRound = 0;

            if (transcoderPoolV2.contains(msg.sender)) {
                resignTranscoder(msg.sender);
            }
        }

        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount
        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);

        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates
     * the transcoder pool using an optional list hint if needed
     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool
     */
    function rebondWithHint(
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");

        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using
     * an optional list hint if needed
     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool
     */
    function rebondFromUnbondedWithHint(
        address _to,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");

        // Set delegator's start round and transition into Pending state
        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);
        // Set delegator's delegate
        delegators[msg.sender].delegateAddress = _to;
        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed
     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool
     */
    function rewardWithHint(address _newPosPrev, address _newPosNext)
        public
        whenSystemNotPaused
        currentRoundInitialized
    {
        uint256 currentRound = roundsManager().currentRound();

        require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");
        require(
            transcoders[msg.sender].lastRewardRound != currentRound,
            ""caller has already called reward for the current round""
        );

        Transcoder storage t = transcoders[msg.sender];
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];

        // Set last round that transcoder called reward
        t.lastRewardRound = currentRound;
        earningsPool.setCommission(t.rewardCut, t.feeShare);

        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round
        // the 'totalStake' and 'claimableStake' on its 'EarningsPool' for the current round wouldn't be initialized
        // Thus we sync the the transcoder's stake to when it was last updated
        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently
        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;
        if (lastUpdateRound < currentRound) {
            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);
        }

        // Create reward based on active transcoder's stake relative to the total active stake
        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake
        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);

        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);

        emit Reward(msg.sender, rewardTokens);
    }

    /**
     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending stake from
     * @return Pending bonded stake for '_delegator' since last claiming rewards
     */
    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {
        uint256 currentRound = roundsManager().currentRound();
        uint256 endRound = _endRound;

        if (endRound > currentRound) {
            // Highest round we can calculate up to is the current round
            endRound = currentRound;
        }

        Delegator storage del = delegators[_delegator];
        uint256 currentBondedAmount = del.bondedAmount;

        for (uint256 i = del.lastClaimRound + 1; i <= _endRound; i++) {
            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];

            bool isTranscoder = _delegator == del.delegateAddress;
            if (earningsPool.hasClaimableShares()) {
                // Calculate and add reward pool share from this round
                currentBondedAmount = currentBondedAmount.add(
                    earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)
                );
            }
        }

        return currentBondedAmount;
    }

    /**
     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending fees from
     * @return Pending fees for '_delegator' since last claiming fees
     */
    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {
        uint256 currentRound = roundsManager().currentRound();
        uint256 endRound = _endRound;

        if (endRound > currentRound) {
            // Highest round we can calculate up to is the current round
            endRound = currentRound;
        }

        Delegator storage del = delegators[_delegator];
        uint256 currentFees = del.fees;
        uint256 currentBondedAmount = del.bondedAmount;

        for (uint256 i = del.lastClaimRound + 1; i <= _endRound; i++) {
            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];

            if (earningsPool.hasClaimableShares()) {
                bool isTranscoder = _delegator == del.delegateAddress;
                // Calculate and add fee pool share from this round
                currentFees = currentFees.add(earningsPool.feePoolShare(currentBondedAmount, isTranscoder));
                // Calculate new bonded amount with rewards from this round. Updated bonded amount used
                // to calculate fee pool share in next round
                currentBondedAmount = currentBondedAmount.add(
                    earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder)
                );
            }
        }

        return currentFees;
    }

    /**
     * @notice Returns total bonded stake for a transcoder
     * @param _transcoder Address of transcoder
     * @return total bonded stake for a delegator
     */
    function transcoderTotalStake(address _transcoder) public view returns (uint256) {
        return delegators[_transcoder].delegatedAmount;
    }

    /**
     * @notice Computes transcoder status
     * @param _transcoder Address of transcoder
     * @return registered or not registered transcoder status
     */
    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {
        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;
        return TranscoderStatus.NotRegistered;
    }

    /**
     * @notice Computes delegator status
     * @param _delegator Address of delegator
     * @return bonded, unbonded or pending delegator status
     */
    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {
        Delegator storage del = delegators[_delegator];

        if (del.bondedAmount == 0) {
            // Delegator unbonded all its tokens
            return DelegatorStatus.Unbonded;
        } else if (del.startRound > roundsManager().currentRound()) {
            // Delegator round start is in the future
            return DelegatorStatus.Pending;
        } else {
            // Delegator round start is now or in the past
            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which
            // would trigger the first if clause
            return DelegatorStatus.Bonded;
        }
    }

    /**
     * @notice Return transcoder information
     * @param _transcoder Address of transcoder
     * @return trancoder's last reward round
     * @return transcoder's reward cut
     * @return transcoder's fee share
     * @return round in which transcoder's stake was last updated while active
     * @return round in which transcoder became active
     * @return round in which transcoder will no longer be active
     */
    function getTranscoder(address _transcoder)
        public
        view
        returns (
            uint256 lastRewardRound,
            uint256 rewardCut,
            uint256 feeShare,
            uint256 lastActiveStakeUpdateRound,
            uint256 activationRound,
            uint256 deactivationRound
        )
    {
        Transcoder storage t = transcoders[_transcoder];

        lastRewardRound = t.lastRewardRound;
        rewardCut = t.rewardCut;
        feeShare = t.feeShare;
        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;
        activationRound = t.activationRound;
        deactivationRound = t.deactivationRound;
    }

    /**
     * @notice Return transcoder's token pools for a given round
     * @param _transcoder Address of transcoder
     * @param _round Round number
     * @return reward pool for delegates to '_transcoder'
     * @return fee pool for delegates to '_trancoder'
     * @return transcoder's total stake
     * @return claimable stake left on transcoder's earningspool for '_round'
     * @return transcoder's reward cut for '_round'
     * @return transcoder's fee share for '_round'
     * @return transcoder's rewards for '_round'
     * @return transcoder's fees for '_round'
     * @return true if transcoder has a split reward and fee pool
     */
    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)
        public
        view
        returns (
            uint256 rewardPool,
            uint256 feePool,
            uint256 totalStake,
            uint256 claimableStake,
            uint256 transcoderRewardCut,
            uint256 transcoderFeeShare,
            uint256 transcoderRewardPool,
            uint256 transcoderFeePool,
            bool hasTranscoderRewardFeePool
        )
    {
        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];

        rewardPool = earningsPool.rewardPool;
        feePool = earningsPool.feePool;
        totalStake = earningsPool.totalStake;
        claimableStake = earningsPool.claimableStake;
        transcoderRewardCut = earningsPool.transcoderRewardCut;
        transcoderFeeShare = earningsPool.transcoderFeeShare;
        transcoderRewardPool = earningsPool.transcoderRewardPool;
        transcoderFeePool = earningsPool.transcoderFeePool;
        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;
    }

    /**
     * @notice Return delegator info
     * @param _delegator Address of delegator
     * @return total amount bonded by '_delegator'
     * @return amount of fees collected by '_delegator'
     * @return address '_delegator' has bonded to
     * @return total amount delegated to '_delegator'
     * @return round in which bond for '_delegator' became effective
     * @return round for which '_delegator' has last claimed earnings
     * @return ID for the next unbonding lock created for '_delegator'
     */
    function getDelegator(address _delegator)
        public
        view
        returns (
            uint256 bondedAmount,
            uint256 fees,
            address delegateAddress,
            uint256 delegatedAmount,
            uint256 startRound,
            uint256 lastClaimRound,
            uint256 nextUnbondingLockId
        )
    {
        Delegator storage del = delegators[_delegator];

        bondedAmount = del.bondedAmount;
        fees = del.fees;
        delegateAddress = del.delegateAddress;
        delegatedAmount = del.delegatedAmount;
        startRound = del.startRound;
        lastClaimRound = del.lastClaimRound;
        nextUnbondingLockId = del.nextUnbondingLockId;
    }

    /**
     * @notice Return delegator's unbonding lock info
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return amount of stake locked up by unbonding lock
     * @return round in which 'amount' becomes available for withdrawal
     */
    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)
        public
        view
        returns (uint256 amount, uint256 withdrawRound)
    {
        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];

        return (lock.amount, lock.withdrawRound);
    }

    /**
     * @notice Returns max size of transcoder pool
     * @return transcoder pool max size
     */
    function getTranscoderPoolMaxSize() public view returns (uint256) {
        return transcoderPoolV2.getMaxSize();
    }

    /**
     * @notice Returns size of transcoder pool
     * @return transcoder pool current size
     */
    function getTranscoderPoolSize() public view returns (uint256) {
        return transcoderPoolV2.getSize();
    }

    /**
     * @notice Returns transcoder with most stake in pool
     * @return address for transcoder with highest stake in transcoder pool
     */
    function getFirstTranscoderInPool() public view returns (address) {
        return transcoderPoolV2.getFirst();
    }

    /**
     * @notice Returns next transcoder in pool for a given transcoder
     * @param _transcoder Address of a transcoder in the pool
     * @return address for the transcoder after '_transcoder' in transcoder pool
     */
    function getNextTranscoderInPool(address _transcoder) public view returns (address) {
        return transcoderPoolV2.getNext(_transcoder);
    }

    /**
     * @notice Return total bonded tokens
     * @return total active stake for the current round
     */
    function getTotalBonded() public view returns (uint256) {
        return currentRoundTotalActiveStake;
    }

    /**
     * @notice Return whether a transcoder is active for the current round
     * @param _transcoder Transcoder address
     * @return true if transcoder is active
     */
    function isActiveTranscoder(address _transcoder) public view returns (bool) {
        Transcoder storage t = transcoders[_transcoder];
        uint256 currentRound = roundsManager().currentRound();
        return t.activationRound <= currentRound && currentRound < t.deactivationRound;
    }

    /**
     * @notice Return whether a transcoder is registered
     * @param _transcoder Transcoder address
     * @return true if transcoder is self-bonded
     */
    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {
        Delegator storage d = delegators[_transcoder];
        return d.delegateAddress == _transcoder && d.bondedAmount > 0;
    }

    /**
     * @notice Return whether an unbonding lock for a delegator is valid
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return true if unbondingLock for ID has a non-zero withdraw round
     */
    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {
        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)
        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;
    }

    /**
     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The delegate to increase the stake for
     * @param _amount The amount to increase the stake for '_delegate' by
     */
    function increaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (isRegisteredTranscoder(_delegate)) {
            uint256 newStake = transcoderTotalStake(_delegate).add(_amount);
            uint256 nextRound = roundsManager().currentRound().add(1);

            // If the transcoder is already in the active set update its stake and return
            if (transcoderPoolV2.contains(_delegate)) {
                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);
                Transcoder storage t = transcoders[_delegate];
                t.earningsPoolPerRound[nextRound].setStake(newStake);
                t.lastActiveStakeUpdateRound = nextRound;
            } else {
                // Check if the transcoder is eligible to join the active set in the update round
                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);
            }
        }

        // Increase delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);
    }

    /**
     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The transcoder to decrease the stake for
     * @param _amount The amount to decrease the stake for '_delegate' by
     */
    function decreaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (transcoderPoolV2.contains(_delegate)) {
            uint256 newStake = transcoderTotalStake(_delegate).sub(_amount);
            uint256 nextRound = roundsManager().currentRound().add(1);

            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);
            Transcoder storage t = transcoders[_delegate];
            t.lastActiveStakeUpdateRound = nextRound;
            t.earningsPoolPerRound[nextRound].setStake(newStake);
        }

        // Decrease old delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);
    }

    /**
     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full
     * @param _transcoder The transcoder to insert into the transcoder pool
     * @param _totalStake The total stake for '_transcoder'
     * @param _activationRound The round in which the transcoder should become active
     */
    function tryToJoinActiveSet(
        address _transcoder,
        uint256 _totalStake,
        uint256 _activationRound,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;

        if (transcoderPoolV2.isFull()) {
            address lastTranscoder = transcoderPoolV2.getLast();
            uint256 lastStake = transcoderTotalStake(lastTranscoder);

            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool
            // then the transcoder is unable to join the active set for the next round
            if (_totalStake <= lastStake) {
                return;
            }

            // Evict the least stake transcoder from the active set for the next round
            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
            // There should be no side-effects as long as the value is properly updated on stake updates
            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
            transcoderPoolV2.remove(lastTranscoder);
            transcoders[lastTranscoder].deactivationRound = _activationRound;
            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);

            emit TranscoderDeactivated(lastTranscoder, _activationRound);
        }

        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);
        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);
        Transcoder storage t = transcoders[_transcoder];
        t.lastActiveStakeUpdateRound = _activationRound;
        t.activationRound = _activationRound;
        t.deactivationRound = MAX_FUTURE_ROUND;
        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);
        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;
        emit TranscoderActivated(_transcoder, _activationRound);
    }

    /**
     * @dev Remove a transcoder from the pool and deactivate it
     */
    function resignTranscoder(address _transcoder) internal {
        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
        // There should be no side-effects as long as the value is properly updated on stake updates
        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
        transcoderPoolV2.remove(_transcoder);
        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));
        uint256 deactivationRound = roundsManager().currentRound().add(1);
        transcoders[_transcoder].deactivationRound = deactivationRound;
        emit TranscoderDeactivated(_transcoder, deactivationRound);
    }

    /**
     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _transcoder Address of transcoder
     * @param _rewards Amount of rewards
     * @param _round Round that transcoder is updated
     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool
     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool
     */
    function updateTranscoderWithRewards(
        address _transcoder,
        uint256 _rewards,
        uint256 _round,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];
        // Add rewards to reward pool
        earningsPool.addToRewardPool(_rewards);
        // Update transcoder's total stake with rewards
        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);
    }

    /**
     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round
     * @param _delegator Delegator address
     * @param _endRound The last round for which to update a delegator's stake with token pools shares
     * @param _lastClaimRound The round for which a delegator has last claimed earnings
     */
    function updateDelegatorWithEarnings(
        address _delegator,
        uint256 _endRound,
        uint256 _lastClaimRound
    ) internal {
        Delegator storage del = delegators[_delegator];
        uint256 startRound = _lastClaimRound.add(1);
        uint256 currentBondedAmount = del.bondedAmount;
        uint256 currentFees = del.fees;

        // Only will have earnings to claim if you have a delegate
        // If not delegated, skip the earnings claim process
        if (del.delegateAddress != address(0)) {
            // Cannot claim earnings for more than maxEarningsClaimsRounds
            // This is a number to cause transactions to fail early if
            // we know they will require too much gas to loop through all the necessary rounds to claim earnings
            // The user should instead manually invoke `claimEarnings` to split up the claiming process
            // across multiple transactions
            require(_endRound.sub(_lastClaimRound) <= maxEarningsClaimsRounds, ""too many rounds to claim through"");

            for (uint256 i = startRound; i <= _endRound; i++) {
                EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];

                if (earningsPool.hasClaimableShares()) {
                    (uint256 fees, uint256 rewards) = earningsPool.claimShare(
                        currentBondedAmount,
                        _delegator == del.delegateAddress
                    );

                    currentFees = currentFees.add(fees);
                    currentBondedAmount = currentBondedAmount.add(rewards);
                }
            }
        }

        emit EarningsClaimed(
            del.delegateAddress,
            _delegator,
            currentBondedAmount.sub(del.bondedAmount),
            currentFees.sub(del.fees),
            startRound,
            _endRound
        );

        del.lastClaimRound = _endRound;
        // Rewards are bonded by default
        del.bondedAmount = currentBondedAmount;
        del.fees = currentFees;
    }

    /**
     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional
     * list hint if needed. See SortedDoublyLL.sol for details on list hints
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool
     */
    function processRebond(
        address _delegator,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        Delegator storage del = delegators[_delegator];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");

        uint256 amount = lock.amount;
        // Increase delegator's bonded amount
        del.bondedAmount = del.bondedAmount.add(amount);

        // Delete lock
        delete del.unbondingLocks[_unbondingLockId];

        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);

        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);
    }

    /**
     * @dev Return LivepeerToken interface
     * @return Livepeer token contract registered with Controller
     */
    function livepeerToken() internal view returns (ILivepeerToken) {
        return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken"")));
    }

    /**
     * @dev Return Minter interface
     * @return Minter contract registered with Controller
     */
    function minter() internal view returns (IMinter) {
        return IMinter(controller.getContract(keccak256(""Minter"")));
    }

    /**
     * @dev Return RoundsManager interface
     * @return RoundsManager contract registered with Controller
     */
    function roundsManager() internal view returns (IRoundsManager) {
        return IRoundsManager(controller.getContract(keccak256(""RoundsManager"")));
    }
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses low-level calls to transfer tokens and withdraw fees without checking the success of these calls. Specifically, the following instances are identified:

1. In the `withdrawStake` function:
   ```solidity
   minter().trustedTransferTokens(msg.sender, amount);
   ```
   If the `trustedTransferTokens` function fails, the transaction will not revert, and the user may lose their funds without any indication of failure.

2. In the `withdrawFees` function:
   ```solidity
   minter().trustedWithdrawETH(msg.sender, amount);
   ```
   Similar to the previous case, if the `trustedWithdrawETH` function fails, the transaction will not revert, leading to potential loss of funds.

Recommended Mitigation:
To mitigate this vulnerability, it is essential to check the return value of low-level calls and revert the transaction if the call fails. This can be done by using the following pattern:

```solidity
(bool success, ) = address(minter()).call(abi.encodeWithSignature(""trustedTransferTokens(address,uint256)"", msg.sender, amount));
require(success, ""Transfer failed"");
```

This ensures that if the call fails, the transaction will revert, preventing any loss of funds and maintaining the integrity of the contract's operations.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
