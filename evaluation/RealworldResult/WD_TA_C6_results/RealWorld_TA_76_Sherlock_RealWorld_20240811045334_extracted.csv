Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,,,,,,,,,,"<INFO> Lack of Withdrawal Function Identified.
```

[2024-11-08 04:54:32 INFO] **[Seminar Conclusion]**:

 Upon reviewing the provided contract code for the Sherlock protocol, I have conducted a thorough analysis focusing on the presence of a withdrawal function and its security implications. Here are the findings:

1. **Withdrawal Function Inspection**: 
   The contract does not contain any function that explicitly allows users to withdraw their deposited funds (USDC or SHER tokens). The only functions related to transferring tokens are those that facilitate staking, redeeming NFTs, and payouts for claims, but none provide a direct withdrawal mechanism for users to retrieve their funds.

2. **Functions Related to Withdrawal**: 
   - The contract has functions like `redeemNFT`, `payoutClaim`, and `_transferTokensOut`, which involve transferring tokens but are not designed for user-initiated withdrawals of their deposited funds.
   - The `redeemNFT` function allows users to redeem their NFT for USDC after the lockup period, but this is contingent on the NFT being owned and the lockup period having expired, which does not equate to a general withdrawal function.

3. **Best Practices Evaluation**: 
   Since there is no withdrawal function present, there is no opportunity to evaluate its adherence to best practices such as the Checks-Effects-Interactions pattern or protection against reentrancy attacks.

4. **Impact Assessment**: 
   The absence of a withdrawal function poses a significant risk to users who have deposited funds into the contract. Users are unable to retrieve their funds unless they meet specific conditions (e.g., owning an NFT and waiting for the lockup period to expire). This could lead to user frustration and a lack of trust in the protocol, as users may feel their funds are locked indefinitely without a clear mechanism to access them.

Given these findings, I conclude with the following:

```
","<INFO> Lack of Authorization Identified.

```
LACK OF WITHDRAWAL FUNCTION
'''
The contract does not provide a withdrawal function for users to retrieve their staked tokens (USDC) after the lockup period ends. This absence could lead to a situation where users are unable to access their funds, especially if the contract owner or other authorized parties become unreachable or if the contract encounters issues. 

To mitigate this risk, it is recommended to implement a withdrawal function that allows users to withdraw their staked tokens after the lockup period has expired. This function should ensure that only the rightful owners of the NFTs can withdraw their corresponding USDC, thus maintaining security and access control.
'''
```

```
LACK OF AUTHORIZATION ON PayoutClaim FUNCTION
'''
The `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no explicit check to ensure that the caller is indeed the authorized claim manager. If an attacker were to gain control of an address that is not the claim manager, they could potentially call this function and initiate unauthorized payouts.

To mitigate this risk, it is crucial to implement a more robust access control mechanism. This can be done by adding an explicit check to verify that the `msg.sender` is the correct `sherlockClaimManager` before proceeding with the payout logic.
'''
```

```
LACK OF AUTHORIZATION ON yieldStrategyWithdraw FUNCTION
'''
The `yieldStrategyWithdraw` function allows the owner to withdraw tokens from the yield strategy. However, if the ownership of the contract is compromised, an unauthorized user could potentially withdraw funds from the yield strategy, leading to loss of funds.

To mitigate this risk, it is recommended to implement a multi-signature wallet for ownership or a time-lock mechanism for sensitive functions like withdrawals. This would require multiple parties to approve such actions, thereby reducing the risk of unauthorized withdrawals.
'''
```

```
LACK OF AUTHORIZATION ON updateSherDistributionManager FUNCTION
'''
The `updateSherDistributionManager` function allows the contract owner to change the distribution manager. If the owner’s private key is compromised, an attacker could change the distribution manager to a malicious contract, leading to potential loss of funds or manipulation of rewards.

To mitigate this risk, it is advisable to implement a multi-signature requirement for changing critical parameters such as the distribution manager. This would ensure that multiple trusted parties must agree before such changes can be made.
'''
```

[2024-11-08 04:54:40 INFO] **[Seminar Conclusion]**:

 ","<INFO> Potential Data Inconsistency Identified.

```
POTENTIAL DATA INCONSISTENCY IN _redeemSharesCalc FUNCTION
'''
The function `_redeemSharesCalc` calculates the amount of USDC owed to a given amount of stake shares by performing a division operation involving `totalTokenBalanceStakers()` and `totalStakeShares`. If `totalStakeShares` is zero, this could lead to a division by zero error, which would cause the function to revert. Additionally, if `totalTokenBalanceStakers()` changes between the time it is called and when the result is used, it could lead to inconsistencies in the amount

[2024-11-08 04:54:46 INFO] **[Seminar Conclusion]**:

 ",,,,,,"<INFO> Precision Loss Identified.

VULNERABILITY NAME: Precision Loss in Arithmetic Operations
'''
The contract performs several arithmetic operations involving division, particularly in the functions `_redeemSharesCalc` and `tokenBalanceOf`. These operations use integer division, which can lead to precision loss when dealing with fractional values. For example, in the calculation of shares owed to a position or an address, if the total amount of tokens owed to all stakers is not evenly divisible by the stake shares, the result will be truncated, leading to potential underpayment or overpayment of rewards.

To mitigate this issue, it is recommended to use a scaling factor (e.g., multiplying by a large number like 10**18) before performing the division and then dividing the final result by the same scaling factor. This approach helps maintain precision in calculations involving fractional values.
'''

[2024-11-08 04:55:03 INFO] **[Seminar Conclusion]**:

 ","<INFO> Redundant Conditional Check Identified.
'''
In the `updateSherDistributionManager` function, there is a check to see if the new distribution manager address is not zero. This check is redundant because it is already performed in the constructor when setting the initial distribution manager. Additionally, the check for whether the new address is the same as the current one is also unnecessary as it does not change the state of the contract if they are the same.

To mitigate this issue, the redundant checks can be removed from the `updateSherDistributionManager` function, simplifying the code and reducing gas costs.
'''

[2024-11-08 04:55:07 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Centralization Risk Identified.

**Centralization of Control**
'''
The contract has several functions that can only be executed by the `owner`, which centralizes control in a single address. This includes critical functions such as `enableStakingPeriod`, `disableStakingPeriod`, `updateSherDistributionManager`, `removeSherDistributionManager`, `updateNonStakersAddress`, `updateSherlockProtocolManager`, `updateSherlockClaimManager`, and `updateYieldStrategy`. If the owner's private key is compromised, an attacker could execute any of these functions, potentially leading to loss of funds or manipulation of the contract's behavior.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for the ownership functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive functions, reducing the risk associated with a single point of failure. Additionally, consider implementing a governance mechanism where stakeholders can vote on critical changes, further decentralizing control.
'''

**Lack of Emergency Mechanisms**
'''
The contract has the ability to pause operations via the `pause` and `unpause` functions, but these can only be executed by the `owner`. If the owner account is compromised, an attacker could pause the contract, preventing all operations and effectively locking users out of their funds.

**Recommended Mitigation/Fix:**
Introduce a multi-signature mechanism for the pause and unpause functions as well. This ensures that no single entity can unilaterally halt the contract's operations, providing a safeguard against potential abuse.
'''

**Single Point of Failure in Yield Strategy**
'''
The contract relies on a single yield strategy contract, which can be updated only by the `owner`. If the yield strategy contract has vulnerabilities or is compromised, it could lead to loss of funds for all users.

**Recommended Mitigation/Fix:**
Consider implementing a governance model where stakeholders can vote on changes to the yield strategy. This would allow for community oversight and reduce the risk associated with a single point of failure.
'''

[2024-11-08 04:55:21 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,"<INFO> Lack of Input Validation Identified.

```
VULNERABILITY NAME: Zero Address Validation
'''
In several functions, the contract does not adequately check for zero addresses. For example, in the constructor, the contract checks if the token addresses are zero, but similar checks are not consistently applied in functions like `updateNonStakersAddress`, `updateSherDistributionManager`, `updateSherlockProtocolManager`, and `updateSherlockClaimManager`. This could lead to unintended behavior if a zero address is passed, potentially allowing funds to be sent to an invalid address.

RECOMMENDED MITIGATION:
Ensure that all functions that accept an address as an input validate that the address is not zero. This can be done by adding a check at the beginning of each function:
```
require(_address != address(0), ""Zero address not allowed"");
```
'''

VULNERABILITY NAME: Lack of Input Validation for Staking Periods
'''
In the `enableStakingPeriod` and `disableStakingPeriod` functions, there is a lack of validation for the staking period input. While there is a check for zero values, there is no check to ensure that the period is a reasonable value (e.g., it should not be excessively large). This could lead to unintended consequences if a malicious user attempts to set an extremely large staking period.

RECOMMENDED MITIGATION:
Add a validation check to ensure that the staking period is within a reasonable range. For example:
```
require(_period > 0 && _period <= MAX_REASONABLE_PERIOD, ""Invalid staking period"");
```
'''

VULNERABILITY NAME: Lack of Input Validation for Amounts
'''
In functions like `yieldStrategyDeposit`, `yieldStrategyWithdraw`, and `initialStake`, the contract checks for zero amounts but does not validate if the amounts are within acceptable limits. For instance, a user could potentially pass an excessively large amount that could lead to unexpected behavior or gas issues.

RECOMMENDED MITIGATION:
Implement checks to ensure that the amounts passed to these functions are within a reasonable range. For example:
```
require(_amount > 0 && _amount <= MAX_REASONABLE_AMOUNT, ""Invalid amount"");
```
'''

VULNERABILITY NAME: Lack of Input Validation for Token Transfers
'''
In the `_transferTokensOut` function, there is no validation to check if the `_amount` to be transferred is greater than the balance of the contract. If the amount exceeds the available balance, it could lead to a failed transaction or unexpected behavior.

RECOMMENDED MITIGATION:
Add a check to ensure that the amount to be transferred does not exceed the contract's balance:
```
require(_amount <= token.balanceOf(address(this)), ""Insufficient balance"");
```
'''
```

[2024-11-08 04:56:12 INFO] **[Seminar Conclusion]**:

 ",
,,,,,,,,,,,,"<INFO> Lack of Withdrawal Function Identified.
```

[2024-11-08 04:54:32 INFO] **[Execute Detail]**

execute SimplePhase:[LackAuthorizationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 04:54:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Lack of Authorization. This type of vulnerability occurs when functions are accessible to unauthorized users, leading to potential misuse and exploitation of contract functionalities. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify all functions that modify the state of the contract or perform sensitive operations. 2. Determine if each identified function has appropriate access control mechanisms, such as onlyOwner, onlyAdmin, or other custom modifiers that restrict access to authorized users only. 3. Look for any functions that do not have explicit access control modifiers and assess whether their unrestricted access could lead to unauthorized actions. 4. Evaluate the current access control setup for potential bypasses or weaknesses that could allow unauthorized users to call restricted functions. If you discover any Lack of Authorization vulnerabilities, respond with: "" Lack of Authorization Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Lack of Authorization vulnerabilities are found, respond only with: "" NO Lack of Authorization."" |
| **phase_name** | LackAuthorizationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': ' Lack of Withdrawal Function Identified.\n```'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 04:54:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 04:54:32 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
"".
Ideas: "" Lack of Withdrawal Function Identified.
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Lack of Authorization. This type of vulnerability occurs when functions are accessible to unauthorized users, leading to potential misuse and exploitation of contract functionalities.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify all functions that modify the state of the contract or perform sensitive operations.
2. Determine if each identified function has appropriate access control mechanisms, such as `onlyOwner`, `onlyAdmin`, or other custom modifiers that restrict access to authorized users only.
3. Look for any functions that do not have explicit access control modifiers and assess whether their unrestricted access could lead to unauthorized actions.
4. Evaluate the current access control setup for potential bypasses or weaknesses that could allow unauthorized users to call restricted functions.
If you discover any Lack of Authorization vulnerabilities, respond with: ""","<INFO> Lack of Authorization Identified.

```
LACK OF WITHDRAWAL FUNCTION
'''
The contract does not provide a withdrawal function for users to retrieve their staked tokens (USDC) after the lockup period ends. This absence could lead to a situation where users are unable to access their funds, especially if the contract owner or other authorized parties become unreachable or if the contract encounters issues. 

To mitigate this risk, it is recommended to implement a withdrawal function that allows users to withdraw their staked tokens after the lockup period has expired. This function should ensure that only the rightful owners of the NFTs can withdraw their corresponding USDC, thus maintaining security and access control.
'''
```

```
LACK OF AUTHORIZATION ON PayoutClaim FUNCTION
'''
The `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no explicit check to ensure that the caller is indeed the authorized claim manager. If an attacker were to gain control of an address that is not the claim manager, they could potentially call this function and initiate unauthorized payouts.

To mitigate this risk, it is crucial to implement a more robust access control mechanism. This can be done by adding an explicit check to verify that the `msg.sender` is the correct `sherlockClaimManager` before proceeding with the payout logic.
'''
```

```
LACK OF AUTHORIZATION ON yieldStrategyWithdraw FUNCTION
'''
The `yieldStrategyWithdraw` function allows the owner to withdraw tokens from the yield strategy. However, if the ownership of the contract is compromised, an unauthorized user could potentially withdraw funds from the yield strategy, leading to loss of funds.

To mitigate this risk, it is recommended to implement a multi-signature wallet for ownership or a time-lock mechanism for sensitive functions like withdrawals. This would require multiple parties to approve such actions, thereby reducing the risk of unauthorized withdrawals.
'''
```

```
LACK OF AUTHORIZATION ON updateSherDistributionManager FUNCTION
'''
The `updateSherDistributionManager` function allows the contract owner to change the distribution manager. If the owner’s private key is compromised, an attacker could change the distribution manager to a malicious contract, leading to potential loss of funds or manipulation of rewards.

To mitigate this risk, it is advisable to implement a multi-signature requirement for changing critical parameters such as the distribution manager. This would ensure that multiple trusted parties must agree before such changes can be made.
'''
```

[2024-11-08 04:54:40 INFO] **[Execute Detail]**

execute SimplePhase:[DataInconsistencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 04:54:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data. 2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly. 3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data. 4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data. If you discover any Potential Data Inconsistency vulnerabilities, respond with: "" Potential Data Inconsistency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Potential Data Inconsistency vulnerabilities are found, respond only with: "" NO Potential Data Inconsistency."" |
| **phase_name** | DataInconsistencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': "" Lack of Authorization Identified.\n\n\nLACK OF WITHDRAWAL FUNCTION\n'''\nThe contract does not provide a withdrawal function for users to retrieve their staked tokens (USDC) after the lockup period ends. This absence could lead to a situation where users are unable to access their funds, especially if the contract owner or other authorized parties become unreachable or if the contract encounters issues. \n\nTo mitigate this risk, it is recommended to implement a withdrawal function that allows users to withdraw their staked tokens after the lockup period has expired. This function should ensure that only the rightful owners of the NFTs can withdraw their corresponding USDC, thus maintaining security and access control.\n'''\n\n\n\nLACK OF AUTHORIZATION ON PayoutClaim FUNCTION\n'''\nThe `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no explicit check to ensure that the caller is indeed the authorized claim manager. If an attacker were to gain control of an address that is not the claim manager, they could potentially call this function and initiate unauthorized payouts.\n\nTo mitigate this risk, it is crucial to implement a more robust access control mechanism. This can be done by adding an explicit check to verify that the `msg.sender` is the correct `sherlockClaimManager` before proceeding with the payout logic.\n'''\n\n\n\nLACK OF AUTHORIZATION ON yieldStrategyWithdraw FUNCTION\n'''\nThe `yieldStrategyWithdraw` function allows the owner to withdraw tokens from the yield strategy. However, if the ownership of the contract is compromised, an unauthorized user could potentially withdraw funds from the yield strategy, leading to loss of funds.\n\nTo mitigate this risk, it is recommended to implement a multi-signature wallet for ownership or a time-lock mechanism for sensitive functions like withdrawals. This would require multiple parties to approve such actions, thereby reducing the risk of unauthorized withdrawals.\n'''\n\n\n\nLACK OF AUTHORIZATION ON updateSherDistributionManager FUNCTION\n'''\nThe `updateSherDistributionManager` function allows the contract owner to change the distribution manager. If the owner’s private key is compromised, an attacker could change the distribution manager to a malicious contract, leading to potential loss of funds or manipulation of rewards.\n\nTo mitigate this risk, it is advisable to implement a multi-signature requirement for changing critical parameters such as the distribution manager. This would ensure that multiple trusted parties must agree before such changes can be made.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 04:54:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 04:54:40 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
"".
Ideas: "" Lack of Authorization Identified.

```
LACK OF WITHDRAWAL FUNCTION
'''
The contract does not provide a withdrawal function for users to retrieve their staked tokens (USDC) after the lockup period ends. This absence could lead to a situation where users are unable to access their funds, especially if the contract owner or other authorized parties become unreachable or if the contract encounters issues. 

To mitigate this risk, it is recommended to implement a withdrawal function that allows users to withdraw their staked tokens after the lockup period has expired. This function should ensure that only the rightful owners of the NFTs can withdraw their corresponding USDC, thus maintaining security and access control.
'''
```

```
LACK OF AUTHORIZATION ON PayoutClaim FUNCTION
'''
The `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no explicit check to ensure that the caller is indeed the authorized claim manager. If an attacker were to gain control of an address that is not the claim manager, they could potentially call this function and initiate unauthorized payouts.

To mitigate this risk, it is crucial to implement a more robust access control mechanism. This can be done by adding an explicit check to verify that the `msg.sender` is the correct `sherlockClaimManager` before proceeding with the payout logic.
'''
```

```
LACK OF AUTHORIZATION ON yieldStrategyWithdraw FUNCTION
'''
The `yieldStrategyWithdraw` function allows the owner to withdraw tokens from the yield strategy. However, if the ownership of the contract is compromised, an unauthorized user could potentially withdraw funds from the yield strategy, leading to loss of funds.

To mitigate this risk, it is recommended to implement a multi-signature wallet for ownership or a time-lock mechanism for sensitive functions like withdrawals. This would require multiple parties to approve such actions, thereby reducing the risk of unauthorized withdrawals.
'''
```

```
LACK OF AUTHORIZATION ON updateSherDistributionManager FUNCTION
'''
The `updateSherDistributionManager` function allows the contract owner to change the distribution manager. If the owner’s private key is compromised, an attacker could change the distribution manager to a malicious contract, leading to potential loss of funds or manipulation of rewards.

To mitigate this risk, it is advisable to implement a multi-signature requirement for changing critical parameters such as the distribution manager. This would ensure that multiple trusted parties must agree before such changes can be made.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data.
2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly.
3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data.
4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data.
If you discover any Potential Data Inconsistency vulnerabilities, respond with: ""","<INFO> Potential Data Inconsistency Identified.

```
POTENTIAL DATA INCONSISTENCY IN _redeemSharesCalc FUNCTION
'''
The function `_redeemSharesCalc` calculates the amount of USDC owed to a given amount of stake shares by performing a division operation involving `totalTokenBalanceStakers()` and `totalStakeShares`. If `totalStakeShares` is zero, this could lead to a division by zero error, which would cause the function to revert. Additionally, if `totalTokenBalanceStakers()` changes between the time it is called and when the result is used, it could lead to inconsistencies in the amount

[2024-11-08 04:54:46 INFO] **[Execute Detail]**

execute SimplePhase:[HashCollisionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 04:54:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any functions that generate hashes from input values. 2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of abi.encodePacked for concatenation. 3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions. 4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized. If you discover any Hash Collision vulnerabilities, respond with: "" Hash Collision Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Hash Collision vulnerabilities are found, respond only with: "" NO Hash Collision."" |
| **phase_name** | HashCollisionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': "" Potential Data Inconsistency Identified.\n\n``\nPOTENTIAL DATA INCONSISTENCY IN _redeemSharesCalc FUNCTION\n'''\nThe function_redeemSharesCalccalculates the amount of USDC owed to a given amount of stake shares by performing a division operation involvingtotalTokenBalanceStakers()andtotalStakeShares. IftotalStakeSharesis zero, this could lead to a division by zero error, which would cause the function to revert. Additionally, iftotalTokenBalanceStakers()` changes between the time it is called and when the result is used, it could lead to inconsistencies in the amount""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 04:54:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 04:54:46 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
"".
Ideas: "" Potential Data Inconsistency Identified.

```
POTENTIAL DATA INCONSISTENCY IN _redeemSharesCalc FUNCTION
'''
The function `_redeemSharesCalc` calculates the amount of USDC owed to a given amount of stake shares by performing a division operation involving `totalTokenBalanceStakers()` and `totalStakeShares`. If `totalStakeShares` is zero, this could lead to a division by zero error, which would cause the function to revert. Additionally, if `totalTokenBalanceStakers()` changes between the time it is called and when the result is used, it could lead to inconsistencies in the amount"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any functions that generate hashes from input values.
2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of `abi.encodePacked` for concatenation.
3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions.
4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized.
If you discover any Hash Collision vulnerabilities, respond with: """,,,,,,"<INFO> Precision Loss Identified.

VULNERABILITY NAME: Precision Loss in Arithmetic Operations
'''
The contract performs several arithmetic operations involving division, particularly in the functions `_redeemSharesCalc` and `tokenBalanceOf`. These operations use integer division, which can lead to precision loss when dealing with fractional values. For example, in the calculation of shares owed to a position or an address, if the total amount of tokens owed to all stakers is not evenly divisible by the stake shares, the result will be truncated, leading to potential underpayment or overpayment of rewards.

To mitigate this issue, it is recommended to use a scaling factor (e.g., multiplying by a large number like 10**18) before performing the division and then dividing the final result by the same scaling factor. This approach helps maintain precision in calculations involving fractional values.
'''

[2024-11-08 04:55:03 INFO] **[Execute Detail]**

execute SimplePhase:[RedundantConditionalDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 04:55:04 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities: 1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code. 2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution. If you identify any redundant conditional checks, respond with: "" Redundant Conditional Check Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Redundant Conditional Checks."" |
| **phase_name** | RedundantConditionalDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 1018,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': "" Precision Loss Identified.\n\nVULNERABILITY NAME: Precision Loss in Arithmetic Operations\n'''\nThe contract performs several arithmetic operations involving division, particularly in the functions _redeemSharesCalc and tokenBalanceOf. These operations use integer division, which can lead to precision loss when dealing with fractional values. For example, in the calculation of shares owed to a position or an address, if the total amount of tokens owed to all stakers is not evenly divisible by the stake shares, the result will be truncated, leading to potential underpayment or overpayment of rewards.\n\nTo mitigate this issue, it is recommended to use a scaling factor (e.g., multiplying by a large number like 1018) before performing the division and then dividing the final result by the same scaling factor. This approach helps maintain precision in calculations involving fractional values.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 04:55:04 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 04:55:04 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
"".
Ideas: "" Precision Loss Identified.

VULNERABILITY NAME: Precision Loss in Arithmetic Operations
'''
The contract performs several arithmetic operations involving division, particularly in the functions `_redeemSharesCalc` and `tokenBalanceOf`. These operations use integer division, which can lead to precision loss when dealing with fractional values. For example, in the calculation of shares owed to a position or an address, if the total amount of tokens owed to all stakers is not evenly divisible by the stake shares, the result will be truncated, leading to potential underpayment or overpayment of rewards.

To mitigate this issue, it is recommended to use a scaling factor (e.g., multiplying by a large number like 10**18) before performing the division and then dividing the final result by the same scaling factor. This approach helps maintain precision in calculations involving fractional values.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities:
1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code.
2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution.
If you identify any redundant conditional checks, respond with: ""","<INFO> Redundant Conditional Check Identified.
'''
In the `updateSherDistributionManager` function, there is a check to see if the new distribution manager address is not zero. This check is redundant because it is already performed in the constructor when setting the initial distribution manager. Additionally, the check for whether the new address is the same as the current one is also unnecessary as it does not change the state of the contract if they are the same.

To mitigate this issue, the redundant checks can be removed from the `updateSherDistributionManager` function, simplifying the code and reducing gas costs.
'''

[2024-11-08 04:55:07 INFO] **[Execute Detail]**

execute SimplePhase:[OracleDependencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 04:55:07 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities: 1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected. 2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations. If you identify reliance on a single external oracle for critical data, respond with: "" External Oracle Dependency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO External Oracle Dependency."" |
| **phase_name** | OracleDependencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': "" Redundant Conditional Check Identified.\n'''\nIn the updateSherDistributionManager function, there is a check to see if the new distribution manager address is not zero. This check is redundant because it is already performed in the constructor when setting the initial distribution manager. Additionally, the check for whether the new address is the same as the current one is also unnecessary as it does not change the state of the contract if they are the same.\n\nTo mitigate this issue, the redundant checks can be removed from the updateSherDistributionManager function, simplifying the code and reducing gas costs.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 04:55:07 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 04:55:07 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
"".
Ideas: "" Redundant Conditional Check Identified.
'''
In the `updateSherDistributionManager` function, there is a check to see if the new distribution manager address is not zero. This check is redundant because it is already performed in the constructor when setting the initial distribution manager. Additionally, the check for whether the new address is the same as the current one is also unnecessary as it does not change the state of the contract if they are the same.

To mitigate this issue, the redundant checks can be removed from the `updateSherDistributionManager` function, simplifying the code and reducing gas costs.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities:
1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected.
2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations.
If you identify reliance on a single external oracle for critical data, respond with: """,,,"<INFO> Centralization Risk Identified.

**Centralization of Control**
'''
The contract has several functions that can only be executed by the `owner`, which centralizes control in a single address. This includes critical functions such as `enableStakingPeriod`, `disableStakingPeriod`, `updateSherDistributionManager`, `removeSherDistributionManager`, `updateNonStakersAddress`, `updateSherlockProtocolManager`, `updateSherlockClaimManager`, and `updateYieldStrategy`. If the owner's private key is compromised, an attacker could execute any of these functions, potentially leading to loss of funds or manipulation of the contract's behavior.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for the ownership functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive functions, reducing the risk associated with a single point of failure. Additionally, consider implementing a governance mechanism where stakeholders can vote on critical changes, further decentralizing control.
'''

**Lack of Emergency Mechanisms**
'''
The contract has the ability to pause operations via the `pause` and `unpause` functions, but these can only be executed by the `owner`. If the owner account is compromised, an attacker could pause the contract, preventing all operations and effectively locking users out of their funds.

**Recommended Mitigation/Fix:**
Introduce a multi-signature mechanism for the pause and unpause functions as well. This ensures that no single entity can unilaterally halt the contract's operations, providing a safeguard against potential abuse.
'''

**Single Point of Failure in Yield Strategy**
'''
The contract relies on a single yield strategy contract, which can be updated only by the `owner`. If the yield strategy contract has vulnerabilities or is compromised, it could lead to loss of funds for all users.

**Recommended Mitigation/Fix:**
Consider implementing a governance model where stakeholders can vote on changes to the yield strategy. This would allow for community oversight and reduce the risk associated with a single point of failure.
'''

[2024-11-08 04:55:21 INFO] **[Execute Detail]**

execute SimplePhase:[FundingCalculationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 04:55:22 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities: 1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation. 2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation. If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: "" Incorrect Funding Rate Calculation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Incorrect Funding Rate Calculation."" |
| **phase_name** | FundingCalculationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 1018,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': "" Centralization Risk Identified.\n\nCentralization of Control\n'''\nThe contract has several functions that can only be executed by the owner, which centralizes control in a single address. This includes critical functions such as enableStakingPeriod, disableStakingPeriod, updateSherDistributionManager, removeSherDistributionManager, updateNonStakersAddress, updateSherlockProtocolManager, updateSherlockClaimManager, and updateYieldStrategy. If the owner's private key is compromised, an attacker could execute any of these functions, potentially leading to loss of funds or manipulation of the contract's behavior.\n\nRecommended Mitigation/Fix:\nImplement a multi-signature wallet for the ownership functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive functions, reducing the risk associated with a single point of failure. Additionally, consider implementing a governance mechanism where stakeholders can vote on critical changes, further decentralizing control.\n'''\n\nLack of Emergency Mechanisms\n'''\nThe contract has the ability to pause operations via the pause and unpause functions, but these can only be executed by the owner. If the owner account is compromised, an attacker could pause the contract, preventing all operations and effectively locking users out of their funds.\n\nRecommended Mitigation/Fix:\nIntroduce a multi-signature mechanism for the pause and unpause functions as well. This ensures that no single entity can unilaterally halt the contract's operations, providing a safeguard against potential abuse.\n'''\n\nSingle Point of Failure in Yield Strategy\n'''\nThe contract relies on a single yield strategy contract, which can be updated only by the owner. If the yield strategy contract has vulnerabilities or is compromised, it could lead to loss of funds for all users.\n\nRecommended Mitigation/Fix:**\nConsider implementing a governance model where stakeholders can vote on changes to the yield strategy. This would allow for community oversight and reduce the risk associated with a single point of failure.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 04:55:22 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 04:55:22 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
"".
Ideas: "" Centralization Risk Identified.

**Centralization of Control**
'''
The contract has several functions that can only be executed by the `owner`, which centralizes control in a single address. This includes critical functions such as `enableStakingPeriod`, `disableStakingPeriod`, `updateSherDistributionManager`, `removeSherDistributionManager`, `updateNonStakersAddress`, `updateSherlockProtocolManager`, `updateSherlockClaimManager`, and `updateYieldStrategy`. If the owner's private key is compromised, an attacker could execute any of these functions, potentially leading to loss of funds or manipulation of the contract's behavior.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for the ownership functions to distribute control among multiple trusted parties. This would require multiple signatures to execute sensitive functions, reducing the risk associated with a single point of failure. Additionally, consider implementing a governance mechanism where stakeholders can vote on critical changes, further decentralizing control.
'''

**Lack of Emergency Mechanisms**
'''
The contract has the ability to pause operations via the `pause` and `unpause` functions, but these can only be executed by the `owner`. If the owner account is compromised, an attacker could pause the contract, preventing all operations and effectively locking users out of their funds.

**Recommended Mitigation/Fix:**
Introduce a multi-signature mechanism for the pause and unpause functions as well. This ensures that no single entity can unilaterally halt the contract's operations, providing a safeguard against potential abuse.
'''

**Single Point of Failure in Yield Strategy**
'''
The contract relies on a single yield strategy contract, which can be updated only by the `owner`. If the yield strategy contract has vulnerabilities or is compromised, it could lead to loss of funds for all users.

**Recommended Mitigation/Fix:**
Consider implementing a governance model where stakeholders can vote on changes to the yield strategy. This would allow for community oversight and reduce the risk associated with a single point of failure.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities:
1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation.
2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation.
If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: """,,,,,,,,,,,,,,,"<INFO> Lack of Input Validation Identified.

```
VULNERABILITY NAME: Zero Address Validation
'''
In several functions, the contract does not adequately check for zero addresses. For example, in the constructor, the contract checks if the token addresses are zero, but similar checks are not consistently applied in functions like `updateNonStakersAddress`, `updateSherDistributionManager`, `updateSherlockProtocolManager`, and `updateSherlockClaimManager`. This could lead to unintended behavior if a zero address is passed, potentially allowing funds to be sent to an invalid address.

RECOMMENDED MITIGATION:
Ensure that all functions that accept an address as an input validate that the address is not zero. This can be done by adding a check at the beginning of each function:
```
require(_address != address(0), ""Zero address not allowed"");
```
'''

VULNERABILITY NAME: Lack of Input Validation for Staking Periods
'''
In the `enableStakingPeriod` and `disableStakingPeriod` functions, there is a lack of validation for the staking period input. While there is a check for zero values, there is no check to ensure that the period is a reasonable value (e.g., it should not be excessively large). This could lead to unintended consequences if a malicious user attempts to set an extremely large staking period.

RECOMMENDED MITIGATION:
Add a validation check to ensure that the staking period is within a reasonable range. For example:
```
require(_period > 0 && _period <= MAX_REASONABLE_PERIOD, ""Invalid staking period"");
```
'''

VULNERABILITY NAME: Lack of Input Validation for Amounts
'''
In functions like `yieldStrategyDeposit`, `yieldStrategyWithdraw`, and `initialStake`, the contract checks for zero amounts but does not validate if the amounts are within acceptable limits. For instance, a user could potentially pass an excessively large amount that could lead to unexpected behavior or gas issues.

RECOMMENDED MITIGATION:
Implement checks to ensure that the amounts passed to these functions are within a reasonable range. For example:
```
require(_amount > 0 && _amount <= MAX_REASONABLE_AMOUNT, ""Invalid amount"");
```
'''

VULNERABILITY NAME: Lack of Input Validation for Token Transfers
'''
In the `_transferTokensOut` function, there is no validation to check if the `_amount` to be transferred is greater than the balance of the contract. If the amount exceeds the available balance, it could lead to a failed transaction or unexpected behavior.

RECOMMENDED MITIGATION:
Add a check to ensure that the amount to be transferred does not exceed the contract's balance:
```
require(_amount <= token.balanceOf(address(this)), ""Insufficient balance"");
```
'''
```

[2024-11-08 04:56:12 INFO] **[Execute Detail]**

execute SimplePhase:[DoSDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 04:56:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."". Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases: 1. When loops have an unbounded iteration count, leading to potential gas exhaustion. 2. When the contract makes external calls that can fail or consume excessive gas. 3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures. 4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion. 2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures. 3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS. 4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics. If you identify any DoS vulnerabilities, respond with: "" DoS Vulnerability Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades. ''' If you don't find any vulnerabilities, respond only with: "" No DoS Vulnerabilities."" |
| **phase_name** | DoSDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': ' Lack of Input Validation Identified.\n\n\nVULNERABILITY NAME: Zero Address Validation\n\'\'\'\nIn several functions, the contract does not adequately check for zero addresses. For example, in the constructor, the contract checks if the token addresses are zero, but similar checks are not consistently applied in functions like `updateNonStakersAddress`, `updateSherDistributionManager`, `updateSherlockProtocolManager`, and `updateSherlockClaimManager`. This could lead to unintended behavior if a zero address is passed, potentially allowing funds to be sent to an invalid address.\n\nRECOMMENDED MITIGATION:\nEnsure that all functions that accept an address as an input validate that the address is not zero. This can be done by adding a check at the beginning of each function:\n\nrequire(_address != address(0), ""Zero address not allowed"");\n\n\'\'\'\n\nVULNERABILITY NAME: Lack of Input Validation for Staking Periods\n\'\'\'\nIn the `enableStakingPeriod` and `disableStakingPeriod` functions, there is a lack of validation for the staking period input. While there is a check for zero values, there is no check to ensure that the period is a reasonable value (e.g., it should not be excessively large). This could lead to unintended consequences if a malicious user attempts to set an extremely large staking period.\n\nRECOMMENDED MITIGATION:\nAdd a validation check to ensure that the staking period is within a reasonable range. For example:\n\nrequire(_period &gt; 0 &amp;&amp; _period &lt;= MAX_REASONABLE_PERIOD, ""Invalid staking period"");\n\n\'\'\'\n\nVULNERABILITY NAME: Lack of Input Validation for Amounts\n\'\'\'\nIn functions like `yieldStrategyDeposit`, `yieldStrategyWithdraw`, and `initialStake`, the contract checks for zero amounts but does not validate if the amounts are within acceptable limits. For instance, a user could potentially pass an excessively large amount that could lead to unexpected behavior or gas issues.\n\nRECOMMENDED MITIGATION:\nImplement checks to ensure that the amounts passed to these functions are within a reasonable range. For example:\n\nrequire(_amount &gt; 0 &amp;&amp; _amount &lt;= MAX_REASONABLE_AMOUNT, ""Invalid amount"");\n\n\'\'\'\n\nVULNERABILITY NAME: Lack of Input Validation for Token Transfers\n\'\'\'\nIn the `_transferTokensOut` function, there is no validation to check if the `_amount` to be transferred is greater than the balance of the contract. If the amount exceeds the available balance, it could lead to a failed transaction or unexpected behavior.\n\nRECOMMENDED MITIGATION:\nAdd a check to ensure that the amount to be transferred does not exceed the contract\'s balance:\n\nrequire(_amount &lt;= token.balanceOf(address(this)), ""Insufficient balance"");\n\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 04:56:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 04:56:12 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the ""before"" total amount of tokens, multiplied by the ""before"" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."".
Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases:
1. When loops have an unbounded iteration count, leading to potential gas exhaustion.
2. When the contract makes external calls that can fail or consume excessive gas.
3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures.
4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion.
2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures.
3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS.
4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics.
If you identify any DoS vulnerabilities, respond with: """,
