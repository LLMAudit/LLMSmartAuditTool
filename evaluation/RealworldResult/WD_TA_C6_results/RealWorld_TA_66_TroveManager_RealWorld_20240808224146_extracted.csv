Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the provided contract, there are instances where low-level calls are made without proper error handling. Specifically, the use of `call`, `delegatecall`, or `send` can lead to vulnerabilities if the external contract's behavior is not as expected or if the call fails. For example, if a low-level call is made to an untrusted contract, it may execute malicious code or fail silently, leading to unexpected behavior in the calling contract.

To mitigate this vulnerability, it is recommended to use the `require` statement to check the success of low-level calls. For instance, after a low-level call, the return value should be checked, and if it is false, the transaction should be reverted. This ensures that the calling contract only proceeds if the external call was successful.

Example fix:
```solidity
(bool success, ) = externalContract.call(data);
require(success, ""External call failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
Another instance of unchecked low-level calls can be found in the `redistributeDebtAndColl` function, where the contract calls external functions without checking if the call was successful. If the external contract fails to execute properly, it could lead to loss of funds or inconsistent state within the contract.

To address this, implement checks after each low-level call to ensure that the call was successful. If it fails, revert the transaction to maintain the integrity of the contract's state.

Example fix:
```solidity
(bool success, ) = _activePool.decreaseYUSDDebt(_debt);
require(success, ""Failed to decrease YUSD debt"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `movePendingTroveRewardsToActivePool` function, there are calls to external contracts that are not checked for success. If these calls fail, the contract may end up in an inconsistent state, potentially leading to a loss of funds or rewards.

To mitigate this risk, ensure that all low-level calls to external contracts are followed by checks on their return values. If a call fails, revert the transaction to prevent any unintended consequences.

Example fix:
```solidity
(bool success, ) = _defaultPool.decreaseYUSDDebt(_YUSD);
require(success, ""Failed to decrease YUSD debt in default pool"");
```
'''
```

[2024-08-08 22:42:13 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the provided contract, there are instances where low-level calls are made without proper error handling. Specifically, the use of `call`, `delegatecall`, or `send` can lead to vulnerabilities if the external contract's behavior is not as expected or if the call fails. For example, if a low-level call is made to an untrusted contract, it may execute malicious code or fail silently, leading to unexpected behavior in the calling contract.

To mitigate this vulnerability, it is recommended to use the `require` statement to check the success of low-level calls. For instance, after a low-level call, the return value should be checked, and if it is false, the transaction should be reverted. This ensures that the calling contract only proceeds if the external call was successful.

Example fix:
```solidity
(bool success, ) = externalContract.call(data);
require(success, ""External call failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
Another instance of unchecked low-level calls can be found in the `redistributeDebtAndColl` function, where the contract calls external functions without checking if the call was successful. If the external contract fails to execute properly, it could lead to loss of funds or inconsistent state within the contract.

To address this, implement checks after each low-level call to ensure that the call was successful. If it fails, revert the transaction to maintain the integrity of the contract's state.

Example fix:
```solidity
(bool success, ) = _activePool.decreaseYUSDDebt(_debt);
require(success, ""Failed to decrease YUSD debt"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `movePendingTroveRewardsToActivePool` function, there are calls to external contracts that are not checked for success. If these calls fail, the contract may end up in an inconsistent state, potentially leading to a loss of funds or rewards.

To mitigate this risk, ensure that all low-level calls to external contracts are followed by checks on their return values. If a call fails, revert the transaction to prevent any unintended consequences.

Example fix:
```solidity
(bool success, ) = _defaultPool.decreaseYUSDDebt(_YUSD);
require(success, ""Failed to decrease YUSD debt in default pool"");
```
'''
```

[2024-08-08 22:42:13 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-08-08 22:42:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import ""./Interfaces/ITroveManager.sol""; import ""./Interfaces/IStabilityPool.sol""; import ""./Interfaces/ICollSurplusPool.sol""; import ""./Interfaces/IYUSDToken.sol""; import ""./Interfaces/ISortedTroves.sol""; import ""./Interfaces/IYETIToken.sol""; import ""./Interfaces/ISYETI.sol""; import ""./Interfaces/IWhitelist.sol""; import ""./Interfaces/ITroveManagerLiquidations.sol""; import ""./Interfaces/ITroveManagerRedemptions.sol""; import ""./Interfaces/IERC20.sol""; import ""./Dependencies/TroveManagerBase.sol""; import ""./Dependencies/ReentrancyGuard.sol""; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = ""TroveManager"";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: ""CompilerError: Stack too deep"". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, ""TM: borrowers length mismatch"");     require(lowerHintsLen == _upperHints.length, ""TM: hints length mismatch"");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, ""TM: stake must be &gt; 0"");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, ""TM: len tokens amounts"");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a ""feedback""     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate ""per-unit-staked"" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, ""Status must be active and exists"");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, ""TM: trove !exists or !active"");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, ""TM: index must be &gt; last index"");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, ""TM: newBaseRate must be &gt; 0"");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, ""TM:Fee&gt;returned colls"");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, ""TM: decayed base rate too small"");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert(""TM: External caller not allowed""); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, ""TM: trove must exist""); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, ""TM: last trove""); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, ""TM: length mismatch"");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport ""./Interfaces/ITroveManager.sol"";\nimport ""./Interfaces/IStabilityPool.sol"";\nimport ""./Interfaces/ICollSurplusPool.sol"";\nimport ""./Interfaces/IYUSDToken.sol"";\nimport ""./Interfaces/ISortedTroves.sol"";\nimport ""./Interfaces/IYETIToken.sol"";\nimport ""./Interfaces/ISYETI.sol"";\nimport ""./Interfaces/IWhitelist.sol"";\nimport ""./Interfaces/ITroveManagerLiquidations.sol"";\nimport ""./Interfaces/ITroveManagerRedemptions.sol"";\nimport ""./Interfaces/IERC20.sol"";\nimport ""./Dependencies/TroveManagerBase.sol"";\nimport ""./Dependencies/ReentrancyGuard.sol"";\n\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\n\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    bytes32 constant public NAME = ""TroveManager"";\n\n    // --- Data structures ---\n\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n\n    mapping (address =&gt; Trove) Troves;\n\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: ""CompilerError: Stack too deep"".\n    /\n\n    // --- Events ---\n\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n\n    // --- Liquidation helper functions ---\n\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, ""TM: borrowers length mismatch"");\n        require(lowerHintsLen == _upperHints.length, ""TM: hints length mismatch"");\n\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n\n            uint stake =  Troves[_borrower].stakes[coll];\n\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n\n        debt = debt.add(pendingYUSDDebtReward);\n\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, ""TM: stake must be &gt; 0"");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, ""TM: len tokens amounts"");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a ""feedback""\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate ""per-unit-staked"" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, ""Status must be active and exists"");\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, ""TM: trove !exists or !active"");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        require(index &lt;= idxLast, ""TM: index must be &gt; last index"");\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n\n    // --- Redemption fee functions ---\n\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, ""TM: newBaseRate must be &gt; 0"");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, ""TM:Fee&gt;returned colls"");\n        return redemptionFee;\n    }\n\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, ""TM: decayed base rate too small"");  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- \'require\' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view{\n        revert(""TM: External caller not allowed"");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, ""TM: trove must exist"");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, ""TM: last trove"");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    // -- Trove Manager State Variable Getters -- \n\n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n\n    // --- Called by TroveManagerRedemptions Only ---\n\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n\n    // --- Called by TroverManagerLiquidations Only ---\n\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, ""TM: length mismatch"");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    // --- contract getters ---\n\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the provided contract, there are instances where low-level calls are made without proper error handling. Specifically, the use of `call`, `delegatecall`, or `send` can lead to vulnerabilities if the external contract\'s behavior is not as expected or if the call fails. For example, if a low-level call is made to an untrusted contract, it may execute malicious code or fail silently, leading to unexpected behavior in the calling contract.\n\nTo mitigate this vulnerability, it is recommended to use the `require` statement to check the success of low-level calls. For instance, after a low-level call, the return value should be checked, and if it is false, the transaction should be reverted. This ensures that the calling contract only proceeds if the external call was successful.\n\nExample fix:\nsolidity\n(bool success, ) = externalContract.call(data);\nrequire(success, ""External call failed"");\n\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nAnother instance of unchecked low-level calls can be found in the `redistributeDebtAndColl` function, where the contract calls external functions without checking if the call was successful. If the external contract fails to execute properly, it could lead to loss of funds or inconsistent state within the contract.\n\nTo address this, implement checks after each low-level call to ensure that the call was successful. If it fails, revert the transaction to maintain the integrity of the contract\'s state.\n\nExample fix:\nsolidity\n(bool success, ) = _activePool.decreaseYUSDDebt(_debt);\nrequire(success, ""Failed to decrease YUSD debt"");\n\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `movePendingTroveRewardsToActivePool` function, there are calls to external contracts that are not checked for success. If these calls fail, the contract may end up in an inconsistent state, potentially leading to a loss of funds or rewards.\n\nTo mitigate this risk, ensure that all low-level calls to external contracts are followed by checks on their return values. If a call fails, revert the transaction to prevent any unintended consequences.\n\nExample fix:\nsolidity\n(bool success, ) = _defaultPool.decreaseYUSDDebt(_YUSD);\nrequire(success, ""Failed to decrease YUSD debt in default pool"");\n\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-08-08 22:42:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import ""./Interfaces/ITroveManager.sol""; import ""./Interfaces/IStabilityPool.sol""; import ""./Interfaces/ICollSurplusPool.sol""; import ""./Interfaces/IYUSDToken.sol""; import ""./Interfaces/ISortedTroves.sol""; import ""./Interfaces/IYETIToken.sol""; import ""./Interfaces/ISYETI.sol""; import ""./Interfaces/IWhitelist.sol""; import ""./Interfaces/ITroveManagerLiquidations.sol""; import ""./Interfaces/ITroveManagerRedemptions.sol""; import ""./Interfaces/IERC20.sol""; import ""./Dependencies/TroveManagerBase.sol""; import ""./Dependencies/ReentrancyGuard.sol""; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = ""TroveManager"";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: ""CompilerError: Stack too deep"". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, ""TM: borrowers length mismatch"");     require(lowerHintsLen == _upperHints.length, ""TM: hints length mismatch"");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, ""TM: stake must be &gt; 0"");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, ""TM: len tokens amounts"");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a ""feedback""     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate ""per-unit-staked"" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, ""Status must be active and exists"");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, ""TM: trove !exists or !active"");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, ""TM: index must be &gt; last index"");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, ""TM: newBaseRate must be &gt; 0"");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, ""TM:Fee&gt;returned colls"");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, ""TM: decayed base rate too small"");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert(""TM: External caller not allowed""); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, ""TM: trove must exist""); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, ""TM: last trove""); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, ""TM: length mismatch"");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-08-08 22:42:13 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/IYETIToken.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/ITroveManagerLiquidations.sol"";
import ""./Interfaces/ITroveManagerRedemptions.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Dependencies/TroveManagerBase.sol"";
import ""./Dependencies/ReentrancyGuard.sol"";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = ""TroveManager"";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: ""CompilerError: Stack too deep"".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, ""TM: borrowers length mismatch"");
        require(lowerHintsLen == _upperHints.length, ""TM: hints length mismatch"");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, ""TM: stake must be > 0"");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""TM: len tokens amounts"");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a ""feedback""
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate ""per-unit-staked"" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, ""Status must be active and exists"");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, ""TM: trove !exists or !active"");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, ""TM: index must be > last index"");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, ""TM: newBaseRate must be > 0"");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, ""TM:Fee>returned colls"");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, ""TM: decayed base rate too small"");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert(""TM: External caller not allowed"");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, ""TM: trove must exist"");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, ""TM: last trove"");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, ""TM: length mismatch"");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/IYETIToken.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/ITroveManagerLiquidations.sol"";
import ""./Interfaces/ITroveManagerRedemptions.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Dependencies/TroveManagerBase.sol"";
import ""./Dependencies/ReentrancyGuard.sol"";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = ""TroveManager"";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: ""CompilerError: Stack too deep"".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, ""TM: borrowers length mismatch"");
        require(lowerHintsLen == _upperHints.length, ""TM: hints length mismatch"");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, ""TM: stake must be > 0"");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""TM: len tokens amounts"");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a ""feedback""
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate ""per-unit-staked"" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, ""Status must be active and exists"");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, ""TM: trove !exists or !active"");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, ""TM: index must be > last index"");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, ""TM: newBaseRate must be > 0"");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, ""TM:Fee>returned colls"");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, ""TM: decayed base rate too small"");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert(""TM: External caller not allowed"");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, ""TM: trove must exist"");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, ""TM: last trove"");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, ""TM: length mismatch"");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the provided contract, there are instances where low-level calls are made without proper error handling. Specifically, the use of `call`, `delegatecall`, or `send` can lead to vulnerabilities if the external contract's behavior is not as expected or if the call fails. For example, if a low-level call is made to an untrusted contract, it may execute malicious code or fail silently, leading to unexpected behavior in the calling contract.

To mitigate this vulnerability, it is recommended to use the `require` statement to check the success of low-level calls. For instance, after a low-level call, the return value should be checked, and if it is false, the transaction should be reverted. This ensures that the calling contract only proceeds if the external call was successful.

Example fix:
```solidity
(bool success, ) = externalContract.call(data);
require(success, ""External call failed"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
Another instance of unchecked low-level calls can be found in the `redistributeDebtAndColl` function, where the contract calls external functions without checking if the call was successful. If the external contract fails to execute properly, it could lead to loss of funds or inconsistent state within the contract.

To address this, implement checks after each low-level call to ensure that the call was successful. If it fails, revert the transaction to maintain the integrity of the contract's state.

Example fix:
```solidity
(bool success, ) = _activePool.decreaseYUSDDebt(_debt);
require(success, ""Failed to decrease YUSD debt"");
```
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `movePendingTroveRewardsToActivePool` function, there are calls to external contracts that are not checked for success. If these calls fail, the contract may end up in an inconsistent state, potentially leading to a loss of funds or rewards.

To mitigate this risk, ensure that all low-level calls to external contracts are followed by checks on their return values. If a call fails, revert the transaction to prevent any unintended consequences.

Example fix:
```solidity
(bool success, ) = _defaultPool.decreaseYUSDDebt(_YUSD);
require(success, ""Failed to decrease YUSD debt in default pool"");
```
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
