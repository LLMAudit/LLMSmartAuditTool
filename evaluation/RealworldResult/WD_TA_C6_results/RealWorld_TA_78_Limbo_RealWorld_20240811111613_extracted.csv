Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,"<INFO> Unchecked External Calls Identified.

```
UNCHECKED EXTERNAL CALLS
'''
In the `migrate` function, the contract calls `IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);` and `AngbandLike(crossingConfig.angband).

[2024-11-08 11:16:37 INFO] **[Seminar Conclusion]**:

 ","<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `migrate` function, the contract makes a low-level call to the `power.parameterize` function without checking if the call succeeds. If the `parameterize` function fails, it could lead to unexpected behavior in the migration process, potentially resulting in a loss of tokens or funds.

Recommended Mitigation: Use the `require` statement to ensure that the low-level call succeeds. For example:
```
require(power.parameterize(token, crossingParams.burnable), ""Parameterization failed"");
```
This ensures that if the call fails, the transaction will revert, preventing any unintended consequences.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `migrate` function, after transferring tokens to the `morgothPower`, the contract calls `AngbandLike(crossingConfig.angband).executePower(...)` without checking if the call was successful. If this call fails, it could leave the contract in an inconsistent state.

Recommended Mitigation: Wrap the call in a `require` statement to ensure it succeeds:
```
require(AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower)), ""Execution of power failed"");
```
This will revert the transaction if the call fails, maintaining the integrity of the contract.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `claimSecondaryRewards` function, the contract calls `AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(...)` without checking if the call succeeds. If this function fails, it could result in unhandled funds or tokens being left in the contract.

Recommended Mitigation: Ensure that the call is checked for success:
```
require(AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender), ""Buying Flan and burning failed"");
```
This will ensure that any failure in this operation will revert the transaction and prevent loss of funds.
'''
```

[2024-11-08 11:16:43 INFO] **[Seminar Conclusion]**:

 ","<INFO> Transactions Order Dependence Identified.

VULNERABILITY NAME: Transactions Order Dependence in `migrate` Function
'''
In the `migrate` function, the order of operations is crucial. The function first transfers tokens to the `morgothPower` and then calls `AngbandLike(crossingConfig.angband).executePower(...)`. If a malicious actor can manipulate the transaction order, they could potentially execute their own transaction between these two calls, leading to unintended consequences such as incorrect token balances or failed migrations.

Recommended Mitigation: To prevent this vulnerability, consider implementing a reentrancy guard or using checks-effects-interactions pattern. This ensures that state changes are made before external calls, reducing the risk of transaction order manipulation.
'''

V

[2024-11-08 11:16:47 INFO] **[Seminar Conclusion]**:

 ","<INFO> Timestamp Manipulation Identified.
```
VULNERABILITY NAME: Timestamp Manipulation in `migrate` Function
'''
In the `migrate` function, the contract relies on the block timestamp to enforce a delay between the end of staking and the migration process. Specifically, it checks if the time elapsed since `stakingEndsTimestamp` is greater than `crossingConfig.crossingMigrationDelay`. This reliance on `block.timestamp` can be manipulated by miners, who can influence the timestamp of the block they mine. This could allow a malicious actor to manipulate the timing to their advantage, potentially allowing them to migrate tokens sooner than intended or to exploit the migration process.

Recommended Mitigation: To mitigate this vulnerability, consider using block numbers instead of timestamps for critical time-based conditions. Block numbers are less susceptible to manipulation as they are determined by the network consensus. Alternatively, if timestamps must be used, implement a mechanism that requires a minimum number of confirmations before allowing state changes based on timestamps, thus reducing the risk of manipulation.
'''
```

[2024-11-08 11:16:51 INFO] **[Seminar Conclusion]**:

 ",,,,,"<INFO> Price Manipulation Identified.

**VULNERABILITY NAME: Centralized Price Control**
'''
The contract relies on a centralized authority (governance) to adjust critical parameters such as the crossing threshold and bonuses (ICB and CBD) without sufficient checks or balances. This can lead to scenarios where a malicious actor or a colluding group can manipulate the token prices by adjusting these parameters to favor their trades, leading to unfair advantages in the market.

**Recommended Mitigation/Fix:** Implement a decentralized oracle mechanism to provide price feeds for tokens. This would ensure that price adjustments are based on market data rather than centralized governance decisions. Additionally, introduce a multi-signature requirement for critical parameter changes to prevent unilateral control.
'''

**VULNERABILITY NAME: Lack of Price Transparency**
'''
The contract does not provide a transparent mechanism for determining the prices of tokens involved in the migration process. This lack of transparency can lead to exploitation by insiders who may have access to privileged information regarding token valuations or migration events.

**Recommended Mitigation/Fix:** Utilize a decentralized price oracle to fetch real-time prices for tokens involved in the migration process. This would ensure that all users have access to the same pricing information and reduce the risk of manipulation by insiders. Furthermore, consider implementing a time-lock mechanism for any price-related changes to allow the community to react to potential manipulations.
'''

[2024-11-08 11:17:05 INFO] **[Seminar Conclusion]**:

 ",,"<INFO> Lack of Withdrawal Function Identified.
```

[2024-11-08 11:17:12 INFO] **[Seminar Conclusion]**:

 Upon reviewing the provided contract code, I have conducted a thorough analysis focusing on the presence and security of withdrawal functions. Here are the findings:

1. **Withdrawal Function Check**: 
   The contract does not contain any explicit function that allows users to withdraw their deposited funds. 

2. **Functions Related to Withdrawal**: 
   The contract primarily includes functions for staking (`stake`), unstaking (`unstake`), and claiming rewards (`claimReward`, `claimBonus`, etc.), but there is no function that facilitates the withdrawal of funds directly from the contract.

3. **Best Practices Evaluation**: 
   Since there is no withdrawal function present, there is no opportunity to evaluate its implementation against best practices such as the Checks-Effects-Interactions pattern or protections against reentrancy attacks.

4. **Impact Assessment**: 
   The absence of a withdrawal function significantly impacts users who have deposited funds into the contract. Users are unable to retrieve their funds once deposited, which poses a substantial risk. This lack of a secure withdrawal mechanism can lead to user frustration, loss of trust in the contract, and potential financial loss if the contract were to become compromised or if the project were to shut down.

Given the findings, I conclude with the following statement:

```
","<INFO> Lack of Authorization Identified.
```
LACK OF AUTHORIZATION
'''
The contract has several functions that modify the state of the contract or perform sensitive operations without appropriate access control mechanisms. Specifically, the following functions are identified as lacking explicit access control:

1. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval modifier, the lack of a specific access control modifier (like `onlyOwner` or `onlyAdmin`) could lead to misuse if governance is compromised.

2. `enableProtocol()`: Similar to `disableProtocol`, this function can be called by anyone who has passed a governance proposal, which may not adequately restrict access.

3. `configureCrossingConfig()`: This function allows configuration of global migration settings but is only protected by `onlySuccessfulProposal`, which may not sufficiently restrict access to unauthorized users.

4. `adjustSoul()`, `configureSoul()`, and `configureCrossingParameters()`: These functions allow for significant changes to the state of souls and crossing parameters but rely on governance approval without additional access control.

To mitigate these vulnerabilities, it is recommended to implement explicit access control modifiers for sensitive functions. For example, adding `onlyOwner` or `onlyAdmin` modifiers to functions that should only be callable by authorized personnel can help prevent unauthorized access. Additionally, consider implementing a role-based access control system to further restrict access based on user roles within the governance structure.
'''
```

[2024-11-08 11:17:18 INFO] **[Seminar Conclusion]**:

 ","<INFO> Potential Data Inconsistency Identified.
```
POTENTIAL DATA INCONSISTENCY
'''
The contract has several areas where data manipulation could lead to inconsistencies, particularly in the handling of user information and soul states. 

1. **User Data Updates**: In the `stake` function, the userâ€™s `stakedAmount` is updated based on the difference between the new balance and the old balance. However, if the token transfer fails or if there are discrepancies in the fee-on-transfer (FOT) tokens, the `stakedAmount` may not accurately reflect the actual amount staked. This could lead to inconsistencies in the user's reward calculations.

   **Mitigation**: Implement checks to ensure that the `oldBalance` and `newBalance` are consistent before updating `user.stakedAmount`. If the transfer fails or the balances do not match expected values, revert the transaction.

2. **Pending Rewards Calculation**: The `getPending` function calculates pending rewards based on the `accumulatedFlanPerShare` and `rewardDebt`. If the `accumulatedFlanPerShare` is not updated correctly in the

[2024-11-08 11:17:23 INFO] **[Seminar Conclusion]**:

 ",,,,"<INFO> Missing 'onlyOwner' Modifier Identified.

```
MISSING 'onlyOwner' MODIFIER
'''
The contract has several functions that can be executed without any access control, which may lead to unauthorized actions. Specifically, the following functions lack the 'onlyOwner' modifier or equivalent access control:

1. `configureCrossingConfig(...)`: This function allows the configuration of critical migration settings, including the address of the Behodler and the minimum delay between end of staking and migration. If an unauthorized user calls this function, they could change important parameters that could affect the entire protocol.

2. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval mechanism, it still poses a risk if the governance process is compromised or if malicious actors gain control over governance.

3. `enableProtocol()`: Similar to `disableProtocol`, this function allows the protocol to be re-enabled only through a formal proposal. However, without proper access control, it could be exploited.

4. `adjustSoul(...)`: This function allows rapid calibration of a soul, which can be critical for responding to market changes. If misused, it could lead to significant financial losses for users.

To mitigate these vulnerabilities, it is recommended to implement the 'onlyOwner' modifier or an equivalent access control mechanism on these functions to ensure that only authorized users (e.g., the contract owner or designated governance roles) can execute them. This will help prevent unauthorized access and potential exploitation of the contract.
'''
```

[2024-11-08 11:17:35 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `unstake` function, the following check is performed:

    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");

This check is redundant because the `soul` state is already being validated in the `stake` function, which ensures that the soul is in a valid state before any staking occurs. Therefore, if the `unstake` function is called, it can be assumed that the state has already been validated, making this check unnecessary.

To mitigate this, you can remove the redundant conditional check from the `unstake` function to reduce gas costs and simplify the code.
'''
```

",,,"<INFO> Centralization Risk Identified.

**Centralized Control through Governance Functions**
'''
The contract has several governance functions that can be executed by a single address (the governance address). For example, functions like `disableProtocol`, `enableProtocol`, and `configureCrossingConfig` can be called by the governance address without any checks for multi-signature or decentralized decision-making. This centralization poses a risk if the governance address is compromised, as it could lead to unauthorized changes to the protocol, including disabling it or changing critical parameters.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for governance functions to ensure that critical actions require multiple approvals. This would distribute control and reduce the risk of a single point of failure. Additionally, consider implementing time-lock mechanisms for governance actions to allow the community to react to potential malicious actions.
'''

**Lack of Decentralized Mechanisms for Critical Operations**
'''
The contract allows the governance address to make significant changes to the protocol without any community input or checks. For instance, the `configureSoul` function can be called to set parameters for a soul, which can significantly affect the staking mechanics and rewards distribution. This lack of checks can lead to potential abuse of power by the governance address.

**Recommended Mitigation/Fix:**
Introduce a proposal and voting mechanism where changes to critical parameters require community approval. This could be done through a decentralized autonomous organization (DAO) structure where token holders can vote on proposals, ensuring that changes reflect the community's interests rather than a single entity's decisions.
'''

[2024-11-08 11:17:59 INFO] **[Seminar Conclusion]**:

 ",,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `enabled` modifier, the comparison `require(protocolEnabled, ""EF"");` is a direct check of the boolean variable `protocolEnabled`. This is a valid use case, but it can be simplified by removing the explicit comparison to `true`. The line can be rewritten as `require(protocolEnabled, ""EF"");` without any change in functionality. This enhances readability and maintains clarity in the code.
'''
```

","<INFO> Inconsistent Initialization Identified.

1. **Inconsistent Initialization in `configureCrossingParameters`**
'''
In the `configureCrossingParameters` function, the `params.set` method is called, which relies on the state of the `soul` variable. If the `soul` variable has not been properly initialized before this function is called, it may lead to incorrect values being set for the crossing parameters. This could result in unexpected behavior during the migration process, as the crossing parameters may not reflect the intended configuration.

**Recommended Mitigation/Fix:** Ensure that the `soul` variable is initialized properly before calling the `configureCrossingParameters` function. This can be done by adding a check to confirm that the `soul` is in a valid state before proceeding with the configuration.
'''

2. **Inconsistent Initialization in `adjustSoul`**
'''
In the `adjustSoul` function, the `flashGoverner.enforceTolerance` method is called with the `soul.flanPerSecond` value. If the `soul` variable has not been initialized correctly, this could lead to the enforcement of tolerance on an uninitialized or incorrect value, potentially causing the function to behave unpredictably.

**Recommended Mitigation/Fix:** Add a check to ensure that the `soul` variable is initialized and in a valid state before calling the `enforceTolerance` method. This will help prevent any unintended consequences from using an uninitialized state variable.
'''

[2024-11-08 11:18:22 INFO] **[Seminar Conclusion]**:

 ",,,,,,"<INFO> Handling Partial Withdrawals Identified.
```
VULNERABILITY NAME: Handling Partial Withdrawals
'''
The contract does not adequately handle scenarios where only a partial amount can be withdrawn from the old strategy during migration. Specifically, in the `migrate` function, the assumption is made that the entire balance of the token can be transferred to the `morgothPower`. If the old strategy does not have sufficient funds to fulfill the `withdraw` call for the full amount, tokens could be left behind, leading to potential loss of funds or incomplete migration.

To mitigate this vulnerability, the contract should implement a check to ensure that the amount being withdrawn does not exceed the available balance. Additionally, it should handle cases where only a partial amount can be withdrawn, ensuring that all available funds are migrated properly. This could involve adjusting the migration logic to account for the actual balance available at the time of migration and potentially allowing for multiple migration attempts until all funds are successfully migrated.
'''
```

[2024-11-08 11:18:38 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Lack of Input Validation Identified.

**VULNERABILITY NAME: Unchecked User Input in Staking and Unstaking**
'''
The `stake` and `_unstake` functions do not validate the `amount` parameter to ensure it is greater than zero before proceeding with the staking or unstaking process. This could lead to unintended behavior if a user attempts to stake or unstake a zero amount, which could result in unnecessary state changes and potential manipulation of the contract's state.

**Recommended Mitigation/Fix:**
Add a check at the beginning of the `stake` and `_unstake` functions to ensure that the `amount` is greater than zero. For example:
```solidity
require(amount > 0, ""Amount must be greater than zero"");
```
'''

**VULNERABILITY NAME: Lack of Address Validation in Stake and Unstake Functions**
'''
In the `stake` function, the contract does not validate whether the `token` address is a valid ERC20 token before proceeding with the transfer. If an invalid address is provided, it could lead to unexpected behavior or loss of funds.

**Recommended Mitigation/Fix:**
Implement a check to ensure that the `token` address is not a zero address and that it conforms to the ERC20 interface. This can be done by checking the balance of the token or calling a function like `IERC20(token).totalSupply()` to confirm it is a valid token contract.

```solidity
require(token != address(0), ""Token address cannot be zero"");
require(IERC20(token).totalSupply() > 0, ""Invalid token address"");
```
'''

**VULNERABILITY NAME: Insufficient Validation on Crossing Parameters**
'''
In the `configureCrossingParameters` function, there is no validation on the `initialCrossingBonus`, `crossingBonusDelta`, or `crossingThreshold` parameters. If these values are set incorrectly (e.g., negative values or excessively high values), it could lead to unintended consequences during the migration process.

**Recommended Mitigation/Fix:**
Add checks to ensure that `initialCrossingBonus` is a positive integer and that `crossingThreshold` is greater than zero. For `crossingBonusDelta`, ensure it is within a reasonable range to prevent extreme fluctuations in rewards.

```solidity
require(initialCrossingBonus > 0, ""Initial crossing bonus must be positive"");
require(crossingThreshold > 0, ""Crossing threshold must be greater than zero"");
require(crossingBonusDelta >= -1000 && crossingBonusDelta <= 1000, ""Crossing bonus delta out of range"");
```
'''

**VULNERABILITY NAME: Lack of Validation on Migration Delay**
'''
In the `migrate` function, there is no validation to ensure

[2024-11-08 11:18:51 INFO] **[Seminar Conclusion]**:

 ",
,,"<INFO> Unchecked External Calls Identified.

```
UNCHECKED EXTERNAL CALLS
'''
In the `migrate` function, the contract calls `IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);` and `AngbandLike(crossingConfig.angband).

[2024-11-08 11:16:37 INFO] **[Execute Detail]**

execute SimplePhase:[UncheckedLowLevelCallDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:16:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all Unchecked Low-level Call vulnerabilities in the provided Solidity contract."". Ideas: ""Look for instances where low-level calls (such as call, delegatecall, send) are made without proper error handling or checks to ensure the calls succeed."". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Unchecked Low-level Calls. There are three cases, the contract may have Unchecked Low-level Calls: 1. When low-level calls (such as call, delegatecall, send) are not adequately checked, the calling contract may execute code in the external contract without ensuring the external contract's behavior is as expected. 2. When the external contract's code is not trusted or its behavior is unpredictable, it can compromise the overall security and stability of the calling contract. 3. When the execution of low-level function calls fails, the contract does not handle errors. The contract does not provide any mechanism to handle or revert the transaction, potentially resulting in a loss of funds. If you identify Unchecked Low-level Calls, please respond with: "" Unchecked Low-level Calls Identified."". For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Unchecked Low-level Calls."" |
| **phase_name** | UncheckedLowLevelCallDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Unchecked External Calls Identified.\n\n``\nUNCHECKED EXTERNAL CALLS\n'''\nIn themigratefunction, the contract callsIERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);andAngbandLike(crossingConfig.angband).""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:16:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:16:37 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all Unchecked Low-level Call vulnerabilities in the provided Solidity contract."".
Ideas: ""Look for instances where low-level calls (such as `call`, `delegatecall`, `send`) are made without proper error handling or checks to ensure the calls succeed."".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Unchecked Low-level Calls. There are three cases, the contract may have Unchecked Low-level Calls:
1. When low-level calls (such as `call`, `delegatecall`, `send`) are not adequately checked, the calling contract may execute code in the external contract without ensuring the external contract's behavior is as expected.
2. When the external contract's code is not trusted or its behavior is unpredictable, it can compromise the overall security and stability of the calling contract.
3. When the execution of low-level function calls fails, the contract does not handle errors. The contract does not provide any mechanism to handle or revert the transaction, potentially resulting in a loss of funds.
If you identify Unchecked Low-level Calls, please respond with: ""","<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `migrate` function, the contract makes a low-level call to the `power.parameterize` function without checking if the call succeeds. If the `parameterize` function fails, it could lead to unexpected behavior in the migration process, potentially resulting in a loss of tokens or funds.

Recommended Mitigation: Use the `require` statement to ensure that the low-level call succeeds. For example:
```
require(power.parameterize(token, crossingParams.burnable), ""Parameterization failed"");
```
This ensures that if the call fails, the transaction will revert, preventing any unintended consequences.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `migrate` function, after transferring tokens to the `morgothPower`, the contract calls `AngbandLike(crossingConfig.angband).executePower(...)` without checking if the call was successful. If this call fails, it could leave the contract in an inconsistent state.

Recommended Mitigation: Wrap the call in a `require` statement to ensure it succeeds:
```
require(AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower)), ""Execution of power failed"");
```
This will revert the transaction if the call fails, maintaining the integrity of the contract.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `claimSecondaryRewards` function, the contract calls `AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(...)` without checking if the call succeeds. If this function fails, it could result in unhandled funds or tokens being left in the contract.

Recommended Mitigation: Ensure that the call is checked for success:
```
require(AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender), ""Buying Flan and burning failed"");
```
This will ensure that any failure in this operation will revert the transaction and prevent loss of funds.
'''
```

[2024-11-08 11:16:43 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:16:43 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `migrate` function, the contract makes a low-level call to the `power.parameterize` function without checking if the call succeeds. If the `parameterize` function fails, it could lead to unexpected behavior in the migration process, potentially resulting in a loss of tokens or funds.\n\nRecommended Mitigation: Use the `require` statement to ensure that the low-level call succeeds. For example:\n\nrequire(power.parameterize(token, crossingParams.burnable), ""Parameterization failed"");\n\nThis ensures that if the call fails, the transaction will revert, preventing any unintended consequences.\n\'\'\'\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `migrate` function, after transferring tokens to the `morgothPower`, the contract calls `AngbandLike(crossingConfig.angband).executePower(...)` without checking if the call was successful. If this call fails, it could leave the contract in an inconsistent state.\n\nRecommended Mitigation: Wrap the call in a `require` statement to ensure it succeeds:\n\nrequire(AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower)), ""Execution of power failed"");\n\nThis will revert the transaction if the call fails, maintaining the integrity of the contract.\n\'\'\'\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `claimSecondaryRewards` function, the contract calls `AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(...)` without checking if the call succeeds. If this function fails, it could result in unhandled funds or tokens being left in the contract.\n\nRecommended Mitigation: Ensure that the call is checked for success:\n\nrequire(AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender), ""Buying Flan and burning failed"");\n\nThis will ensure that any failure in this operation will revert the transaction and prevent loss of funds.\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:16:43 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:16:43 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `migrate` function, the contract makes a low-level call to the `power.parameterize` function without checking if the call succeeds. If the `parameterize` function fails, it could lead to unexpected behavior in the migration process, potentially resulting in a loss of tokens or funds.

Recommended Mitigation: Use the `require` statement to ensure that the low-level call succeeds. For example:
```
require(power.parameterize(token, crossingParams.burnable), ""Parameterization failed"");
```
This ensures that if the call fails, the transaction will revert, preventing any unintended consequences.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `migrate` function, after transferring tokens to the `morgothPower`, the contract calls `AngbandLike(crossingConfig.angband).executePower(...)` without checking if the call was successful. If this call fails, it could leave the contract in an inconsistent state.

Recommended Mitigation: Wrap the call in a `require` statement to ensure it succeeds:
```
require(AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower)), ""Execution of power failed"");
```
This will revert the transaction if the call fails, maintaining the integrity of the contract.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `claimSecondaryRewards` function, the contract calls `AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(...)` without checking if the call succeeds. If this function fails, it could result in unhandled funds or tokens being left in the contract.

Recommended Mitigation: Ensure that the call is checked for success:
```
require(AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender), ""Buying Flan and burning failed"");
```
This will ensure that any failure in this operation will revert the transaction and prevent loss of funds.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: ""","<INFO> Transactions Order Dependence Identified.

VULNERABILITY NAME: Transactions Order Dependence in `migrate` Function
'''
In the `migrate` function, the order of operations is crucial. The function first transfers tokens to the `morgothPower` and then calls `AngbandLike(crossingConfig.angband).executePower(...)`. If a malicious actor can manipulate the transaction order, they could potentially execute their own transaction between these two calls, leading to unintended consequences such as incorrect token balances or failed migrations.

Recommended Mitigation: To prevent this vulnerability, consider implementing a reentrancy guard or using checks-effects-interactions pattern. This ensures that state changes are made before external calls, reducing the risk of transaction order manipulation.
'''

V

[2024-11-08 11:16:47 INFO] **[Execute Detail]**

execute SimplePhase:[TimeStampManipulationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:16:47 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Timestamp Manipulation. Timestamp Manipulation vulnerabilities can occur in the following cases: 1. When the contract relies on block timestamps (e.g., block.timestamp, now) for critical decisions, such as generating randomness or enforcing time-based conditions. 2. When the contract uses block timestamps to determine the outcome of random number generation, which can be manipulated by miners. 3. When the contract's logic depends on exact timestamps for time-based conditions like auction timing or lockup periods, allowing miners to manipulate the outcome. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where block timestamps are used for critical decisions.   Examine critical functions, particularly those involving randomness generation, timed conditions, and state changes based on timestamps, to ensure they have proper checks in place.   Verify that the contract minimizes reliance on block timestamps and uses alternative methods where possible to prevent manipulation.   If you identify Timestamp Manipulation, respond with: "" Timestamp Manipulation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Timestamp Manipulation."" |
| **phase_name** | TimeStampManipulationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Transactions Order Dependence Identified.\n\nVULNERABILITY NAME: Transactions Order Dependence in migrate Function\n'''\nIn the migrate function, the order of operations is crucial. The function first transfers tokens to the morgothPower and then calls AngbandLike(crossingConfig.angband).executePower(...). If a malicious actor can manipulate the transaction order, they could potentially execute their own transaction between these two calls, leading to unintended consequences such as incorrect token balances or failed migrations.\n\nRecommended Mitigation: To prevent this vulnerability, consider implementing a reentrancy guard or using checks-effects-interactions pattern. This ensures that state changes are made before external calls, reducing the risk of transaction order manipulation.\n'''\n\nV""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:16:47 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:16:47 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Transactions Order Dependence Identified.

VULNERABILITY NAME: Transactions Order Dependence in `migrate` Function
'''
In the `migrate` function, the order of operations is crucial. The function first transfers tokens to the `morgothPower` and then calls `AngbandLike(crossingConfig.angband).executePower(...)`. If a malicious actor can manipulate the transaction order, they could potentially execute their own transaction between these two calls, leading to unintended consequences such as incorrect token balances or failed migrations.

Recommended Mitigation: To prevent this vulnerability, consider implementing a reentrancy guard or using checks-effects-interactions pattern. This ensures that state changes are made before external calls, reducing the risk of transaction order manipulation.
'''

V"".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Timestamp Manipulation. Timestamp Manipulation vulnerabilities can occur in the following cases:
1. When the contract relies on block timestamps (e.g., block.timestamp, now) for critical decisions, such as generating randomness or enforcing time-based conditions.
2. When the contract uses block timestamps to determine the outcome of random number generation, which can be manipulated by miners.
3. When the contract's logic depends on exact timestamps for time-based conditions like auction timing or lockup periods, allowing miners to manipulate the outcome.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where block timestamps are used for critical decisions.

2. Examine critical functions, particularly those involving randomness generation, timed conditions, and state changes based on timestamps, to ensure they have proper checks in place.

3. Verify that the contract minimizes reliance on block timestamps and uses alternative methods where possible to prevent manipulation.

If you identify Timestamp Manipulation, respond with: ""","<INFO> Timestamp Manipulation Identified.
```
VULNERABILITY NAME: Timestamp Manipulation in `migrate` Function
'''
In the `migrate` function, the contract relies on the block timestamp to enforce a delay between the end of staking and the migration process. Specifically, it checks if the time elapsed since `stakingEndsTimestamp` is greater than `crossingConfig.crossingMigrationDelay`. This reliance on `block.timestamp` can be manipulated by miners, who can influence the timestamp of the block they mine. This could allow a malicious actor to manipulate the timing to their advantage, potentially allowing them to migrate tokens sooner than intended or to exploit the migration process.

Recommended Mitigation: To mitigate this vulnerability, consider using block numbers instead of timestamps for critical time-based conditions. Block numbers are less susceptible to manipulation as they are determined by the network consensus. Alternatively, if timestamps must be used, implement a mechanism that requires a minimum number of confirmations before allowing state changes based on timestamps, thus reducing the risk of manipulation.
'''
```

[2024-11-08 11:16:51 INFO] **[Execute Detail]**

execute SimplePhase:[PredictableRandDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:16:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Predictable Randomness. There are two cases, the code may have Predictable Randomness vulnerabilities: 1. Reliance on blockhash for randomness, which pertains to the flawed generation of random numbers within smart contracts. Random numbers often influence the decisions or outcomes of contract functionalities. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential exploitation. 2. Reliance on blocknumber for randomness, which will be used by attacker if he control the number of blocks mined in a given time frame. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential If you identify Reliance on blockhash for randomness, respond with: "" Predictable Randomness Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Predictable Randomness."" |
| **phase_name** | PredictableRandDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Timestamp Manipulation Identified.\n\nVULNERABILITY NAME: Timestamp Manipulation in `migrate` Function\n'''\nIn the `migrate` function, the contract relies on the block timestamp to enforce a delay between the end of staking and the migration process. Specifically, it checks if the time elapsed since `stakingEndsTimestamp` is greater than `crossingConfig.crossingMigrationDelay`. This reliance on `block.timestamp` can be manipulated by miners, who can influence the timestamp of the block they mine. This could allow a malicious actor to manipulate the timing to their advantage, potentially allowing them to migrate tokens sooner than intended or to exploit the migration process.\n\nRecommended Mitigation: To mitigate this vulnerability, consider using block numbers instead of timestamps for critical time-based conditions. Block numbers are less susceptible to manipulation as they are determined by the network consensus. Alternatively, if timestamps must be used, implement a mechanism that requires a minimum number of confirmations before allowing state changes based on timestamps, thus reducing the risk of manipulation.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:16:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:16:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Timestamp Manipulation Identified.
```
VULNERABILITY NAME: Timestamp Manipulation in `migrate` Function
'''
In the `migrate` function, the contract relies on the block timestamp to enforce a delay between the end of staking and the migration process. Specifically, it checks if the time elapsed since `stakingEndsTimestamp` is greater than `crossingConfig.crossingMigrationDelay`. This reliance on `block.timestamp` can be manipulated by miners, who can influence the timestamp of the block they mine. This could allow a malicious actor to manipulate the timing to their advantage, potentially allowing them to migrate tokens sooner than intended or to exploit the migration process.

Recommended Mitigation: To mitigate this vulnerability, consider using block numbers instead of timestamps for critical time-based conditions. Block numbers are less susceptible to manipulation as they are determined by the network consensus. Alternatively, if timestamps must be used, implement a mechanism that requires a minimum number of confirmations before allowing state changes based on timestamps, thus reducing the risk of manipulation.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Predictable Randomness. There are two cases, the code may have Predictable Randomness vulnerabilities:
1. Reliance on blockhash for randomness, which pertains to the flawed generation of random numbers within smart contracts. Random numbers often influence the decisions or outcomes of contract functionalities. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential exploitation.
2. Reliance on blocknumber for randomness, which will be used by attacker if he control the number of blocks mined in a given time frame. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential
If you identify Reliance on blockhash for randomness, respond with: """,,,,,"<INFO> Price Manipulation Identified.

**VULNERABILITY NAME: Centralized Price Control**
'''
The contract relies on a centralized authority (governance) to adjust critical parameters such as the crossing threshold and bonuses (ICB and CBD) without sufficient checks or balances. This can lead to scenarios where a malicious actor or a colluding group can manipulate the token prices by adjusting these parameters to favor their trades, leading to unfair advantages in the market.

**Recommended Mitigation/Fix:** Implement a decentralized oracle mechanism to provide price feeds for tokens. This would ensure that price adjustments are based on market data rather than centralized governance decisions. Additionally, introduce a multi-signature requirement for critical parameter changes to prevent unilateral control.
'''

**VULNERABILITY NAME: Lack of Price Transparency**
'''
The contract does not provide a transparent mechanism for determining the prices of tokens involved in the migration process. This lack of transparency can lead to exploitation by insiders who may have access to privileged information regarding token valuations or migration events.

**Recommended Mitigation/Fix:** Utilize a decentralized price oracle to fetch real-time prices for tokens involved in the migration process. This would ensure that all users have access to the same pricing information and reduce the risk of manipulation by insiders. Furthermore, consider implementing a time-lock mechanism for any price-related changes to allow the community to react to potential manipulations.
'''

[2024-11-08 11:17:05 INFO] **[Execute Detail]**

execute SimplePhase:[DataCorruptionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:17:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Assumption of Fixed-Length Array. There are two cases where the contract may have Assumption of Fixed-Length Array vulnerabilities: 1. When the contract incorrectly assumes that an array returned by a function has a fixed length, potentially leading to data corruption or out-of-bounds errors if the actual array length differs. 2. When the contract does not handle dynamic array lengths properly, causing incorrect data processing or logic errors. If you identify all Assumption of Fixed-Length Array vulnerabilities, respond with: "" Assumption of Fixed-Length Array Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code. ''' If you don't find any vulnerabilities, respond only with: "" No Assumption of Fixed-Length Array."" |
| **phase_name** | DataCorruptionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Price Manipulation Identified.\n\nVULNERABILITY NAME: Centralized Price Control\n'''\nThe contract relies on a centralized authority (governance) to adjust critical parameters such as the crossing threshold and bonuses (ICB and CBD) without sufficient checks or balances. This can lead to scenarios where a malicious actor or a colluding group can manipulate the token prices by adjusting these parameters to favor their trades, leading to unfair advantages in the market.\n\nRecommended Mitigation/Fix: Implement a decentralized oracle mechanism to provide price feeds for tokens. This would ensure that price adjustments are based on market data rather than centralized governance decisions. Additionally, introduce a multi-signature requirement for critical parameter changes to prevent unilateral control.\n'''\n\nVULNERABILITY NAME: Lack of Price Transparency\n'''\nThe contract does not provide a transparent mechanism for determining the prices of tokens involved in the migration process. This lack of transparency can lead to exploitation by insiders who may have access to privileged information regarding token valuations or migration events.\n\nRecommended Mitigation/Fix: Utilize a decentralized price oracle to fetch real-time prices for tokens involved in the migration process. This would ensure that all users have access to the same pricing information and reduce the risk of manipulation by insiders. Furthermore, consider implementing a time-lock mechanism for any price-related changes to allow the community to react to potential manipulations.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:17:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:17:05 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Price Manipulation Identified.

**VULNERABILITY NAME: Centralized Price Control**
'''
The contract relies on a centralized authority (governance) to adjust critical parameters such as the crossing threshold and bonuses (ICB and CBD) without sufficient checks or balances. This can lead to scenarios where a malicious actor or a colluding group can manipulate the token prices by adjusting these parameters to favor their trades, leading to unfair advantages in the market.

**Recommended Mitigation/Fix:** Implement a decentralized oracle mechanism to provide price feeds for tokens. This would ensure that price adjustments are based on market data rather than centralized governance decisions. Additionally, introduce a multi-signature requirement for critical parameter changes to prevent unilateral control.
'''

**VULNERABILITY NAME: Lack of Price Transparency**
'''
The contract does not provide a transparent mechanism for determining the prices of tokens involved in the migration process. This lack of transparency can lead to exploitation by insiders who may have access to privileged information regarding token valuations or migration events.

**Recommended Mitigation/Fix:** Utilize a decentralized price oracle to fetch real-time prices for tokens involved in the migration process. This would ensure that all users have access to the same pricing information and reduce the risk of manipulation by insiders. Furthermore, consider implementing a time-lock mechanism for any price-related changes to allow the community to react to potential manipulations.
'''"".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Assumption of Fixed-Length Array. There are two cases where the contract may have Assumption of Fixed-Length Array vulnerabilities:
1. When the contract incorrectly assumes that an array returned by a function has a fixed length, potentially leading to data corruption or out-of-bounds errors if the actual array length differs.
2. When the contract does not handle dynamic array lengths properly, causing incorrect data processing or logic errors.
If you identify all Assumption of Fixed-Length Array vulnerabilities, respond with: """,,"<INFO> Lack of Withdrawal Function Identified.
```

[2024-11-08 11:17:12 INFO] **[Execute Detail]**

execute SimplePhase:[LackAuthorizationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:17:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Lack of Authorization. This type of vulnerability occurs when functions are accessible to unauthorized users, leading to potential misuse and exploitation of contract functionalities. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify all functions that modify the state of the contract or perform sensitive operations. 2. Determine if each identified function has appropriate access control mechanisms, such as onlyOwner, onlyAdmin, or other custom modifiers that restrict access to authorized users only. 3. Look for any functions that do not have explicit access control modifiers and assess whether their unrestricted access could lead to unauthorized actions. 4. Evaluate the current access control setup for potential bypasses or weaknesses that could allow unauthorized users to call restricted functions. If you discover any Lack of Authorization vulnerabilities, respond with: "" Lack of Authorization Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Lack of Authorization vulnerabilities are found, respond only with: "" NO Lack of Authorization."" |
| **phase_name** | LackAuthorizationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' Lack of Withdrawal Function Identified.\n```'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:17:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:17:12 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Lack of Withdrawal Function Identified.
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Lack of Authorization. This type of vulnerability occurs when functions are accessible to unauthorized users, leading to potential misuse and exploitation of contract functionalities.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify all functions that modify the state of the contract or perform sensitive operations.
2. Determine if each identified function has appropriate access control mechanisms, such as `onlyOwner`, `onlyAdmin`, or other custom modifiers that restrict access to authorized users only.
3. Look for any functions that do not have explicit access control modifiers and assess whether their unrestricted access could lead to unauthorized actions.
4. Evaluate the current access control setup for potential bypasses or weaknesses that could allow unauthorized users to call restricted functions.
If you discover any Lack of Authorization vulnerabilities, respond with: ""","<INFO> Lack of Authorization Identified.
```
LACK OF AUTHORIZATION
'''
The contract has several functions that modify the state of the contract or perform sensitive operations without appropriate access control mechanisms. Specifically, the following functions are identified as lacking explicit access control:

1. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval modifier, the lack of a specific access control modifier (like `onlyOwner` or `onlyAdmin`) could lead to misuse if governance is compromised.

2. `enableProtocol()`: Similar to `disableProtocol`, this function can be called by anyone who has passed a governance proposal, which may not adequately restrict access.

3. `configureCrossingConfig()`: This function allows configuration of global migration settings but is only protected by `onlySuccessfulProposal`, which may not sufficiently restrict access to unauthorized users.

4. `adjustSoul()`, `configureSoul()`, and `configureCrossingParameters()`: These functions allow for significant changes to the state of souls and crossing parameters but rely on governance approval without additional access control.

To mitigate these vulnerabilities, it is recommended to implement explicit access control modifiers for sensitive functions. For example, adding `onlyOwner` or `onlyAdmin` modifiers to functions that should only be callable by authorized personnel can help prevent unauthorized access. Additionally, consider implementing a role-based access control system to further restrict access based on user roles within the governance structure.
'''
```

[2024-11-08 11:17:18 INFO] **[Execute Detail]**

execute SimplePhase:[DataInconsistencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:17:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data. 2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly. 3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data. 4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data. If you discover any Potential Data Inconsistency vulnerabilities, respond with: "" Potential Data Inconsistency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Potential Data Inconsistency vulnerabilities are found, respond only with: "" NO Potential Data Inconsistency."" |
| **phase_name** | DataInconsistencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Lack of Authorization Identified.\n\nLACK OF AUTHORIZATION\n'''\nThe contract has several functions that modify the state of the contract or perform sensitive operations without appropriate access control mechanisms. Specifically, the following functions are identified as lacking explicit access control:\n\n1. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval modifier, the lack of a specific access control modifier (like `onlyOwner` or `onlyAdmin`) could lead to misuse if governance is compromised.\n\n2. `enableProtocol()`: Similar to `disableProtocol`, this function can be called by anyone who has passed a governance proposal, which may not adequately restrict access.\n\n3. `configureCrossingConfig()`: This function allows configuration of global migration settings but is only protected by `onlySuccessfulProposal`, which may not sufficiently restrict access to unauthorized users.\n\n4. `adjustSoul()`, `configureSoul()`, and `configureCrossingParameters()`: These functions allow for significant changes to the state of souls and crossing parameters but rely on governance approval without additional access control.\n\nTo mitigate these vulnerabilities, it is recommended to implement explicit access control modifiers for sensitive functions. For example, adding `onlyOwner` or `onlyAdmin` modifiers to functions that should only be callable by authorized personnel can help prevent unauthorized access. Additionally, consider implementing a role-based access control system to further restrict access based on user roles within the governance structure.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:17:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:17:18 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Lack of Authorization Identified.
```
LACK OF AUTHORIZATION
'''
The contract has several functions that modify the state of the contract or perform sensitive operations without appropriate access control mechanisms. Specifically, the following functions are identified as lacking explicit access control:

1. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval modifier, the lack of a specific access control modifier (like `onlyOwner` or `onlyAdmin`) could lead to misuse if governance is compromised.

2. `enableProtocol()`: Similar to `disableProtocol`, this function can be called by anyone who has passed a governance proposal, which may not adequately restrict access.

3. `configureCrossingConfig()`: This function allows configuration of global migration settings but is only protected by `onlySuccessfulProposal`, which may not sufficiently restrict access to unauthorized users.

4. `adjustSoul()`, `configureSoul()`, and `configureCrossingParameters()`: These functions allow for significant changes to the state of souls and crossing parameters but rely on governance approval without additional access control.

To mitigate these vulnerabilities, it is recommended to implement explicit access control modifiers for sensitive functions. For example, adding `onlyOwner` or `onlyAdmin` modifiers to functions that should only be callable by authorized personnel can help prevent unauthorized access. Additionally, consider implementing a role-based access control system to further restrict access based on user roles within the governance structure.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data.
2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly.
3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data.
4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data.
If you discover any Potential Data Inconsistency vulnerabilities, respond with: ""","<INFO> Potential Data Inconsistency Identified.
```
POTENTIAL DATA INCONSISTENCY
'''
The contract has several areas where data manipulation could lead to inconsistencies, particularly in the handling of user information and soul states. 

1. **User Data Updates**: In the `stake` function, the userâ€™s `stakedAmount` is updated based on the difference between the new balance and the old balance. However, if the token transfer fails or if there are discrepancies in the fee-on-transfer (FOT) tokens, the `stakedAmount` may not accurately reflect the actual amount staked. This could lead to inconsistencies in the user's reward calculations.

   **Mitigation**: Implement checks to ensure that the `oldBalance` and `newBalance` are consistent before updating `user.stakedAmount`. If the transfer fails or the balances do not match expected values, revert the transaction.

2. **Pending Rewards Calculation**: The `getPending` function calculates pending rewards based on the `accumulatedFlanPerShare` and `rewardDebt`. If the `accumulatedFlanPerShare` is not updated correctly in the

[2024-11-08 11:17:23 INFO] **[Execute Detail]**

execute SimplePhase:[HashCollisionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:17:23 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any functions that generate hashes from input values. 2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of abi.encodePacked for concatenation. 3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions. 4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized. If you discover any Hash Collision vulnerabilities, respond with: "" Hash Collision Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Hash Collision vulnerabilities are found, respond only with: "" NO Hash Collision."" |
| **phase_name** | HashCollisionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Potential Data Inconsistency Identified.\n``\nPOTENTIAL DATA INCONSISTENCY\n'''\nThe contract has several areas where data manipulation could lead to inconsistencies, particularly in the handling of user information and soul states. \n\n1. **User Data Updates**: In thestakefunction, the userâ€™sstakedAmountis updated based on the difference between the new balance and the old balance. However, if the token transfer fails or if there are discrepancies in the fee-on-transfer (FOT) tokens, thestakedAmountmay not accurately reflect the actual amount staked. This could lead to inconsistencies in the user's reward calculations.\n\n   **Mitigation**: Implement checks to ensure that theoldBalanceandnewBalanceare consistent before updatinguser.stakedAmount. If the transfer fails or the balances do not match expected values, revert the transaction.\n\n2. **Pending Rewards Calculation**: ThegetPendingfunction calculates pending rewards based on theaccumulatedFlanPerShareandrewardDebt. If theaccumulatedFlanPerShare` is not updated correctly in the""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:17:23 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:17:23 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Potential Data Inconsistency Identified.
```
POTENTIAL DATA INCONSISTENCY
'''
The contract has several areas where data manipulation could lead to inconsistencies, particularly in the handling of user information and soul states. 

1. **User Data Updates**: In the `stake` function, the userâ€™s `stakedAmount` is updated based on the difference between the new balance and the old balance. However, if the token transfer fails or if there are discrepancies in the fee-on-transfer (FOT) tokens, the `stakedAmount` may not accurately reflect the actual amount staked. This could lead to inconsistencies in the user's reward calculations.

   **Mitigation**: Implement checks to ensure that the `oldBalance` and `newBalance` are consistent before updating `user.stakedAmount`. If the transfer fails or the balances do not match expected values, revert the transaction.

2. **Pending Rewards Calculation**: The `getPending` function calculates pending rewards based on the `accumulatedFlanPerShare` and `rewardDebt`. If the `accumulatedFlanPerShare` is not updated correctly in the"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any functions that generate hashes from input values.
2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of `abi.encodePacked` for concatenation.
3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions.
4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized.
If you discover any Hash Collision vulnerabilities, respond with: """,,,,"<INFO> Missing 'onlyOwner' Modifier Identified.

```
MISSING 'onlyOwner' MODIFIER
'''
The contract has several functions that can be executed without any access control, which may lead to unauthorized actions. Specifically, the following functions lack the 'onlyOwner' modifier or equivalent access control:

1. `configureCrossingConfig(...)`: This function allows the configuration of critical migration settings, including the address of the Behodler and the minimum delay between end of staking and migration. If an unauthorized user calls this function, they could change important parameters that could affect the entire protocol.

2. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval mechanism, it still poses a risk if the governance process is compromised or if malicious actors gain control over governance.

3. `enableProtocol()`: Similar to `disableProtocol`, this function allows the protocol to be re-enabled only through a formal proposal. However, without proper access control, it could be exploited.

4. `adjustSoul(...)`: This function allows rapid calibration of a soul, which can be critical for responding to market changes. If misused, it could lead to significant financial losses for users.

To mitigate these vulnerabilities, it is recommended to implement the 'onlyOwner' modifier or an equivalent access control mechanism on these functions to ensure that only authorized users (e.g., the contract owner or designated governance roles) can execute them. This will help prevent unauthorized access and potential exploitation of the contract.
'''
```

[2024-11-08 11:17:35 INFO] **[Execute Detail]**

execute SimplePhase:[MisuseMsgValueDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:17:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Misuse of msg.value within a Loop. There are key indicators of this vulnerability: 1. Incorrectly allocating the total msg.value to each item within a loop, rather than dividing msg.value properly among the items. 2. Misallocation of funds where each iteration of the loop assigns the entire msg.value instead of the correct portion, leading to an unintended and excessive distribution. If you identify Misuse of msg.value within a Loop, respond with: "" Misuse of msg.value within a Loop Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Misuse of msg.value within a Loop."" |
| **phase_name** | MisuseMsgValueDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Missing 'onlyOwner' Modifier Identified.\n\n\nMISSING 'onlyOwner' MODIFIER\n'''\nThe contract has several functions that can be executed without any access control, which may lead to unauthorized actions. Specifically, the following functions lack the 'onlyOwner' modifier or equivalent access control:\n\n1. `configureCrossingConfig(...)`: This function allows the configuration of critical migration settings, including the address of the Behodler and the minimum delay between end of staking and migration. If an unauthorized user calls this function, they could change important parameters that could affect the entire protocol.\n\n2. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval mechanism, it still poses a risk if the governance process is compromised or if malicious actors gain control over governance.\n\n3. `enableProtocol()`: Similar to `disableProtocol`, this function allows the protocol to be re-enabled only through a formal proposal. However, without proper access control, it could be exploited.\n\n4. `adjustSoul(...)`: This function allows rapid calibration of a soul, which can be critical for responding to market changes. If misused, it could lead to significant financial losses for users.\n\nTo mitigate these vulnerabilities, it is recommended to implement the 'onlyOwner' modifier or an equivalent access control mechanism on these functions to ensure that only authorized users (e.g., the contract owner or designated governance roles) can execute them. This will help prevent unauthorized access and potential exploitation of the contract.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:17:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:17:35 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Missing 'onlyOwner' Modifier Identified.

```
MISSING 'onlyOwner' MODIFIER
'''
The contract has several functions that can be executed without any access control, which may lead to unauthorized actions. Specifically, the following functions lack the 'onlyOwner' modifier or equivalent access control:

1. `configureCrossingConfig(...)`: This function allows the configuration of critical migration settings, including the address of the Behodler and the minimum delay between end of staking and migration. If an unauthorized user calls this function, they could change important parameters that could affect the entire protocol.

2. `disableProtocol()`: This function allows anyone with sufficient EYE balance to disable the protocol instantly. While it is governed by a governance approval mechanism, it still poses a risk if the governance process is compromised or if malicious actors gain control over governance.

3. `enableProtocol()`: Similar to `disableProtocol`, this function allows the protocol to be re-enabled only through a formal proposal. However, without proper access control, it could be exploited.

4. `adjustSoul(...)`: This function allows rapid calibration of a soul, which can be critical for responding to market changes. If misused, it could lead to significant financial losses for users.

To mitigate these vulnerabilities, it is recommended to implement the 'onlyOwner' modifier or an equivalent access control mechanism on these functions to ensure that only authorized users (e.g., the contract owner or designated governance roles) can execute them. This will help prevent unauthorized access and potential exploitation of the contract.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Misuse of `msg.value` within a Loop. There are key indicators of this vulnerability:
1. Incorrectly allocating the total `msg.value` to each item within a loop, rather than dividing `msg.value` properly among the items.
2. Misallocation of funds where each iteration of the loop assigns the entire `msg.value` instead of the correct portion, leading to an unintended and excessive distribution.
If you identify Misuse of `msg.value` within a Loop, respond with: """,,,"<INFO> Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `claimBonus` function, the following check is performed:

    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

This check is redundant because the state of the soul is already being validated in the `migrate` function, which ensures that the soul is in a valid state before any migration occurs. Therefore, if the `claimBonus` function is called, it can be assumed that the state has already been validated, making this check unnecessary.

To mitigate this, you can remove the redundant conditional check from the `claimBonus` function to reduce gas costs and simplify the code.
'''
```

[2024-11-08 11:17:48 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Centralization Risk Identified.

**Centralized Control through Governance Functions**
'''
The contract has several governance functions that can be executed by a single address (the governance address). For example, functions like `disableProtocol`, `enableProtocol`, and `configureCrossingConfig` can be called by the governance address without any checks for multi-signature or decentralized decision-making. This centralization poses a risk if the governance address is compromised, as it could lead to unauthorized changes to the protocol, including disabling it or changing critical parameters.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for governance functions to ensure that critical actions require multiple approvals. This would distribute control and reduce the risk of a single point of failure. Additionally, consider implementing time-lock mechanisms for governance actions to allow the community to react to potential malicious actions.
'''

**Lack of Decentralized Mechanisms for Critical Operations**
'''
The contract allows the governance address to make significant changes to the protocol without any community input or checks. For instance, the `configureSoul` function can be called to set parameters for a soul, which can significantly affect the staking mechanics and rewards distribution. This lack of checks can lead to potential abuse of power by the governance address.

**Recommended Mitigation/Fix:**
Introduce a proposal and voting mechanism where changes to critical parameters require community approval. This could be done through a decentralized autonomous organization (DAO) structure where token holders can vote on proposals, ensuring that changes reflect the community's interests rather than a single entity's decisions.
'''

[2024-11-08 11:17:59 INFO] **[Execute Detail]**

execute SimplePhase:[FundingCalculationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:17:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities: 1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation. 2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation. If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: "" Incorrect Funding Rate Calculation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Incorrect Funding Rate Calculation."" |
| **phase_name** | FundingCalculationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Centralization Risk Identified.\n\nCentralized Control through Governance Functions\n'''\nThe contract has several governance functions that can be executed by a single address (the governance address). For example, functions like disableProtocol, enableProtocol, and configureCrossingConfig can be called by the governance address without any checks for multi-signature or decentralized decision-making. This centralization poses a risk if the governance address is compromised, as it could lead to unauthorized changes to the protocol, including disabling it or changing critical parameters.\n\nRecommended Mitigation/Fix:\nImplement a multi-signature wallet for governance functions to ensure that critical actions require multiple approvals. This would distribute control and reduce the risk of a single point of failure. Additionally, consider implementing time-lock mechanisms for governance actions to allow the community to react to potential malicious actions.\n'''\n\nLack of Decentralized Mechanisms for Critical Operations\n'''\nThe contract allows the governance address to make significant changes to the protocol without any community input or checks. For instance, the configureSoul function can be called to set parameters for a soul, which can significantly affect the staking mechanics and rewards distribution. This lack of checks can lead to potential abuse of power by the governance address.\n\nRecommended Mitigation/Fix:\nIntroduce a proposal and voting mechanism where changes to critical parameters require community approval. This could be done through a decentralized autonomous organization (DAO) structure where token holders can vote on proposals, ensuring that changes reflect the community's interests rather than a single entity's decisions.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:17:59 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:17:59 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Centralization Risk Identified.

**Centralized Control through Governance Functions**
'''
The contract has several governance functions that can be executed by a single address (the governance address). For example, functions like `disableProtocol`, `enableProtocol`, and `configureCrossingConfig` can be called by the governance address without any checks for multi-signature or decentralized decision-making. This centralization poses a risk if the governance address is compromised, as it could lead to unauthorized changes to the protocol, including disabling it or changing critical parameters.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for governance functions to ensure that critical actions require multiple approvals. This would distribute control and reduce the risk of a single point of failure. Additionally, consider implementing time-lock mechanisms for governance actions to allow the community to react to potential malicious actions.
'''

**Lack of Decentralized Mechanisms for Critical Operations**
'''
The contract allows the governance address to make significant changes to the protocol without any community input or checks. For instance, the `configureSoul` function can be called to set parameters for a soul, which can significantly affect the staking mechanics and rewards distribution. This lack of checks can lead to potential abuse of power by the governance address.

**Recommended Mitigation/Fix:**
Introduce a proposal and voting mechanism where changes to critical parameters require community approval. This could be done through a decentralized autonomous organization (DAO) structure where token holders can vote on proposals, ensuring that changes reflect the community's interests rather than a single entity's decisions.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities:
1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation.
2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation.
If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: """,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `attemptToTargetAPY` function, the line `require(soul.soulType == SoulType.threshold, ""EI"");` checks if `soul.soulType` is equal to `SoulType.threshold`. This is a necessary comparison, but if the intention is to ensure that the soul type is not `SoulType.uninitialized`, it could be more readable to check directly against the valid types without the explicit comparison. However, this specific comparison is necessary for the logic of the contract.
'''
```

","<INFO> Inconsistent Initialization Identified.

1. **Inconsistent Initialization in `configureCrossingParameters`**
'''
In the `configureCrossingParameters` function, the `params.set` method is called, which relies on the state of the `soul` variable. If the `soul` variable has not been properly initialized before this function is called, it may lead to incorrect values being set for the crossing parameters. This could result in unexpected behavior during the migration process, as the crossing parameters may not reflect the intended configuration.

**Recommended Mitigation/Fix:** Ensure that the `soul` variable is initialized properly before calling the `configureCrossingParameters` function. This can be done by adding a check to confirm that the `soul` is in a valid state before proceeding with the configuration.
'''

2. **Inconsistent Initialization in `adjustSoul`**
'''
In the `adjustSoul` function, the `flashGoverner.enforceTolerance` method is called with the `soul.flanPerSecond` value. If the `soul` variable has not been initialized correctly, this could lead to the enforcement of tolerance on an uninitialized or incorrect value, potentially causing the function to behave unpredictably.

**Recommended Mitigation/Fix:** Add a check to ensure that the `soul` variable is initialized and in a valid state before calling the `enforceTolerance` method. This will help prevent any unintended consequences from using an uninitialized state variable.
'''

[2024-11-08 11:18:22 INFO] **[Execute Detail]**

execute SimplePhase:[SourceSwappingDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:18:22 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Inconsistency in Yield Source Swapping. This type of vulnerability arises when a function allows the swapping of yield sources without ensuring that the deposit token of the new yield source matches the current one, which can lead to inconsistencies and potential issues in the contract's operations. There is one primary case where the code may have Potential Inconsistency in Yield Source Swapping vulnerabilities: 1. A function that allows the owner to swap the current yield source with a new one without verifying that the deposit token of the new yield source is the same as the current one. This can lead to inconsistencies and operational issues if the deposit tokens are different. If you identify Potential Inconsistency in Yield Source Swapping, respond with: "" Potential Inconsistency in Yield Source Swapping Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Potential Inconsistency in Yield Source Swapping."" |
| **phase_name** | SourceSwappingDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Inconsistent Initialization Identified.\n\n1. Inconsistent Initialization in configureCrossingParameters\n'''\nIn the configureCrossingParameters function, the params.set method is called, which relies on the state of the soul variable. If the soul variable has not been properly initialized before this function is called, it may lead to incorrect values being set for the crossing parameters. This could result in unexpected behavior during the migration process, as the crossing parameters may not reflect the intended configuration.\n\nRecommended Mitigation/Fix: Ensure that the soul variable is initialized properly before calling the configureCrossingParameters function. This can be done by adding a check to confirm that the soul is in a valid state before proceeding with the configuration.\n'''\n\n2. Inconsistent Initialization in adjustSoul\n'''\nIn the adjustSoul function, the flashGoverner.enforceTolerance method is called with the soul.flanPerSecond value. If the soul variable has not been initialized correctly, this could lead to the enforcement of tolerance on an uninitialized or incorrect value, potentially causing the function to behave unpredictably.\n\nRecommended Mitigation/Fix: Add a check to ensure that the soul variable is initialized and in a valid state before calling the enforceTolerance method. This will help prevent any unintended consequences from using an uninitialized state variable.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:18:22 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:18:22 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Inconsistent Initialization Identified.

1. **Inconsistent Initialization in `configureCrossingParameters`**
'''
In the `configureCrossingParameters` function, the `params.set` method is called, which relies on the state of the `soul` variable. If the `soul` variable has not been properly initialized before this function is called, it may lead to incorrect values being set for the crossing parameters. This could result in unexpected behavior during the migration process, as the crossing parameters may not reflect the intended configuration.

**Recommended Mitigation/Fix:** Ensure that the `soul` variable is initialized properly before calling the `configureCrossingParameters` function. This can be done by adding a check to confirm that the `soul` is in a valid state before proceeding with the configuration.
'''

2. **Inconsistent Initialization in `adjustSoul`**
'''
In the `adjustSoul` function, the `flashGoverner.enforceTolerance` method is called with the `soul.flanPerSecond` value. If the `soul` variable has not been initialized correctly, this could lead to the enforcement of tolerance on an uninitialized or incorrect value, potentially causing the function to behave unpredictably.

**Recommended Mitigation/Fix:** Add a check to ensure that the `soul` variable is initialized and in a valid state before calling the `enforceTolerance` method. This will help prevent any unintended consequences from using an uninitialized state variable.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Inconsistency in Yield Source Swapping. This type of vulnerability arises when a function allows the swapping of yield sources without ensuring that the deposit token of the new yield source matches the current one, which can lead to inconsistencies and potential issues in the contract's operations.
There is one primary case where the code may have Potential Inconsistency in Yield Source Swapping vulnerabilities:
1. A function that allows the owner to swap the current yield source with a new one without verifying that the deposit token of the new yield source is the same as the current one. This can lead to inconsistencies and operational issues if the deposit tokens are different.
If you identify Potential Inconsistency in Yield Source Swapping, respond with: """,,,,,,"<INFO> Handling Partial Withdrawals Identified.
```
VULNERABILITY NAME: Handling Partial Withdrawals
'''
The contract does not adequately handle scenarios where only a partial amount can be withdrawn from the old strategy during migration. Specifically, in the `migrate` function, the assumption is made that the entire balance of the token can be transferred to the `morgothPower`. If the old strategy does not have sufficient funds to fulfill the `withdraw` call for the full amount, tokens could be left behind, leading to potential loss of funds or incomplete migration.

To mitigate this vulnerability, the contract should implement a check to ensure that the amount being withdrawn does not exceed the available balance. Additionally, it should handle cases where only a partial amount can be withdrawn, ensuring that all available funds are migrated properly. This could involve adjusting the migration logic to account for the actual balance available at the time of migration and potentially allowing for multiple migration attempts until all funds are successfully migrated.
'''
```

[2024-11-08 11:18:38 INFO] **[Execute Detail]**

execute SimplePhase:[FallbackFunctionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:18:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the absence of a Fallback Function. There are two primary cases where the code may have Fallback Function vulnerabilities: 1. Contracts that do not define a fallback function, which could lead to accidental loss of ether sent to the contract, as the contract will reject ether transfers if there is no payable fallback function. 2. Contracts that require handling unexpected ether transfers, but lack a mechanism to do so, potentially causing ether to be locked in the contract or the transaction to revert. If you identify any No Fallback Function vulnerabilities, respond with: "" Fallback Function Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO No Fallback Function."" |
| **phase_name** | FallbackFunctionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': "" Handling Partial Withdrawals Identified.\n\nVULNERABILITY NAME: Handling Partial Withdrawals\n'''\nThe contract does not adequately handle scenarios where only a partial amount can be withdrawn from the old strategy during migration. Specifically, in the `migrate` function, the assumption is made that the entire balance of the token can be transferred to the `morgothPower`. If the old strategy does not have sufficient funds to fulfill the `withdraw` call for the full amount, tokens could be left behind, leading to potential loss of funds or incomplete migration.\n\nTo mitigate this vulnerability, the contract should implement a check to ensure that the amount being withdrawn does not exceed the available balance. Additionally, it should handle cases where only a partial amount can be withdrawn, ensuring that all available funds are migrated properly. This could involve adjusting the migration logic to account for the actual balance available at the time of migration and potentially allowing for multiple migration attempts until all funds are successfully migrated.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:18:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:18:38 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Handling Partial Withdrawals Identified.
```
VULNERABILITY NAME: Handling Partial Withdrawals
'''
The contract does not adequately handle scenarios where only a partial amount can be withdrawn from the old strategy during migration. Specifically, in the `migrate` function, the assumption is made that the entire balance of the token can be transferred to the `morgothPower`. If the old strategy does not have sufficient funds to fulfill the `withdraw` call for the full amount, tokens could be left behind, leading to potential loss of funds or incomplete migration.

To mitigate this vulnerability, the contract should implement a check to ensure that the amount being withdrawn does not exceed the available balance. Additionally, it should handle cases where only a partial amount can be withdrawn, ensuring that all available funds are migrated properly. This could involve adjusting the migration logic to account for the actual balance available at the time of migration and potentially allowing for multiple migration attempts until all funds are successfully migrated.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the absence of a Fallback Function. There are two primary cases where the code may have Fallback Function vulnerabilities:
1. Contracts that do not define a fallback function, which could lead to accidental loss of ether sent to the contract, as the contract will reject ether transfers if there is no payable fallback function.
2. Contracts that require handling unexpected ether transfers, but lack a mechanism to do so, potentially causing ether to be locked in the contract or the transaction to revert.
If you identify any No Fallback Function vulnerabilities, respond with: """,,,"<INFO> Lack of Input Validation Identified.

**VULNERABILITY NAME: Unchecked User Input in Staking and Unstaking**
'''
The `stake` and `_unstake` functions do not validate the `amount` parameter to ensure it is greater than zero before proceeding with the staking or unstaking process. This could lead to unintended behavior if a user attempts to stake or unstake a zero amount, which could result in unnecessary state changes and potential manipulation of the contract's state.

**Recommended Mitigation/Fix:**
Add a check at the beginning of the `stake` and `_unstake` functions to ensure that the `amount` is greater than zero. For example:
```solidity
require(amount > 0, ""Amount must be greater than zero"");
```
'''

**VULNERABILITY NAME: Lack of Address Validation in Stake and Unstake Functions**
'''
In the `stake` function, the contract does not validate whether the `token` address is a valid ERC20 token before proceeding with the transfer. If an invalid address is provided, it could lead to unexpected behavior or loss of funds.

**Recommended Mitigation/Fix:**
Implement a check to ensure that the `token` address is not a zero address and that it conforms to the ERC20 interface. This can be done by checking the balance of the token or calling a function like `IERC20(token).totalSupply()` to confirm it is a valid token contract.

```solidity
require(token != address(0), ""Token address cannot be zero"");
require(IERC20(token).totalSupply() > 0, ""Invalid token address"");
```
'''

**VULNERABILITY NAME: Insufficient Validation on Crossing Parameters**
'''
In the `configureCrossingParameters` function, there is no validation on the `initialCrossingBonus`, `crossingBonusDelta`, or `crossingThreshold` parameters. If these values are set incorrectly (e.g., negative values or excessively high values), it could lead to unintended consequences during the migration process.

**Recommended Mitigation/Fix:**
Add checks to ensure that `initialCrossingBonus` is a positive integer and that `crossingThreshold` is greater than zero. For `crossingBonusDelta`, ensure it is within a reasonable range to prevent extreme fluctuations in rewards.

```solidity
require(initialCrossingBonus > 0, ""Initial crossing bonus must be positive"");
require(crossingThreshold > 0, ""Crossing threshold must be greater than zero"");
require(crossingBonusDelta >= -1000 && crossingBonusDelta <= 1000, ""Crossing bonus delta out of range"");
```
'''

**VULNERABILITY NAME: Lack of Validation on Migration Delay**
'''
In the `migrate` function, there is no validation to ensure

[2024-11-08 11:18:51 INFO] **[Execute Detail]**

execute SimplePhase:[DoSDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:18:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."". Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases: 1. When loops have an unbounded iteration count, leading to potential gas exhaustion. 2. When the contract makes external calls that can fail or consume excessive gas. 3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures. 4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion. 2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures. 3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS. 4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics. If you identify any DoS vulnerabilities, respond with: "" DoS Vulnerability Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades. ''' If you don't find any vulnerabilities, respond only with: "" No DoS Vulnerabilities."" |
| **phase_name** | DoSDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' Lack of Input Validation Identified.\n\nVULNERABILITY NAME: Unchecked User Input in Staking and Unstaking\n\'\'\'\nThe stake and _unstake functions do not validate the amount parameter to ensure it is greater than zero before proceeding with the staking or unstaking process. This could lead to unintended behavior if a user attempts to stake or unstake a zero amount, which could result in unnecessary state changes and potential manipulation of the contract\'s state.\n\nRecommended Mitigation/Fix:\nAdd a check at the beginning of the stake and _unstake functions to ensure that the amount is greater than zero. For example:\nsolidity\nrequire(amount &gt; 0, ""Amount must be greater than zero"");\n\n\'\'\'\n\nVULNERABILITY NAME: Lack of Address Validation in Stake and Unstake Functions\n\'\'\'\nIn the stake function, the contract does not validate whether the token address is a valid ERC20 token before proceeding with the transfer. If an invalid address is provided, it could lead to unexpected behavior or loss of funds.\n\nRecommended Mitigation/Fix:\nImplement a check to ensure that the token address is not a zero address and that it conforms to the ERC20 interface. This can be done by checking the balance of the token or calling a function like IERC20(token).totalSupply() to confirm it is a valid token contract.\n\nsolidity\nrequire(token != address(0), ""Token address cannot be zero"");\nrequire(IERC20(token).totalSupply() &gt; 0, ""Invalid token address"");\n\n\'\'\'\n\nVULNERABILITY NAME: Insufficient Validation on Crossing Parameters\n\'\'\'\nIn the configureCrossingParameters function, there is no validation on the initialCrossingBonus, crossingBonusDelta, or crossingThreshold parameters. If these values are set incorrectly (e.g., negative values or excessively high values), it could lead to unintended consequences during the migration process.\n\nRecommended Mitigation/Fix:\nAdd checks to ensure that initialCrossingBonus is a positive integer and that crossingThreshold is greater than zero. For crossingBonusDelta, ensure it is within a reasonable range to prevent extreme fluctuations in rewards.\n\nsolidity\nrequire(initialCrossingBonus &gt; 0, ""Initial crossing bonus must be positive"");\nrequire(crossingThreshold &gt; 0, ""Crossing threshold must be greater than zero"");\nrequire(crossingBonusDelta &gt;= -1000 &amp;&amp; crossingBonusDelta &lt;= 1000, ""Crossing bonus delta out of range"");\n\n\'\'\'\n\nVULNERABILITY NAME: Lack of Validation on Migration Delay\n\'\'\'\nIn the migrate function, there is no validation to ensure'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:18:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:18:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."".
Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases:
1. When loops have an unbounded iteration count, leading to potential gas exhaustion.
2. When the contract makes external calls that can fail or consume excessive gas.
3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures.
4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion.
2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures.
3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS.
4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics.
If you identify any DoS vulnerabilities, respond with: """,
,,,,,,,,,,,,,,,,,,,,,"<INFO> Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `unstake` function, the following check is performed:

    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");

This check is redundant because the `soul` state is already being validated in the `stake` function, which ensures that the soul is in a valid state before any staking occurs. Therefore, if the `unstake` function is called, it can be assumed that the state has already been validated, making this check unnecessary.

To mitigate this, you can remove the redundant conditional check from the `unstake` function to reduce gas costs and simplify the code.
'''
```

",,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `claimBonus` function, the line `require(finalFlanPerTeraToken > 0, ""ED"");` checks if `finalFlanPerTeraToken` is greater than zero. This is a necessary comparison to ensure that the bonus is positive before proceeding. However, if the logic allows for negative values to be handled differently, this comparison could be adjusted to reflect that logic more clearly.
'''
``` 

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,"<INFO> Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `claimBonus` function, the following check is performed:

    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

This check is redundant because the state of the soul is already being validated in the `migrate` function, which ensures that the soul is in a valid state before any migration occurs. Therefore, if the `claimBonus` function is called, it can be assumed that the state has already been validated, making this check unnecessary.

To mitigate this, you can remove the redundant conditional check from the `claimBonus` function to reduce gas costs and simplify the code.
'''
```

[2024-11-08 11:17:48 INFO] **[Execute Detail]**

execute SimplePhase:[OracleDependencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:17:48 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities: 1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected. 2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations. If you identify reliance on a single external oracle for critical data, respond with: "" External Oracle Dependency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO External Oracle Dependency."" |
| **phase_name** | OracleDependencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' Redundant Conditional Check Identified.\n\nREDUNDANT CONDITIONAL CHECK\n\'\'\'\nIn the `claimBonus` function, the following check is performed:\n\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\nThis check is redundant because the state of the soul is already being validated in the `migrate` function, which ensures that the soul is in a valid state before any migration occurs. Therefore, if the `claimBonus` function is called, it can be assumed that the state has already been validated, making this check unnecessary.\n\nTo mitigate this, you can remove the redundant conditional check from the `claimBonus` function to reduce gas costs and simplify the code.\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:17:48 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:17:48 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `claimBonus` function, the following check is performed:

    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

This check is redundant because the state of the soul is already being validated in the `migrate` function, which ensures that the soul is in a valid state before any migration occurs. Therefore, if the `claimBonus` function is called, it can be assumed that the state has already been validated, making this check unnecessary.

To mitigate this, you can remove the redundant conditional check from the `claimBonus` function to reduce gas costs and simplify the code.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities:
1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected.
2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations.
If you identify reliance on a single external oracle for critical data, respond with: """,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `rewardAdjustDebt` function, the line `user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;` does not require an explicit comparison to zero or any other value. The calculation is straightforward and does not need additional checks unless there are specific conditions that need to be validated before this assignment.
'''
``` 

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `unstake` function, the line `require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");` checks if the state is either `calibration` or `staking`. This is a necessary comparison to ensure that the unstaking can only occur in valid states. However, if the logic allows for more states to be added in the future, it may be beneficial to use a mapping or a state machine pattern to manage valid states more dynamically.
'''
``` 

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `configureCrossingConfig` function, the line `require(rectInflationFactor <= 10000, ""E6"");` checks if the inflation factor is within a valid range. This is a necessary comparison to ensure that

[2024-11-08 11:18:16 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `enabled` modifier, the comparison `require(protocolEnabled, ""EF"");` is a direct check of the boolean variable `protocolEnabled`. This is a valid use case, but it can be simplified by removing the explicit comparison to `true`. The line can be rewritten as `require(protocolEnabled, ""EF"");` without any change in functionality. This enhances readability and maintains clarity in the code.
'''
```

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `attemptToTargetAPY` function, the line `require(soul.soulType == SoulType.threshold, ""EI"");` checks if `soul.soulType` is equal to `SoulType.threshold`. This is a necessary comparison, but if the intention is to ensure that the soul type is not `SoulType.uninitialized`, it could be more readable to check directly against the valid types without the explicit comparison. However, this specific comparison is necessary for the logic of the contract.
'''
```

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `claimBonus` function, the line `require(finalFlanPerTeraToken > 0, ""ED"");` checks if `finalFlanPerTeraToken` is greater than zero. This is a necessary comparison to ensure that the bonus is positive before proceeding. However, if the logic allows for negative values to be handled differently, this comparison could be adjusted to reflect that logic more clearly.
'''
``` 

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `rewardAdjustDebt` function, the line `user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;` does not require an explicit comparison to zero or any other value. The calculation is straightforward and does not need additional checks unless there are specific conditions that need to be validated before this assignment.
'''
``` 

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `unstake` function, the line `require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");` checks if the state is either `calibration` or `staking`. This is a necessary comparison to ensure that the unstaking can only occur in valid states. However, if the logic allows for more states to be added in the future, it may be beneficial to use a mapping or a state machine pattern to manage valid states more dynamically.
'''
``` 

",,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"<INFO> Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `configureCrossingConfig` function, the line `require(rectInflationFactor <= 10000, ""E6"");` checks if the inflation factor is within a valid range. This is a necessary comparison to ensure that

[2024-11-08 11:18:16 INFO] **[Execute Detail]**

execute SimplePhase:[InconsistentInitializationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 11:18:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Inconsistent Initialization. This type of vulnerability arises when state variables are initialized using a function that relies on the state of other variables, which may not yet be set or initialized, leading to unpredictable or unintended behavior. There are two cases where the code may have Inconsistent Initialization vulnerabilities: 1. Initialization of a state variable using a function call where the function's logic depends on the state of other variables that are not yet initialized. This can lead to incorrect values being set for the variable. 2. Initialization order of state variables where the value of one variable depends on the value of another variable that has not been initialized yet. If you identify Inconsistent Initialization, respond with: "" Inconsistent Initialization Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Inconsistent Initialization."" |
| **phase_name** | InconsistentInitializationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/access/Ownable.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";\n// import ""hardhat/console.sol"";\nimport ""./facades/LimboDAOLike.sol"";\nimport ""./facades/Burnable.sol"";\nimport ""./facades/BehodlerLike.sol"";\nimport ""./facades/FlanLike.sol"";\nimport ""./facades/UniPairLike.sol"";\nimport ""./facades/MigratorLike.sol"";\nimport ""./facades/AMMHelper.sol"";\nimport ""./facades/AngbandLike.sol"";\nimport ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";\nimport ""./DAO/Governable.sol"";\nimport ""./facades/FlashGovernanceArbiterLike.sol"";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, ""EF"");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EI"");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, ""E1"");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, ""E6"");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, ""E4"");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, ""E5"");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, ""ED"");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, ""EB"");\n    require(soul.state == SoulState.waitingToCross, ""E2"");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      ""EC""\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' Unnecessary Comparison Identified.\n``\nUNNECESSARY COMPARISON\n\'\'\'\nIn theconfigureCrossingConfigfunction, the linerequire(rectInflationFactor &lt;= 10000, ""E6"");` checks if the inflation factor is within a valid range. This is a necessary comparison to ensure that'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 11:18:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import ""@openzeppelin/contracts/access/Ownable.sol""; import ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""; // import ""hardhat/console.sol""; import ""./facades/LimboDAOLike.sol""; import ""./facades/Burnable.sol""; import ""./facades/BehodlerLike.sol""; import ""./facades/FlanLike.sol""; import ""./facades/UniPairLike.sol""; import ""./facades/MigratorLike.sol""; import ""./facades/AMMHelper.sol""; import ""./facades/AngbandLike.sol""; import ""./facades/LimboAddTokenToBehodlerPowerLike.sol""; import ""./DAO/Governable.sol""; import ""./facades/FlashGovernanceArbiterLike.sol""; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9""); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, ""EF"");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EI"");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, ""E1"");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, ""E6"");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, ""E4""); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2""); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, ""E5""); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, ""E6"");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, ""ED"");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, ""EB"");     require(soul.state == SoulState.waitingToCross, ""E2"");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       ""EC""     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 11:18:16 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
"".
Ideas: "" Unnecessary Comparison Identified.
```
UNNECESSARY COMPARISON
'''
In the `configureCrossingConfig` function, the line `require(rectInflationFactor <= 10000, ""E6"");` checks if the inflation factor is within a valid range. This is a necessary comparison to ensure that"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Inconsistent Initialization. This type of vulnerability arises when state variables are initialized using a function that relies on the state of other variables, which may not yet be set or initialized, leading to unpredictable or unintended behavior.
There are two cases where the code may have Inconsistent Initialization vulnerabilities:
1. Initialization of a state variable using a function call where the function's logic depends on the state of other variables that are not yet initialized. This can lead to incorrect values being set for the variable.
2. Initialization order of state variables where the value of one variable depends on the value of another variable that has not been initialized yet.
If you identify Inconsistent Initialization, respond with: """,,,,,,,,,,,
