Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses the `doTransferOut` function, which performs a low-level call to transfer funds to an external address. This function does not check the success of the transfer operation. If the transfer fails (for example, if the recipient is a contract that does not implement the expected behavior), the contract will not revert, potentially leading to a loss of funds. 

Recommended Mitigation: Implement a check to ensure that the transfer was successful. This can be done by checking the return value of the low-level call and reverting the transaction if it fails. For example, modify the `doTransferOut` function to include a require statement that checks the success of the transfer operation.
'''

UNCHECKED LOW-LEVEL CALL
'''
The `doTransferIn` function also performs a low-level call to transfer tokens from the user to the contract. Similar to `doTransferOut`, this function does not check the success of the transfer operation. If the transfer fails, the contract will not revert, which can lead to unexpected behavior and loss of funds.

Recommended Mitigation: Ensure that the return value of the low-level call is checked. If the transfer fails, revert the transaction to prevent any loss of funds. This can be implemented by adding a require statement to check the success of the transfer operation.
'''
```

[2024-10-08 14:55:45 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses the `doTransferOut` function, which performs a low-level call to transfer funds to an external address. This function does not check the success of the transfer operation. If the transfer fails (for example, if the recipient is a contract that does not implement the expected behavior), the contract will not revert, potentially leading to a loss of funds. 

Recommended Mitigation: Implement a check to ensure that the transfer was successful. This can be done by checking the return value of the low-level call and reverting the transaction if it fails. For example, modify the `doTransferOut` function to include a require statement that checks the success of the transfer operation.
'''

UNCHECKED LOW-LEVEL CALL
'''
The `doTransferIn` function also performs a low-level call to transfer tokens from the user to the contract. Similar to `doTransferOut`, this function does not check the success of the transfer operation. If the transfer fails, the contract will not revert, which can lead to unexpected behavior and loss of funds.

Recommended Mitigation: Ensure that the return value of the low-level call is checked. If the transfer fails, revert the transaction to prevent any loss of funds. This can be implemented by adding a require statement to check the success of the transfer operation.
'''
```

[2024-10-08 14:55:45 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-10-08 14:55:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import ""./LPoolInterface.sol""; import ""./LPoolDepositor.sol""; import ""../lib/Exponential.sol""; import ""../Adminable.sol""; import ""../lib/CarefulMath.sol""; import ""../lib/TransferHelper.sol""; import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol""; import ""../DelegateInterface.sol""; import ""../ControllerInterface.sol""; import ""../IWETH.sol""; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), ""underlying_ address cannot be 0"");     require(controller_ != address(0), ""controller_ address cannot be 0"");     require(msg.sender == admin, ""Only allow to be called by admin"");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, ""inited once"");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, ""Initial Exchange Rate Mantissa should be greater zero"");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), ""dst address cannot be 0"");     /* Do not allow self-transfers */     require(src != dst, ""src = dst"");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, ""calc failed"");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, ""not eth pool"");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, ""borrower rate higher"");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, ""calc borrow index fail"");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, ""calc fail"");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, ""calc fail"");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, ""borrower rate higher"");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, ""calc mint token error"");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, ""calc supply new failed"");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, ""calc tokens new ailed"");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one be zero"");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, ""0x"");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport ""./LPoolInterface.sol"";\nimport ""./LPoolDepositor.sol"";\nimport ""../lib/Exponential.sol"";\nimport ""../Adminable.sol"";\nimport ""../lib/CarefulMath.sol"";\nimport ""../lib/TransferHelper.sol"";\nimport ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";\n\nimport ""../DelegateInterface.sol"";\nimport ""../ControllerInterface.sol"";\nimport ""../IWETH.sol"";\n\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), ""underlying_ address cannot be 0"");\n        require(controller_ != address(0), ""controller_ address cannot be 0"");\n        require(msg.sender == admin, ""Only allow to be called by admin"");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, ""inited once"");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, ""Initial Exchange Rate Mantissa should be greater zero"");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), ""dst address cannot be 0"");\n        / Do not allow self-transfers /\n        require(src != dst, ""src = dst"");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, ""calc failed"");\n        return balance;\n    }\n\n    / User Interface /\n\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, ""not eth pool"");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n    / Safe Token /\n\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, ""borrower rate higher"");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        return totalBorrowsNew;\n    }\n\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, ""calc borrow index fail"");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, ""calc fail"");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, ""calc fail"");\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, ""borrower rate higher"");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");\n\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, ""calc mint token error"");\n\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, ""calc supply new failed"");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, ""calc tokens new ailed"");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook /\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one be zero"");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook /\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    / Admin Functions ***/\n\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, ""0x"");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        _;\n    }\n}\n\n', 'ideas': "" Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n'''\nThe contract uses the `doTransferOut` function, which performs a low-level call to transfer funds to an external address. This function does not check the success of the transfer operation. If the transfer fails (for example, if the recipient is a contract that does not implement the expected behavior), the contract will not revert, potentially leading to a loss of funds. \n\nRecommended Mitigation: Implement a check to ensure that the transfer was successful. This can be done by checking the return value of the low-level call and reverting the transaction if it fails. For example, modify the `doTransferOut` function to include a require statement that checks the success of the transfer operation.\n'''\n\nUNCHECKED LOW-LEVEL CALL\n'''\nThe `doTransferIn` function also performs a low-level call to transfer tokens from the user to the contract. Similar to `doTransferOut`, this function does not check the success of the transfer operation. If the transfer fails, the contract will not revert, which can lead to unexpected behavior and loss of funds.\n\nRecommended Mitigation: Ensure that the return value of the low-level call is checked. If the transfer fails, revert the transaction to prevent any loss of funds. This can be implemented by adding a require statement to check the success of the transfer operation.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-10-08 14:55:45 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import ""./LPoolInterface.sol""; import ""./LPoolDepositor.sol""; import ""../lib/Exponential.sol""; import ""../Adminable.sol""; import ""../lib/CarefulMath.sol""; import ""../lib/TransferHelper.sol""; import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol""; import ""../DelegateInterface.sol""; import ""../ControllerInterface.sol""; import ""../IWETH.sol""; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), ""underlying_ address cannot be 0"");     require(controller_ != address(0), ""controller_ address cannot be 0"");     require(msg.sender == admin, ""Only allow to be called by admin"");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, ""inited once"");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, ""Initial Exchange Rate Mantissa should be greater zero"");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), ""dst address cannot be 0"");     /* Do not allow self-transfers */     require(src != dst, ""src = dst"");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, ""calc failed"");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, ""not eth pool"");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, ""borrower rate higher"");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, ""calc borrow index fail"");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, ""calc fail"");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, ""calc fail"");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, ""borrower rate higher"");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, ""calc mint token error"");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, ""calc supply new failed"");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, ""calc tokens new ailed"");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one be zero"");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, ""0x"");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-10-08 14:55:45 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import ""./LPoolInterface.sol"";
import ""./LPoolDepositor.sol"";
import ""../lib/Exponential.sol"";
import ""../Adminable.sol"";
import ""../lib/CarefulMath.sol"";
import ""../lib/TransferHelper.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";

import ""../DelegateInterface.sol"";
import ""../ControllerInterface.sol"";
import ""../IWETH.sol"";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), ""underlying_ address cannot be 0"");
        require(controller_ != address(0), ""controller_ address cannot be 0"");
        require(msg.sender == admin, ""Only allow to be called by admin"");
        require(accrualBlockNumber == 0 && borrowIndex == 0, ""inited once"");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, ""Initial Exchange Rate Mantissa should be greater zero"");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), ""dst address cannot be 0"");
        /* Do not allow self-transfers */
        require(src != dst, ""src = dst"");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, ""calc failed"");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, ""not eth pool"");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, ""borrower rate higher"");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, ""calc borrow index fail"");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, ""calc fail"");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, ""calc fail"");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, ""borrower rate higher"");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, ""calc mint token error"");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, ""calc supply new failed"");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, ""calc tokens new ailed"");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one be zero"");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, ""0x"");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import ""./LPoolInterface.sol"";
import ""./LPoolDepositor.sol"";
import ""../lib/Exponential.sol"";
import ""../Adminable.sol"";
import ""../lib/CarefulMath.sol"";
import ""../lib/TransferHelper.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";

import ""../DelegateInterface.sol"";
import ""../ControllerInterface.sol"";
import ""../IWETH.sol"";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), ""underlying_ address cannot be 0"");
        require(controller_ != address(0), ""controller_ address cannot be 0"");
        require(msg.sender == admin, ""Only allow to be called by admin"");
        require(accrualBlockNumber == 0 && borrowIndex == 0, ""inited once"");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, ""Initial Exchange Rate Mantissa should be greater zero"");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), ""dst address cannot be 0"");
        /* Do not allow self-transfers */
        require(src != dst, ""src = dst"");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, ""calc failed"");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, ""not eth pool"");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, ""borrower rate higher"");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, ""calc borrow index fail"");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, ""calc fail"");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, ""calc fail"");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, ""borrower rate higher"");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, ""calc block delta erro"");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, ""calc mint token error"");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, ""calc supply new failed"");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, ""calc tokens new ailed"");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one be zero"");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, ""0x"");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses the `doTransferOut` function, which performs a low-level call to transfer funds to an external address. This function does not check the success of the transfer operation. If the transfer fails (for example, if the recipient is a contract that does not implement the expected behavior), the contract will not revert, potentially leading to a loss of funds. 

Recommended Mitigation: Implement a check to ensure that the transfer was successful. This can be done by checking the return value of the low-level call and reverting the transaction if it fails. For example, modify the `doTransferOut` function to include a require statement that checks the success of the transfer operation.
'''

UNCHECKED LOW-LEVEL CALL
'''
The `doTransferIn` function also performs a low-level call to transfer tokens from the user to the contract. Similar to `doTransferOut`, this function does not check the success of the transfer operation. If the transfer fails, the contract will not revert, which can lead to unexpected behavior and loss of funds.

Recommended Mitigation: Ensure that the return value of the low-level call is checked. If the transfer fails, revert the transaction to prevent any loss of funds. This can be implemented by adding a require statement to check the success of the transfer operation.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
