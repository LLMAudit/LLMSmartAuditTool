Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `borrow` function, the contract performs a low-level call to transfer protocol fees and borrowed tokens without checking the success of the call:
```solidity
(bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
require(feeSuccess, 'Transfer fail');
(bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
require(success, 'Transfer fail');
```
If either of these calls fails, the transaction will revert, but the contract does not handle the case where the call to `protocolFeeCollector` fails before the transfer to `msg.sender`. This can lead to a situation where the borrower does not receive their funds, and the protocol fee is not transferred correctly.

Recommended Mitigation:
- Use the `transfer` method instead of `call` for transferring Ether, as it automatically reverts on failure. If using `call`, ensure to handle the failure case appropriately and consider using a `require` statement to revert the transaction if the call fails.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `liquidate` function, the contract performs a low-level call to transfer collateral tokens without checking the success of the call:
```solidity
(bool success, ) = msg.sender.call{value: _returnETH}('');
require(success, 'Transfer fail');
```
If the call to `msg.sender` fails, the transaction will revert, but the contract does not handle the case where the collateral transfer fails. This can lead to a situation where the liquidator does not receive their collateral, and the contract state may become inconsistent.

Recommended Mitigation:
- Similar to the previous case, consider using the `transfer` method instead of `call` for transferring Ether. If using `call`, ensure to handle the failure case appropriately and revert the transaction if the call fails.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `_withdrawBorrowAmount` function, the contract calls `withdrawFrom` on the savings account without checking if the call was successful:
```solidity
_savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
```
If the `withdrawFrom` function fails, the contract does not handle the error, which could lead to unexpected behavior and potential loss of funds.

Recommended Mitigation:
- Ensure that the `withdrawFrom` function call is followed by a check to confirm that the operation was successful. If the function does not return a boolean indicating success, consider wrapping it in a try-catch block or use a require statement to revert the transaction if the operation fails.
'''
```

[2024-08-08 14:45:02 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `borrow` function, the contract performs a low-level call to transfer protocol fees and borrowed tokens without checking the success of the call:
```solidity
(bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
require(feeSuccess, 'Transfer fail');
(bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
require(success, 'Transfer fail');
```
If either of these calls fails, the transaction will revert, but the contract does not handle the case where the call to `protocolFeeCollector` fails before the transfer to `msg.sender`. This can lead to a situation where the borrower does not receive their funds, and the protocol fee is not transferred correctly.

Recommended Mitigation:
- Use the `transfer` method instead of `call` for transferring Ether, as it automatically reverts on failure. If using `call`, ensure to handle the failure case appropriately and consider using a `require` statement to revert the transaction if the call fails.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `liquidate` function, the contract performs a low-level call to transfer collateral tokens without checking the success of the call:
```solidity
(bool success, ) = msg.sender.call{value: _returnETH}('');
require(success, 'Transfer fail');
```
If the call to `msg.sender` fails, the transaction will revert, but the contract does not handle the case where the collateral transfer fails. This can lead to a situation where the liquidator does not receive their collateral, and the contract state may become inconsistent.

Recommended Mitigation:
- Similar to the previous case, consider using the `transfer` method instead of `call` for transferring Ether. If using `call`, ensure to handle the failure case appropriately and revert the transaction if the call fails.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `_withdrawBorrowAmount` function, the contract calls `withdrawFrom` on the savings account without checking if the call was successful:
```solidity
_savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
```
If the `withdrawFrom` function fails, the contract does not handle the error, which could lead to unexpected behavior and potential loss of funds.

Recommended Mitigation:
- Ensure that the `withdrawFrom` function call is followed by a check to confirm that the operation was successful. If the function does not return a boolean indicating success, consider wrapping it in a try-catch block or use a require statement to revert the transaction if the operation fails.
'''
```

[2024-08-08 14:45:02 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-08-08 14:45:03 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         ""Only Borrower or Lender who hasn't requested can accept""     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     /\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     /\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     /\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     /\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     /\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     /\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     /\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     /\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            ""Only Borrower or Lender who hasn\'t requested can accept""\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn\'t match argument"");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount"");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     /\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10*_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n', 'ideas': "" Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n'''\nIn the `borrow` function, the contract performs a low-level call to transfer protocol fees and borrowed tokens without checking the success of the call:\nsolidity\n(bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');\nrequire(feeSuccess, 'Transfer fail');\n(bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');\nrequire(success, 'Transfer fail');\n\nIf either of these calls fails, the transaction will revert, but the contract does not handle the case where the call to `protocolFeeCollector` fails before the transfer to `msg.sender`. This can lead to a situation where the borrower does not receive their funds, and the protocol fee is not transferred correctly.\n\nRecommended Mitigation:\n- Use the `transfer` method instead of `call` for transferring Ether, as it automatically reverts on failure. If using `call`, ensure to handle the failure case appropriately and consider using a `require` statement to revert the transaction if the call fails.\n'''\n\n\n\nUNCHECKED LOW-LEVEL CALL\n'''\nIn the `liquidate` function, the contract performs a low-level call to transfer collateral tokens without checking the success of the call:\nsolidity\n(bool success, ) = msg.sender.call{value: _returnETH}('');\nrequire(success, 'Transfer fail');\n\nIf the call to `msg.sender` fails, the transaction will revert, but the contract does not handle the case where the collateral transfer fails. This can lead to a situation where the liquidator does not receive their collateral, and the contract state may become inconsistent.\n\nRecommended Mitigation:\n- Similar to the previous case, consider using the `transfer` method instead of `call` for transferring Ether. If using `call`, ensure to handle the failure case appropriately and revert the transaction if the call fails.\n'''\n\n\n\nUNCHECKED LOW-LEVEL CALL\n'''\nIn the `_withdrawBorrowAmount` function, the contract calls `withdrawFrom` on the savings account without checking if the call was successful:\nsolidity\n_savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n\nIf the `withdrawFrom` function fails, the contract does not handle the error, which could lead to unexpected behavior and potential loss of funds.\n\nRecommended Mitigation:\n- Ensure that the `withdrawFrom` function call is followed by a check to confirm that the operation was successful. If the function does not return a boolean indicating success, consider wrapping it in a try-catch block or use a require statement to revert the transaction if the operation fails.\n'''\n""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-08-08 14:45:03 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         ""Only Borrower or Lender who hasn't requested can accept""     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-08-08 14:45:03 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
In the `borrow` function, the contract performs a low-level call to transfer protocol fees and borrowed tokens without checking the success of the call:
```solidity
(bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
require(feeSuccess, 'Transfer fail');
(bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
require(success, 'Transfer fail');
```
If either of these calls fails, the transaction will revert, but the contract does not handle the case where the call to `protocolFeeCollector` fails before the transfer to `msg.sender`. This can lead to a situation where the borrower does not receive their funds, and the protocol fee is not transferred correctly.

Recommended Mitigation:
- Use the `transfer` method instead of `call` for transferring Ether, as it automatically reverts on failure. If using `call`, ensure to handle the failure case appropriately and consider using a `require` statement to revert the transaction if the call fails.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `liquidate` function, the contract performs a low-level call to transfer collateral tokens without checking the success of the call:
```solidity
(bool success, ) = msg.sender.call{value: _returnETH}('');
require(success, 'Transfer fail');
```
If the call to `msg.sender` fails, the transaction will revert, but the contract does not handle the case where the collateral transfer fails. This can lead to a situation where the liquidator does not receive their collateral, and the contract state may become inconsistent.

Recommended Mitigation:
- Similar to the previous case, consider using the `transfer` method instead of `call` for transferring Ether. If using `call`, ensure to handle the failure case appropriately and revert the transaction if the call fails.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `_withdrawBorrowAmount` function, the contract calls `withdrawFrom` on the savings account without checking if the call was successful:
```solidity
_savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
```
If the `withdrawFrom` function fails, the contract does not handle the error, which could lead to unexpected behavior and potential loss of funds.

Recommended Mitigation:
- Ensure that the `withdrawFrom` function call is followed by a check to confirm that the operation was successful. If the function does not return a boolean indicating success, consider wrapping it in a try-catch block or use a require statement to revert the transaction if the operation fails.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
