Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses low-level calls such as `call` and `delegatecall` without proper error handling or checks to ensure the calls succeed. For instance, in the `_singleLeverUp` function, the call to the router's `route` function does not check if the call was successful. If the external contract fails for any reason (e.g., insufficient gas, revert conditions), the failure will not be caught, potentially leading to unexpected behavior or loss of funds.

Recommended Mitigation:
To mitigate this vulnerability, it is essential to check the return value of low-level calls. For example, after the call to the router, you can implement a require statement to ensure the call succeeded:
```
(bool success, ) = router.route(...);
require(success, ""Router call failed"");
```
This ensures that if the call fails, the transaction will revert, preventing any unintended consequences.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `_repayYUSD` function, the call to `burn` on the `yusdToken` does not check if the operation was successful. If the `burn` function fails (e.g., due to insufficient balance), the transaction will not revert, leading to a potential loss of funds or inconsistent state.

Recommended Mitigation:
Implement a check on the return value of the `burn` function to ensure it executed successfully. For example:
```
bool success = _yusdToken.burn(_account, _YUSD);
require(success, ""YUSD burn failed"");
```
This will ensure that if the burn operation fails, the transaction will revert, maintaining the integrity of the contract's state.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `_withdrawYUSD` function, the call to `mint` on the `yusdToken` does not check if the minting was successful. If the minting fails, the contract's state may become inconsistent, leading to potential loss of funds.

Recommended Mitigation:
Check the return value of the `mint` function to ensure it was successful. For example:
```
bool success = _yusdToken.mint(_account, _YUSDAmount);
require(success, ""YUSD minting failed"");
```
This will ensure that if the minting operation fails, the transaction will revert, preventing any unintended consequences.
'''
```

[2024-08-08 22:39:26 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses low-level calls such as `call` and `delegatecall` without proper error handling or checks to ensure the calls succeed. For instance, in the `_singleLeverUp` function, the call to the router's `route` function does not check if the call was successful. If the external contract fails for any reason (e.g., insufficient gas, revert conditions), the failure will not be caught, potentially leading to unexpected behavior or loss of funds.

Recommended Mitigation:
To mitigate this vulnerability, it is essential to check the return value of low-level calls. For example, after the call to the router, you can implement a require statement to ensure the call succeeded:
```
(bool success, ) = router.route(...);
require(success, ""Router call failed"");
```
This ensures that if the call fails, the transaction will revert, preventing any unintended consequences.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `_repayYUSD` function, the call to `burn` on the `yusdToken` does not check if the operation was successful. If the `burn` function fails (e.g., due to insufficient balance), the transaction will not revert, leading to a potential loss of funds or inconsistent state.

Recommended Mitigation:
Implement a check on the return value of the `burn` function to ensure it executed successfully. For example:
```
bool success = _yusdToken.burn(_account, _YUSD);
require(success, ""YUSD burn failed"");
```
This will ensure that if the burn operation fails, the transaction will revert, maintaining the integrity of the contract's state.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `_withdrawYUSD` function, the call to `mint` on the `yusdToken` does not check if the minting was successful. If the minting fails, the contract's state may become inconsistent, leading to potential loss of funds.

Recommended Mitigation:
Check the return value of the `mint` function to ensure it was successful. For example:
```
bool success = _yusdToken.mint(_account, _YUSDAmount);
require(success, ""YUSD minting failed"");
```
This will ensure that if the minting operation fails, the transaction will revert, preventing any unintended consequences.
'''
```

[2024-08-08 22:39:26 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-08-08 22:39:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import ""./Interfaces/IBorrowerOperations.sol""; import ""./Interfaces/ITroveManager.sol""; import ""./Interfaces/IYUSDToken.sol""; import ""./Interfaces/ICollSurplusPool.sol""; import ""./Interfaces/ISortedTroves.sol""; import ""./Interfaces/ISYETI.sol""; import ""./Interfaces/IWhitelist.sol""; import ""./Interfaces/IYetiRouter.sol""; import ""./Interfaces/IERC20.sol""; import ""./Dependencies/LiquityBase.sol""; import ""./Dependencies/Ownable.sol""; import ""./Dependencies/CheckContract.sol""; import ""./Dependencies/SafeMath.sol""; import ""./Dependencies/ReentrancyGuard.sol""; import ""./Interfaces/IWAsset.sol""; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = ""BorrowerOperations""; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: ""CompilerError: Stack too deep"". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, ""BO:MIN_NET_DEBT==0"");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, ""WrongLeverage"");     require(_maxSlippage &lt;= 1e18, ""WrongSlippage"");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), ""BO:RouteLeverUpNotSent""); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, ""WrongSlippage"");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), ""BO:YUSDNotSentUnLever""); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), ""BO:TransferCollsFailed"");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), ""BO:BadColl"");         require(_amounts[i] != 0, ""BO:NoAmounts"");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         ""BO:0Adjust""     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), ""BO:TroveInactive""); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), ""BO:TroveActive""); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, ""BO:NoDebtChange""); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], ""BO:OverlapColls"");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], ""BO:OverlapColls"");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), ""BO:InRecMode""); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         ""BO:InRecMode""     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, ""BOps:Len0""); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, ""BO:LenMismatch""); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         ""BO:ReqICR&gt;MCR""     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, ""BO:ReqICR&gt;CCR""); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         ""BO:RecMode:ICR&lt;oldICR""     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         ""BO:ReqTCR&gt;CCR""     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         ""BO:netDebt&lt;2000""     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         ""BO:InvalidYUSDRepay""     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         ""BO:InsuffYUSDBal""     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert(""BO:InvalidMaxFee"");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  ""_requireValidRouterParams: _finalRoutedColls length mismatch""); //     require(_amounts.length == _routers.length, ""_requireValidRouterParams: _routers length mismatch""); //     require(_amounts.length == _minSwapAmounts.length, ""_minSwapAmounts: finalRoutedColls length mismatch""); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), ""_requireValidRouterParams: not a valid router""); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], ""_requireRouterAVAXIndicesInOrder: indices out of order""); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport ""./Interfaces/IBorrowerOperations.sol"";\nimport ""./Interfaces/ITroveManager.sol"";\nimport ""./Interfaces/IYUSDToken.sol"";\nimport ""./Interfaces/ICollSurplusPool.sol"";\nimport ""./Interfaces/ISortedTroves.sol"";\nimport ""./Interfaces/ISYETI.sol"";\nimport ""./Interfaces/IWhitelist.sol"";\nimport ""./Interfaces/IYetiRouter.sol"";\nimport ""./Interfaces/IERC20.sol"";\nimport ""./Dependencies/LiquityBase.sol"";\nimport ""./Dependencies/Ownable.sol"";\nimport ""./Dependencies/CheckContract.sol"";\nimport ""./Dependencies/SafeMath.sol"";\nimport ""./Dependencies/ReentrancyGuard.sol"";\nimport ""./Interfaces/IWAsset.sol"";\n\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = ""BorrowerOperations"";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    / --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    ""CompilerError: Stack too deep"". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, ""BO:MIN_NET_DEBT==0"");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, ""WrongLeverage"");\n        require(_maxSlippage &lt;= 1e18, ""WrongSlippage"");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), ""BO:RouteLeverUpNotSent"");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, ""WrongSlippage"");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), ""BO:YUSDNotSentUnLever"");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     /\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), ""BO:TransferCollsFailed"");\n        }\n    }\n\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- \'Require\' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), ""BO:BadColl"");\n            require(_amounts[i] != 0, ""BO:NoAmounts"");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            ""BO:0Adjust""\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), ""BO:TroveInactive"");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), ""BO:TroveActive"");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, ""BO:NoDebtChange"");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], ""BO:OverlapColls"");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], ""BO:OverlapColls"");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), ""BO:InRecMode"");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            ""BO:InRecMode""\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, ""BOps:Len0"");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, ""BO:LenMismatch"");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            ""BO:ReqICR&gt;MCR""\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, ""BO:ReqICR&gt;CCR"");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            ""BO:RecMode:ICR= CCR,\n            ""BO:ReqTCR&gt;CCR""\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            ""BO:netDebt&lt;2000""\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            ""BO:InvalidYUSDRepay""\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            ""BO:InsuffYUSDBal""\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert(""BO:InvalidMaxFee"");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  ""_requireValidRouterParams: _finalRoutedColls length mismatch"");\n    //     require(_amounts.length == _routers.length, ""_requireValidRouterParams: _routers length mismatch"");\n    //     require(_amounts.length == _minSwapAmounts.length, ""_minSwapAmounts: finalRoutedColls length mismatch"");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), ""_requireValidRouterParams: not a valid router"");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], ""_requireRouterAVAXIndicesInOrder: indices out of order"");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nThe contract uses low-level calls such as `call` and `delegatecall` without proper error handling or checks to ensure the calls succeed. For instance, in the `_singleLeverUp` function, the call to the router\'s `route` function does not check if the call was successful. If the external contract fails for any reason (e.g., insufficient gas, revert conditions), the failure will not be caught, potentially leading to unexpected behavior or loss of funds.\n\nRecommended Mitigation:\nTo mitigate this vulnerability, it is essential to check the return value of low-level calls. For example, after the call to the router, you can implement a require statement to ensure the call succeeded:\n\n(bool success, ) = router.route(...);\nrequire(success, ""Router call failed"");\n\nThis ensures that if the call fails, the transaction will revert, preventing any unintended consequences.\n\'\'\'\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `_repayYUSD` function, the call to `burn` on the `yusdToken` does not check if the operation was successful. If the `burn` function fails (e.g., due to insufficient balance), the transaction will not revert, leading to a potential loss of funds or inconsistent state.\n\nRecommended Mitigation:\nImplement a check on the return value of the `burn` function to ensure it executed successfully. For example:\n\nbool success = _yusdToken.burn(_account, _YUSD);\nrequire(success, ""YUSD burn failed"");\n\nThis will ensure that if the burn operation fails, the transaction will revert, maintaining the integrity of the contract\'s state.\n\'\'\'\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `_withdrawYUSD` function, the call to `mint` on the `yusdToken` does not check if the minting was successful. If the minting fails, the contract\'s state may become inconsistent, leading to potential loss of funds.\n\nRecommended Mitigation:\nCheck the return value of the `mint` function to ensure it was successful. For example:\n\nbool success = _yusdToken.mint(_account, _YUSDAmount);\nrequire(success, ""YUSD minting failed"");\n\nThis will ensure that if the minting operation fails, the transaction will revert, preventing any unintended consequences.\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-08-08 22:39:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import ""./Interfaces/IBorrowerOperations.sol""; import ""./Interfaces/ITroveManager.sol""; import ""./Interfaces/IYUSDToken.sol""; import ""./Interfaces/ICollSurplusPool.sol""; import ""./Interfaces/ISortedTroves.sol""; import ""./Interfaces/ISYETI.sol""; import ""./Interfaces/IWhitelist.sol""; import ""./Interfaces/IYetiRouter.sol""; import ""./Interfaces/IERC20.sol""; import ""./Dependencies/LiquityBase.sol""; import ""./Dependencies/Ownable.sol""; import ""./Dependencies/CheckContract.sol""; import ""./Dependencies/SafeMath.sol""; import ""./Dependencies/ReentrancyGuard.sol""; import ""./Interfaces/IWAsset.sol""; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = ""BorrowerOperations""; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: ""CompilerError: Stack too deep"". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, ""BO:MIN_NET_DEBT==0"");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, ""WrongLeverage"");     require(_maxSlippage &lt;= 1e18, ""WrongSlippage"");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), ""BO:RouteLeverUpNotSent""); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, ""WrongSlippage"");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), ""BO:YUSDNotSentUnLever""); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), ""BO:TransferCollsFailed"");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), ""BO:BadColl"");         require(_amounts[i] != 0, ""BO:NoAmounts"");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         ""BO:0Adjust""     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), ""BO:TroveInactive""); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), ""BO:TroveActive""); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, ""BO:NoDebtChange""); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], ""BO:OverlapColls"");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], ""BO:OverlapColls"");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), ""BO:InRecMode""); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         ""BO:InRecMode""     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, ""BOps:Len0""); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, ""BO:LenMismatch""); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         ""BO:ReqICR&gt;MCR""     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, ""BO:ReqICR&gt;CCR""); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         ""BO:RecMode:ICR&lt;oldICR""     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         ""BO:ReqTCR&gt;CCR""     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         ""BO:netDebt&lt;2000""     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         ""BO:InvalidYUSDRepay""     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         ""BO:InsuffYUSDBal""     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert(""BO:InvalidMaxFee"");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  ""_requireValidRouterParams: _finalRoutedColls length mismatch""); //     require(_amounts.length == _routers.length, ""_requireValidRouterParams: _routers length mismatch""); //     require(_amounts.length == _minSwapAmounts.length, ""_minSwapAmounts: finalRoutedColls length mismatch""); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), ""_requireValidRouterParams: not a valid router""); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], ""_requireRouterAVAXIndicesInOrder: indices out of order""); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-08-08 22:39:27 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/ReentrancyGuard.sol"";
import ""./Interfaces/IWAsset.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, ""BO:MIN_NET_DEBT==0"");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, ""WrongLeverage"");
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), ""BO:RouteLeverUpNotSent"");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), ""BO:YUSDNotSentUnLever"");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), ""BO:TransferCollsFailed"");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), ""BO:BadColl"");
            require(_amounts[i] != 0, ""BO:NoAmounts"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BO:0Adjust""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), ""BO:TroveInactive"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), ""BO:TroveActive"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, ""BO:NoDebtChange"");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BO:InRecMode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BO:InRecMode""
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, ""BOps:Len0"");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, ""BO:LenMismatch"");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BO:ReqICR>MCR""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BO:ReqICR>CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BO:RecMode:ICR<oldICR""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BO:ReqTCR>CCR""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BO:netDebt<2000""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BO:InvalidYUSDRepay""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BO:InsuffYUSDBal""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert(""BO:InvalidMaxFee"");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  ""_requireValidRouterParams: _finalRoutedColls length mismatch"");
    //     require(_amounts.length == _routers.length, ""_requireValidRouterParams: _routers length mismatch"");
    //     require(_amounts.length == _minSwapAmounts.length, ""_minSwapAmounts: finalRoutedColls length mismatch"");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), ""_requireValidRouterParams: not a valid router"");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], ""_requireRouterAVAXIndicesInOrder: indices out of order"");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/ReentrancyGuard.sol"";
import ""./Interfaces/IWAsset.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, ""BO:MIN_NET_DEBT==0"");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, ""WrongLeverage"");
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), ""BO:RouteLeverUpNotSent"");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), ""BO:YUSDNotSentUnLever"");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), ""BO:TransferCollsFailed"");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), ""BO:BadColl"");
            require(_amounts[i] != 0, ""BO:NoAmounts"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BO:0Adjust""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), ""BO:TroveInactive"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), ""BO:TroveActive"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, ""BO:NoDebtChange"");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BO:InRecMode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BO:InRecMode""
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, ""BOps:Len0"");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, ""BO:LenMismatch"");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BO:ReqICR>MCR""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BO:ReqICR>CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BO:RecMode:ICR<oldICR""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BO:ReqTCR>CCR""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BO:netDebt<2000""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BO:InvalidYUSDRepay""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BO:InsuffYUSDBal""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert(""BO:InvalidMaxFee"");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  ""_requireValidRouterParams: _finalRoutedColls length mismatch"");
    //     require(_amounts.length == _routers.length, ""_requireValidRouterParams: _routers length mismatch"");
    //     require(_amounts.length == _minSwapAmounts.length, ""_minSwapAmounts: finalRoutedColls length mismatch"");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), ""_requireValidRouterParams: not a valid router"");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], ""_requireRouterAVAXIndicesInOrder: indices out of order"");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses low-level calls such as `call` and `delegatecall` without proper error handling or checks to ensure the calls succeed. For instance, in the `_singleLeverUp` function, the call to the router's `route` function does not check if the call was successful. If the external contract fails for any reason (e.g., insufficient gas, revert conditions), the failure will not be caught, potentially leading to unexpected behavior or loss of funds.

Recommended Mitigation:
To mitigate this vulnerability, it is essential to check the return value of low-level calls. For example, after the call to the router, you can implement a require statement to ensure the call succeeded:
```
(bool success, ) = router.route(...);
require(success, ""Router call failed"");
```
This ensures that if the call fails, the transaction will revert, preventing any unintended consequences.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `_repayYUSD` function, the call to `burn` on the `yusdToken` does not check if the operation was successful. If the `burn` function fails (e.g., due to insufficient balance), the transaction will not revert, leading to a potential loss of funds or inconsistent state.

Recommended Mitigation:
Implement a check on the return value of the `burn` function to ensure it executed successfully. For example:
```
bool success = _yusdToken.burn(_account, _YUSD);
require(success, ""YUSD burn failed"");
```
This will ensure that if the burn operation fails, the transaction will revert, maintaining the integrity of the contract's state.
'''

UNCHECKED LOW-LEVEL CALL
'''
In the `_withdrawYUSD` function, the call to `mint` on the `yusdToken` does not check if the minting was successful. If the minting fails, the contract's state may become inconsistent, leading to potential loss of funds.

Recommended Mitigation:
Check the return value of the `mint` function to ensure it was successful. For example:
```
bool success = _yusdToken.mint(_account, _YUSDAmount);
require(success, ""YUSD minting failed"");
```
This will ensure that if the minting operation fails, the transaction will revert, preventing any unintended consequences.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
