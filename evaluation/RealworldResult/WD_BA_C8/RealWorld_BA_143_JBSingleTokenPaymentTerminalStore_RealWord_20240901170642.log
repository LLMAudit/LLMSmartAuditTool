[2024-01-09 17:06:42 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901170642)

**Timestamp**: 20240901170642

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}


**project_name**: RealWorld_BA_143_JBSingleTokenPaymentTerminalStore

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_143_JBSingleTokenPaymentTerminalStore_RealWord_20240901170642.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 17:06:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBCurrencies.sol';\nimport './libraries/JBFixedPointNumber.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\n\n/\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********//\n  // -------------------------- private constants ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  /\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  //***********//\n  // --------------------- public stored properties -------------------- //\n  //**********//\n\n  /\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf;\n\n  /\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n\n    @dev\n    Increases as projects use their allowance.\n\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of overflow that project has in the specified terminal.\n  /\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n\n    @return The current total amount of overflow that project has across all terminals.\n  /\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal's currency.\n\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified _terminal.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _terminal.\n  /\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _overflow.\n  /\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  /\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Records newly contributed tokens to a project.\n\n    @dev\n    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The project's funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // If there's no amount being recorded, there's nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n\n    // If there's no weight, token count must be 0 so there's nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n\n    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the _amount.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as weight has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n\n  /\n    @notice\n    Records newly redeemed tokens of a project.\n\n    @dev\n    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n\n    // Scoped section prevents stack too deep. _reclaimedTokenAmount, _currentOverflow, and _totalSupply only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n\n      // Another scoped section prevents stack too deep. _token, _decimals, and _currency only used within scope.\n      {\n        // Get a reference to the terminal's tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n\n        // Get a reference to the terminal's decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n\n        // Get areference to the terminal's currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n\n        // Can't redeem more tokens that is in the supply.\n        if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();\n\n        if (_currentOverflow &gt; 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that'll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n\n    // The amount being reclaimed must be within the project's balance.\n    if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Remove the reclaimed funds from the project's balance.\n    if (reclaimAmount &gt; 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n\n  /\n    @notice\n    Records newly distributed funds for a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the _amount. This must match the project's current funding cycle's currency.\n\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to the balance's currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available.\n    if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n\n    // Removed the distributed funds from the project's token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n\n  /\n    @notice\n    Records newly used allowance funds of a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the _amount. Must match the currency of the overflow allowance.\n\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to this store's terminal's token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount &gt;\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n\n    // Update the project's balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n\n  /\n    @notice\n    Records newly added funds for the project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n\n  /\n    @notice\n    Records the migration of funds from this store.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n\n    @param _projectId The ID of the project being migrated.\n\n    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n\n  //*********//\n  // --------------------- private helper functions -------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n\n    @return The amount of overflowed tokens that can be reclaimed.\n  /\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n\n  /\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @param _fundingCycle The ID of the funding cycle to base the overflow on.\n    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n\n    @return overflow The overflow of funds, as a fixed point number with 18 decimals.\n  /\n  function _overflowDuring(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _balanceCurrency\n  ) private view returns (uint256) {\n    // Get the current balance of the project.\n    uint256 _balanceOf = balanceOf[_terminal][_projectId];\n\n    // If there's no balance, there's no overflow.\n    if (_balanceOf == 0) return 0;\n\n    // Get a reference to the distribution limit during the funding cycle.\n    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n\n    // Get a reference to the amount still distributable during the funding cycle.\n    uint256 _distributionLimitRemaining = _distributionLimit -\n      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n\n    // Convert the _distributionRemaining to be in terms of the provided currency.\n    if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)\n      _distributionLimitRemaining = PRBMath.mulDiv(\n        _distributionLimitRemaining,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // Overflow is the balance of this project minus the amount that can still be distributed.\n    return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n  }\n\n  /\n    @notice\n    Gets the amount that is currently overflowing across all of a project's terminals. \n\n    @dev\n    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.\n\n    @param _projectId The ID of the project to get the total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the overflow should be in terms of.\n\n    @return overflow The total overflow of a project's funds.\n  /\n  function _currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) private view returns (uint256) {\n    // Get a reference to the project's terminals.\n    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);\n\n    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.\n    uint256 _ethOverflow;\n\n    // Add the current ETH overflow for each terminal.\n    for (uint256 _i = 0; _i &lt; _terminals.length; _i++)\n      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);\n\n    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.\n    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH\n      ? _ethOverflow\n      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));\n\n    // Adjust the decimals of the fixed point number if needed to match the target decimals.\n    return\n      (_decimals == 18)\n        ? _totalOverflow18Decimal\n        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);\n  }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:06:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:06:42 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 17:06:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:06:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16012
completion_tokens: 353
total_tokens: 16365
cost: $-1.000000


[2024-01-09 17:06:49 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Let's analyze the provided Solidity contract and identify potential improvements or enhancements.

1. **Error Handling**: The contract uses custom errors for various failure cases, which is a good practice for gas efficiency. However, we could consider adding more descriptive error messages or events to provide better context when errors occur. This could help in debugging and understanding the state of the contract during failures.

2. **Access Control**: Currently, the contract does not implement any access control mechanisms for functions that modify state. We could consider using OpenZeppelin's `Ownable` or `AccessControl` to restrict access to certain functions, ensuring that only authorized addresses can perform sensitive operations.

3. **Gas Optimization**: The contract has several mappings and calculations that could be optimized for gas efficiency. For example, we could explore using `uint128` or `uint64` for certain variables instead of `uint256` if the expected values are within those ranges. This could save gas costs during transactions.

4. **Reentrancy Protection**: While the contract inherits from `ReentrancyGuard`, we should ensure that all state-changing functions are properly protected. We could also consider implementing checks-effects-interactions pattern more rigorously to further mitigate reentrancy risks.

5. **Event Emission**: The contract could benefit from emitting events for critical state changes, such as payments, redemptions, and distributions. This would enhance transparency and allow for easier tracking of contract activity on the blockchain.

6. **Upgradeability**: If the contract is intended to be used for a long time, we might want to consider implementing a proxy pattern for upgradeability. This would allow the contract logic to be updated without losing the state.

7. **Testing and Auditing**: Ensure

[2024-01-09 17:06:49 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \'@openzeppelin/contracts/security/ReentrancyGuard.sol\';\nimport \'@paulrberg/contracts/math/PRBMath.sol\';\nimport \'./interfaces/IJBController.sol\';\nimport \'./interfaces/IJBSingleTokenPaymentTerminalStore.sol\';\nimport \'./libraries/JBConstants.sol\';\nimport \'./libraries/JBCurrencies.sol\';\nimport \'./libraries/JBFixedPointNumber.sol\';\nimport \'./libraries/JBFundingCycleMetadataResolver.sol\';\n/\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain\'s state according to the protocol\'s rules.\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n  //*********//\n  // -------------------------- private constants ---------------------- //\n  //*********//\n  /\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  /\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n  //***********//\n  // --------------------- public stored properties -------------------- //\n  //**********//\n  /\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal\'s token.\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf;\n  /\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit\'s currency.\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedDistributionLimitOf;\n  /\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance\'s currency.\n    @dev\n    Increases as projects use their allowance.\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedOverflowAllowanceOf;\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n  /\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @return The current amount of overflow that project has in the specified terminal.\n  /\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project\'s current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n  /\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n    @return The current total amount of overflow that project has across all terminals.\n  /\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project\'s ballot redemption rate is used.\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal\'s currency.\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project\'s terminals. If false, overflow should be limited to the amount in the specified _terminal.\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _terminal.\n  /\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Get the amount of current overflow.\n    // Use the project\'s total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n    // If there\'s no overflow, there\'s no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n    // Can\'t redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project\'s ballot redemption rate is used.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _overflow.\n  /\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there\'s no overflow, there\'s no reclaimable overflow.\n    if (_overflow == 0) return 0;\n    // Can\'t redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n  //*********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n  /\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  /\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n  /\n    @notice\n    Records newly contributed tokens to a project.\n    @dev\n    Mint\'s the project\'s tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender\'s tokens.\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle\'s data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n    @return fundingCycle The project\'s funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that\'ll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle\'s weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n    // If there\'s no amount being recorded, there\'s nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n    // If there\'s no weight, token count must be 0 so there\'s nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n    // If the terminal should base its weight on a different currency from the terminal\'s currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the _amount.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as weight has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n  /\n    @notice\n    Records newly redeemed tokens of a project.\n    @dev\n    Redeems the project\'s tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project\'s current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n    // Scoped section prevents stack too deep. _reclaimedTokenAmount, _currentOverflow, and _totalSupply only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n      // Another scoped section prevents stack too deep. _token, _decimals, and _currency only used within scope.\n      {\n        // Get a reference to the terminal\'s tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n        // Get a reference to the terminal\'s decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n        // Get areference to the terminal\'s currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project\'s total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n        // Can\'t redeem more tokens that is in the supply.\n        if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();\n        if (_currentOverflow &gt; 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that\'ll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n    // The amount being reclaimed must be within the project\'s balance.\n    if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n    // Remove the reclaimed funds from the project\'s balance.\n    if (reclaimAmount &gt; 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n  /\n    @notice\n    Records newly distributed funds for a project.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the _amount. This must match the project\'s current funding cycle\'s currency.\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n    // Get a reference to the terminal\'s currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n    // Convert the amount to the balance\'s currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value\'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n    // The amount being distributed must be available.\n    if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n    // Removed the distributed funds from the project\'s token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n  /\n    @notice\n    Records newly used allowance funds of a project.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the _amount. Must match the currency of the overflow allowance.\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n    // Get a reference to the terminal\'s currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n    // Convert the amount to this store\'s terminal\'s token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value\'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount &gt;\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n    // Update the project\'s balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n  /\n    @notice\n    Records newly added funds for the project.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n  /\n    @notice\n    Records the migration of funds from this store.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n    @param _projectId The ID of the project being migrated.\n    @return balance The project\'s migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n  //*********//\n  // --------------------- private helper functions -------------------- //\n  //*********//\n  /\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project\'s ballot redemption rate is used.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n    @return The amount of overflowed tokens that can be reclaimed.\n  /\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle\'s ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n  /\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @param _fundingCycle The ID of the funding cycle to base the overflow on.\n    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n    @return overflow The overflow of funds, as a fixed point number with 18 decimals.\n  /\n  function _overflowDuring(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _balanceCurrency\n  ) private view returns (uint256) {\n    // Get the current balance of the project.\n    uint256 _balanceOf = balanceOf[_terminal][_projectId];\n    // If there\'s no balance, there\'s no overflow.\n    if (_balanceOf == 0) return 0;\n    // Get a reference to the distribution limit during the funding cycle.\n    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n    // Get a reference to the amount still distributable during the funding cycle.\n    uint256 _distributionLimitRemaining = _distributionLimit -\n      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n    // Convert the _distributionRemaining to be in terms of the provided currency.\n    if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)\n      _distributionLimitRemaining = PRBMath.mulDiv(\n        _distributionLimitRemaining,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value\'s fidelity as possible when converting.\n        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n    // Overflow is the balance of this project minus the amount that can still be distributed.\n    return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n  }\n  /\n    @notice\n    Gets the amount that is currently overflowing across all of a project\'s terminals. \n    @dev\n    This amount changes as the value of the balances changes in relation to the currency being used to measure the project\'s distribution limits.\n    @param _projectId The ID of the project to get the total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the overflow should be in terms of.\n    @return overflow The total overflow of a project\'s funds.\n  /\n  function _currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) private view returns (uint256) {\n    // Get a reference to the project\'s terminals.\n    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);\n    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.\n    uint256 _ethOverflow;\n    // Add the current ETH overflow for each terminal.\n    for (uint256 _i = 0; _i &lt; _terminals.length; _i++)\n      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);\n    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.\n    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH\n      ? _ethOverflow\n      : PRBMath.mulDiv(_ethOverflow, 1018, prices.priceFor(JBCurrencies.ETH, _currency, 18));\n    // Adjust the decimals of the fixed point number if needed to match the target decimals.\n    return\n      (_decimals == 18)\n        ? _totalOverflow18Decimal\n        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \'@openzeppelin/contracts/security/ReentrancyGuard.sol\';\nimport \'@paulrberg/contracts/math/PRBMath.sol\';\nimport \'./interfaces/IJBController.sol\';\nimport \'./interfaces/IJBSingleTokenPaymentTerminalStore.sol\';\nimport \'./libraries/JBConstants.sol\';\nimport \'./libraries/JBCurrencies.sol\';\nimport \'./libraries/JBFixedPointNumber.sol\';\nimport \'./libraries/JBFundingCycleMetadataResolver.sol\';\n/\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain\'s state according to the protocol\'s rules.\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n  //**********//\n  // --------------------------- custom errors ------------------------- //\n  //**********//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n  //*********//\n  // -------------------------- private constants ---------------------- //\n  //*********//\n  /\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  /\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n  //***********//\n  // --------------------- public stored properties -------------------- //\n  //**********//\n  /\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal\'s token.\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf;\n  /\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit\'s currency.\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedDistributionLimitOf;\n  /\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance\'s currency.\n    @dev\n    Increases as projects use their allowance.\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedOverflowAllowanceOf;\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n  /\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @return The current amount of overflow that project has in the specified terminal.\n  /\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project\'s current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n  /\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n    @return The current total amount of overflow that project has across all terminals.\n  /\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project\'s ballot redemption rate is used.\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal\'s currency.\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project\'s terminals. If false, overflow should be limited to the amount in the specified _terminal.\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _terminal.\n  /\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Get the amount of current overflow.\n    // Use the project\'s total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n    // If there\'s no overflow, there\'s no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n    // Can\'t redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project\'s ballot redemption rate is used.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _overflow.\n  /\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there\'s no overflow, there\'s no reclaimable overflow.\n    if (_overflow == 0) return 0;\n    // Can\'t redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n  //*********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n  /\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  /\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n  /\n    @notice\n    Records newly contributed tokens to a project.\n    @dev\n    Mint\'s the project\'s tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender\'s tokens.\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle\'s data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n    @return fundingCycle The project\'s funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that\'ll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle\'s weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n    // If there\'s no amount being recorded, there\'s nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n    // If there\'s no weight, token count must be 0 so there\'s nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n    // If the terminal should base its weight on a different currency from the terminal\'s currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the _amount.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as weight has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n  /\n    @notice\n    Records newly redeemed tokens of a project.\n    @dev\n    Redeems the project\'s tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project\'s current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n    // Scoped section prevents stack too deep. _reclaimedTokenAmount, _currentOverflow, and _totalSupply only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n      // Another scoped section prevents stack too deep. _token, _decimals, and _currency only used within scope.\n      {\n        // Get a reference to the terminal\'s tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n        // Get a reference to the terminal\'s decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n        // Get areference to the terminal\'s currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project\'s total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n        // Can\'t redeem more tokens that is in the supply.\n        if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();\n        if (_currentOverflow &gt; 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that\'ll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n    // The amount being reclaimed must be within the project\'s balance.\n    if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n    // Remove the reclaimed funds from the project\'s balance.\n    if (reclaimAmount &gt; 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n  /\n    @notice\n    Records newly distributed funds for a project.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the _amount. This must match the project\'s current funding cycle\'s currency.\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n    // Get a reference to the terminal\'s currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n    // Convert the amount to the balance\'s currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value\'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n    // The amount being distributed must be available.\n    if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n    // Removed the distributed funds from the project\'s token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n  /\n    @notice\n    Records newly used allowance funds of a project.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the _amount. Must match the currency of the overflow allowance.\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n    // Get a reference to the terminal\'s currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n    // Convert the amount to this store\'s terminal\'s token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value\'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount &gt;\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n    // Update the project\'s balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n  /\n    @notice\n    Records newly added funds for the project.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n  /\n    @notice\n    Records the migration of funds from this store.\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n    @param _projectId The ID of the project being migrated.\n    @return balance The project\'s migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n  //*********//\n  // --------------------- private helper functions -------------------- //\n  //*********//\n  /\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project\'s ballot redemption rate is used.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n    @return The amount of overflowed tokens that can be reclaimed.\n  /\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle\'s ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n  /\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @param _fundingCycle The ID of the funding cycle to base the overflow on.\n    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n    @return overflow The overflow of funds, as a fixed point number with 18 decimals.\n  /\n  function _overflowDuring(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _balanceCurrency\n  ) private view returns (uint256) {\n    // Get the current balance of the project.\n    uint256 _balanceOf = balanceOf[_terminal][_projectId];\n    // If there\'s no balance, there\'s no overflow.\n    if (_balanceOf == 0) return 0;\n    // Get a reference to the distribution limit during the funding cycle.\n    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n    // Get a reference to the amount still distributable during the funding cycle.\n    uint256 _distributionLimitRemaining = _distributionLimit -\n      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n    // Convert the _distributionRemaining to be in terms of the provided currency.\n    if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)\n      _distributionLimitRemaining = PRBMath.mulDiv(\n        _distributionLimitRemaining,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value\'s fidelity as possible when converting.\n        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n    // Overflow is the balance of this project minus the amount that can still be distributed.\n    return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n  }\n  /\n    @notice\n    Gets the amount that is currently overflowing across all of a project\'s terminals. \n    @dev\n    This amount changes as the value of the balances changes in relation to the currency being used to measure the project\'s distribution limits.\n    @param _projectId The ID of the project to get the total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the overflow should be in terms of.\n    @return overflow The total overflow of a project\'s funds.\n  /\n  function _currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) private view returns (uint256) {\n    // Get a reference to the project\'s terminals.\n    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);\n    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.\n    uint256 _ethOverflow;\n    // Add the current ETH overflow for each terminal.\n    for (uint256 _i = 0; _i &lt; _terminals.length; _i++)\n      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);\n    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.\n    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH\n      ? _ethOverflow\n      : PRBMath.mulDiv(_ethOverflow, 1018, prices.priceFor(JBCurrencies.ETH, _currency, 18));\n    // Adjust the decimals of the fixed point number if needed to match the target decimals.\n    return\n      (_decimals == 18)\n        ? _totalOverflow18Decimal\n        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s analyze the provided Solidity contract and identify potential improvements or enhancements.\n1. Error Handling: The contract uses custom errors for various failure cases, which is a good practice for gas efficiency. However, we could consider adding more descriptive error messages or events to provide better context when errors occur. This could help in debugging and understanding the state of the contract during failures.\n2. Access Control: Currently, the contract does not implement any access control mechanisms for functions that modify state. We could consider using OpenZeppelin\'s Ownable or AccessControl to restrict access to certain functions, ensuring that only authorized addresses can perform sensitive operations.\n3. Gas Optimization: The contract has several mappings and calculations that could be optimized for gas efficiency. For example, we could explore using uint128 or uint64 for certain variables instead of uint256 if the expected values are within those ranges. This could save gas costs during transactions.\n4. Reentrancy Protection: While the contract inherits from ReentrancyGuard, we should ensure that all state-changing functions are properly protected. We could also consider implementing checks-effects-interactions pattern more rigorously to further mitigate reentrancy risks.\n5. Event Emission: The contract could benefit from emitting events for critical state changes, such as payments, redemptions, and distributions. This would enhance transparency and allow for easier tracking of contract activity on the blockchain.\n6. Upgradeability: If the contract is intended to be used for a long time, we might want to consider implementing a proxy pattern for upgradeability. This would allow the contract logic to be updated without losing the state.\n7. Testing and Auditing**: Ensure', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:06:49 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:06:49 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.
  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.
  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;
  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();
  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//
  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;
  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//
  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;
  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;
  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;
  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//
  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.
    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.
    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;
  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.
    @dev
    Increases as projects use their preconfigured distribution limits.
    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.
    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;
  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.
    @dev
    Increases as projects use their allowance.
    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.
    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;
  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//
  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.
    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }
  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.
    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.
    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }
  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.
    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.
    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.
    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());
    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;
    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());
    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;
    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }
  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.
    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.
    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;
    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }
  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//
  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }
  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//
  /**
    @notice
    Records newly contributed tokens to a project.
    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.
    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.
    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();
    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();
    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;
    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }
    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);
    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;
    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);
    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;
    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);
    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }
  /**
    @notice
    Records newly redeemed tokens of a project.
    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.
    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.
    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();
    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;
      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();
        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();
        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();
        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );
        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );
        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();
        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );
        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }
      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }
    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }
  /**
    @notice
    Records newly distributed funds for a project.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 
    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.
    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();
    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;
    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );
    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();
    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();
    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();
    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );
    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;
    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }
  /**
    @notice
    Records newly used allowance funds of a project.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 
    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.
    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;
    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );
    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();
    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();
    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();
    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );
    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;
    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }
  /**
    @notice
    Records newly added funds for the project.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 
    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }
  /**
    @notice
    Records the migration of funds from this store.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.
    @param _projectId The ID of the project being migrated.
    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();
    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];
    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }
  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//
  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.
    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.
    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;
    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();
    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;
    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);
    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;
    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }
  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.
    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.
    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.
    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];
    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;
    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());
    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];
    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );
    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }
  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 
    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.
    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.
    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);
    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;
    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);
    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));
    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.
  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.
  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;
  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();
  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//
  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;
  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//
  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;
  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;
  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;
  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//
  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.
    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.
    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;
  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.
    @dev
    Increases as projects use their preconfigured distribution limits.
    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.
    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;
  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.
    @dev
    Increases as projects use their allowance.
    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.
    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;
  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//
  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.
    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }
  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.
    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.
    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }
  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.
    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.
    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.
    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.
    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());
    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;
    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());
    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;
    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }
  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.
    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.
    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;
    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }
  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//
  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }
  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//
  /**
    @notice
    Records newly contributed tokens to a project.
    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.
    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.
    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();
    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();
    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;
    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }
    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);
    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;
    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);
    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;
    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);
    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }
  /**
    @notice
    Records newly redeemed tokens of a project.
    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.
    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.
    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();
    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;
      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();
        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();
        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();
        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );
        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );
        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();
        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );
        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }
      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }
    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }
  /**
    @notice
    Records newly distributed funds for a project.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 
    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.
    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();
    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;
    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );
    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();
    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();
    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();
    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );
    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;
    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }
  /**
    @notice
    Records newly used allowance funds of a project.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 
    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.
    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;
    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );
    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();
    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();
    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();
    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );
    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;
    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }
  /**
    @notice
    Records newly added funds for the project.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 
    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }
  /**
    @notice
    Records the migration of funds from this store.
    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.
    @param _projectId The ID of the project being migrated.
    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();
    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];
    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }
  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//
  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.
    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.
    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;
    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();
    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;
    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);
    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;
    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }
  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.
    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.
    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.
    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];
    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;
    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());
    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];
    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );
    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }
  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 
    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.
    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.
    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);
    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;
    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);
    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));
    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's analyze the provided Solidity contract and identify potential improvements or enhancements.
1. **Error Handling**: The contract uses custom errors for various failure cases, which is a good practice for gas efficiency. However, we could consider adding more descriptive error messages or events to provide better context when errors occur. This could help in debugging and understanding the state of the contract during failures.
2. **Access Control**: Currently, the contract does not implement any access control mechanisms for functions that modify state. We could consider using OpenZeppelin's `Ownable` or `AccessControl` to restrict access to certain functions, ensuring that only authorized addresses can perform sensitive operations.
3. **Gas Optimization**: The contract has several mappings and calculations that could be optimized for gas efficiency. For example, we could explore using `uint128` or `uint64` for certain variables instead of `uint256` if the expected values are within those ranges. This could save gas costs during transactions.
4. **Reentrancy Protection**: While the contract inherits from `ReentrancyGuard`, we should ensure that all state-changing functions are properly protected. We could also consider implementing checks-effects-interactions pattern more rigorously to further mitigate reentrancy risks.
5. **Event Emission**: The contract could benefit from emitting events for critical state changes, such as payments, redemptions, and distributions. This would enhance transparency and allow for easier tracking of contract activity on the blockchain.
6. **Upgradeability**: If the contract is intended to be used for a long time, we might want to consider implementing a proxy pattern for upgradeability. This would allow the contract logic to be updated without losing the state.
7. **Testing and Auditing**: Ensure Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 17:06:53 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:06:53 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24427
completion_tokens: 1
total_tokens: 24428
cost: $-1.000000


[2024-01-09 17:06:53 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Security

[2024-01-09 17:06:53 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 17:06:53 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 17:06:53 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 17:06:53 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBCurrencies.sol';\nimport './libraries/JBFixedPointNumber.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\n\n/\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********//\n  // -------------------------- private constants ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  /\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  //***********//\n  // --------------------- public stored properties -------------------- //\n  //**********//\n\n  /\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf;\n\n  /\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n\n    @dev\n    Increases as projects use their allowance.\n\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of overflow that project has in the specified terminal.\n  /\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n\n    @return The current total amount of overflow that project has across all terminals.\n  /\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal's currency.\n\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified _terminal.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _terminal.\n  /\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _overflow.\n  /\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  /\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Records newly contributed tokens to a project.\n\n    @dev\n    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The project's funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // If there's no amount being recorded, there's nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n\n    // If there's no weight, token count must be 0 so there's nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n\n    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the _amount.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as weight has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n\n  /\n    @notice\n    Records newly redeemed tokens of a project.\n\n    @dev\n    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n\n    // Scoped section prevents stack too deep. _reclaimedTokenAmount, _currentOverflow, and _totalSupply only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n\n      // Another scoped section prevents stack too deep. _token, _decimals, and _currency only used within scope.\n      {\n        // Get a reference to the terminal's tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n\n        // Get a reference to the terminal's decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n\n        // Get areference to the terminal's currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n\n        // Can't redeem more tokens that is in the supply.\n        if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();\n\n        if (_currentOverflow &gt; 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that'll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n\n    // The amount being reclaimed must be within the project's balance.\n    if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Remove the reclaimed funds from the project's balance.\n    if (reclaimAmount &gt; 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n\n  /\n    @notice\n    Records newly distributed funds for a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the _amount. This must match the project's current funding cycle's currency.\n\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to the balance's currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available.\n    if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n\n    // Removed the distributed funds from the project's token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n\n  /\n    @notice\n    Records newly used allowance funds of a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the _amount. Must match the currency of the overflow allowance.\n\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to this store's terminal's token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount &gt;\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n\n    // Update the project's balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n\n  /\n    @notice\n    Records newly added funds for the project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n\n  /\n    @notice\n    Records the migration of funds from this store.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n\n    @param _projectId The ID of the project being migrated.\n\n    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n\n  //*********//\n  // --------------------- private helper functions -------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n\n    @return The amount of overflowed tokens that can be reclaimed.\n  /\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n\n  /\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @param _fundingCycle The ID of the funding cycle to base the overflow on.\n    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n\n    @return overflow The overflow of funds, as a fixed point number with 18 decimals.\n  /\n  function _overflowDuring(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _balanceCurrency\n  ) private view returns (uint256) {\n    // Get the current balance of the project.\n    uint256 _balanceOf = balanceOf[_terminal][_projectId];\n\n    // If there's no balance, there's no overflow.\n    if (_balanceOf == 0) return 0;\n\n    // Get a reference to the distribution limit during the funding cycle.\n    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n\n    // Get a reference to the amount still distributable during the funding cycle.\n    uint256 _distributionLimitRemaining = _distributionLimit -\n      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n\n    // Convert the _distributionRemaining to be in terms of the provided currency.\n    if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)\n      _distributionLimitRemaining = PRBMath.mulDiv(\n        _distributionLimitRemaining,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // Overflow is the balance of this project minus the amount that can still be distributed.\n    return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n  }\n\n  /\n    @notice\n    Gets the amount that is currently overflowing across all of a project's terminals. \n\n    @dev\n    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.\n\n    @param _projectId The ID of the project to get the total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the overflow should be in terms of.\n\n    @return overflow The total overflow of a project's funds.\n  /\n  function _currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) private view returns (uint256) {\n    // Get a reference to the project's terminals.\n    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);\n\n    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.\n    uint256 _ethOverflow;\n\n    // Add the current ETH overflow for each terminal.\n    for (uint256 _i = 0; _i &lt; _terminals.length; _i++)\n      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);\n\n    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.\n    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH\n      ? _ethOverflow\n      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));\n\n    // Adjust the decimals of the fixed point number if needed to match the target decimals.\n    return\n      (_decimals == 18)\n        ? _totalOverflow18Decimal\n        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:06:53 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:06:53 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:06:59 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:06:59 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16003
completion_tokens: 362
total_tokens: 16365
cost: $-1.000000


[2024-01-09 17:06:59 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

### REENTRANCY VULNERABILITY
```
DETAILED DESCRIPTION: While the contract inherits from `ReentrancyGuard`, which is designed to prevent reentrant calls, there are still areas where reentrancy could potentially be exploited. For example, in functions like `recordPaymentFrom`, `recordRedemptionFor`, and `recordDistributionFor`, the state changes (like updating balances) occur after external calls (like calling the data source). If an attacker can manipulate the flow of control through these external calls, they could exploit this to re-enter the function before the state is updated.

RECOMMENDED MITIGATION: Ensure that all state changes occur before any external calls. This can be achieved by reordering the logic in these functions to update the state first and then perform any external calls.
```

### INSUFFICIENT VALIDATION OF INPUTS
```
DETAILED DESCRIPTION: The contract does not sufficiently validate inputs in several functions. For example, in `recordPaymentFrom`, `_amount.value` is checked for zero, but there are no checks to ensure that the `_amount` structure is valid (e.g., checking if the currency is supported or if the decimals are within expected limits). This could lead to unexpected behavior or errors during execution.

RECOMMENDED MITIGATION: Implement comprehensive validation checks for all inputs, ensuring that they conform to expected formats and values before processing them. This includes checking for valid currencies, ensuring that decimals are within a reasonable range, and validating that the project ID exists.
```

### ARITHMETIC OVERFLOW/UNDERFLOW
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially when dealing with fixed

[2024-01-09 17:06:59 INFO] **[Seminar Conclusion]**:

 ### REENTRANCY VULNERABILITY
```
DETAILED DESCRIPTION: While the contract inherits from `ReentrancyGuard`, which is designed to prevent reentrant calls, there are still areas where reentrancy could potentially be exploited. For example, in functions like `recordPaymentFrom`, `recordRedemptionFor`, and `recordDistributionFor`, the state changes (like updating balances) occur after external calls (like calling the data source). If an attacker can manipulate the flow of control through these external calls, they could exploit this to re-enter the function before the state is updated.

RECOMMENDED MITIGATION: Ensure that all state changes occur before any external calls. This can be achieved by reordering the logic in these functions to update the state first and then perform any external calls.
```

### INSUFFICIENT VALIDATION OF INPUTS
```
DETAILED DESCRIPTION: The contract does not sufficiently validate inputs in several functions. For example, in `recordPaymentFrom`, `_amount.value` is checked for zero, but there are no checks to ensure that the `_amount` structure is valid (e.g., checking if the currency is supported or if the decimals are within expected limits). This could lead to unexpected behavior or errors during execution.

RECOMMENDED MITIGATION: Implement comprehensive validation checks for all inputs, ensuring that they conform to expected formats and values before processing them. This includes checking for valid currencies, ensuring that decimals are within a reasonable range, and validating that the project ID exists.
```

### ARITHMETIC OVERFLOW/UNDERFLOW
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially when dealing with fixed

[2024-01-09 17:06:59 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 17:06:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:06:59 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:06:59 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:07:11 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:07:11 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8061
completion_tokens: 885
total_tokens: 8946
cost: $-1.000000


[2024-01-09 17:07:11 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Based on the provided Solidity smart contract code for `JBSingleTokenPaymentTerminalStore`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which helps prevent reentrant calls, it is crucial to ensure that all external calls are properly guarded. Any function that modifies state variables and calls external contracts should be carefully reviewed to ensure that reentrancy cannot occur.

2. **Insufficient Input Validation**:
   - The contract relies on external contracts (like `IJBController` and `IJBFundingCycleStore`) for critical operations. If these contracts are compromised or behave unexpectedly, it may lead to vulnerabilities. Input validation should be reinforced to ensure that the data being processed is valid and adheres to expected formats.

3. **Arithmetic Operations**:
   - The contract uses fixed-point arithmetic with the `PRBMath` library, which is generally safe. However, care must be taken to ensure that all arithmetic operations are checked for overflow and underflow, especially when dealing with user inputs or external data.

4. **Access Control**:
   - The contract does not explicitly define access control for certain functions. While it assumes that only `IJBSingleTokenPaymentTerminal` can call certain functions, it is essential to implement explicit checks to prevent unauthorized access.

5. **Error Handling**:
   - The contract uses custom errors for handling exceptions. While this is a good practice, it is important to ensure that all potential failure points are covered, and that the errors provide sufficient context for debugging.

6. **Currency Conversion Risks**:
   - The contract performs currency conversions using external price feeds. If these price feeds are manipulated or provide incorrect data, it could lead to significant financial losses. It is advisable to implement checks or fallback mechanisms to handle unexpected price feed behavior.

7. **State Variable Visibility**:
   - Some state variables are public but may expose sensitive information. It is essential to review the visibility of state variables and ensure that only necessary data is exposed to external contracts or users.

8. **Lack of Upgradeability**:
   - The contract does not incorporate any upgradeability mechanisms. If a vulnerability is discovered post-deployment, there would be no way to patch the contract without a complete redeployment, which could lead to loss of funds or functionality.

### Comprehensive Analysis Report

The `JBSingleTokenPaymentTerminalStore` contract is a complex financial contract that manages the inflows and outflows of funds for projects. While it employs several best practices, such as using the `ReentrancyGuard` and the `PRBMath` library for fixed-point arithmetic, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Although the contract uses `ReentrancyGuard`, it is essential to ensure that all external calls are properly guarded. Review all functions that modify state and call external contracts to ensure they are not vulnerable to reentrancy attacks.

2. **Input Validation and Access Control**: The reliance on external contracts necessitates robust input validation and explicit access control checks to prevent unauthorized access and ensure data integrity.

3. **Arithmetic Safety**: While the use of fixed-point arithmetic is generally safe, it is crucial to ensure that all arithmetic operations are checked for potential overflow or underflow conditions.

4. **Error Handling**: The use of custom errors is a good practice, but it is vital to ensure that all potential failure points are covered and that errors provide sufficient context for debugging.

5. **Currency Conversion Risks**: Given the reliance on external price feeds for currency conversions, it is advisable to implement checks or fallback mechanisms to handle unexpected price feed behavior.

6. **State Variable Visibility**: Review the visibility of state variables to ensure that sensitive information is not unnecessarily exposed.

7. **Upgradeability**: The lack of upgradeability mechanisms poses a risk in the event of a discovered vulnerability. Consider implementing a proxy pattern or similar upgradeability mechanism to allow for future updates.

In conclusion, while the `JBSingleTokenPaymentTerminalStore` contract demonstrates a solid foundation, addressing the identified vulnerabilities will enhance its security posture and ensure the safety of funds managed by the contract. It is recommended to conduct a thorough security audit and implement the necessary changes before deployment.

[2024-01-09 17:07:11 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for `JBSingleTokenPaymentTerminalStore`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which helps prevent reentrant calls, it is crucial to ensure that all external calls are properly guarded. Any function that modifies state variables and calls external contracts should be carefully reviewed to ensure that reentrancy cannot occur.

2. **Insufficient Input Validation**:
   - The contract relies on external contracts (like `IJBController` and `IJBFundingCycleStore`) for critical operations. If these contracts are compromised or behave unexpectedly, it may lead to vulnerabilities. Input validation should be reinforced to ensure that the data being processed is valid and adheres to expected formats.

3. **Arithmetic Operations**:
   - The contract uses fixed-point arithmetic with the `PRBMath` library, which is generally safe. However, care must be taken to ensure that all arithmetic operations are checked for overflow and underflow, especially when dealing with user inputs or external data.

4. **Access Control**:
   - The contract does not explicitly define access control for certain functions. While it assumes that only `IJBSingleTokenPaymentTerminal` can call certain functions, it is essential to implement explicit checks to prevent unauthorized access.

5. **Error Handling**:
   - The contract uses custom errors for handling exceptions. While this is a good practice, it is important to ensure that all potential failure points are covered, and that the errors provide sufficient context for debugging.

6. **Currency Conversion Risks**:
   - The contract performs currency conversions using external price feeds. If these price feeds are manipulated or provide incorrect data, it could lead to significant financial losses. It is advisable to implement checks or fallback mechanisms to handle unexpected price feed behavior.

7. **State Variable Visibility**:
   - Some state variables are public but may expose sensitive information. It is essential to review the visibility of state variables and ensure that only necessary data is exposed to external contracts or users.

8. **Lack of Upgradeability**:
   - The contract does not incorporate any upgradeability mechanisms. If a vulnerability is discovered post-deployment, there would be no way to patch the contract without a complete redeployment, which could lead to loss of funds or functionality.

### Comprehensive Analysis Report

The `JBSingleTokenPaymentTerminalStore` contract is a complex financial contract that manages the inflows and outflows of funds for projects. While it employs several best practices, such as using the `ReentrancyGuard` and the `PRBMath` library for fixed-point arithmetic, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Although the contract uses `ReentrancyGuard`, it is essential to ensure that all external calls are properly guarded. Review all functions that modify state and call external contracts to ensure they are not vulnerable to reentrancy attacks.

2. **Input Validation and Access Control**: The reliance on external contracts necessitates robust input validation and explicit access control checks to prevent unauthorized access and ensure data integrity.

3. **Arithmetic Safety**: While the use of fixed-point arithmetic is generally safe, it is crucial to ensure that all arithmetic operations are checked for potential overflow or underflow conditions.

4. **Error Handling**: The use of custom errors is a good practice, but it is vital to ensure that all potential failure points are covered and that errors provide sufficient context for debugging.

5. **Currency Conversion Risks**: Given the reliance on external price feeds for currency conversions, it is advisable to implement checks or fallback mechanisms to handle unexpected price feed behavior.

6. **State Variable Visibility**: Review the visibility of state variables to ensure that sensitive information is not unnecessarily exposed.

7. **Upgradeability**: The lack of upgradeability mechanisms poses a risk in the event of a discovered vulnerability. Consider implementing a proxy pattern or similar upgradeability mechanism to allow for future updates.

In conclusion, while the `JBSingleTokenPaymentTerminalStore` contract demonstrates a solid foundation, addressing the identified vulnerabilities will enhance its security posture and ensure the safety of funds managed by the contract. It is recommended to conduct a thorough security audit and implement the necessary changes before deployment.

[2024-01-09 17:07:11 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 17:07:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBCurrencies.sol';\nimport './libraries/JBFixedPointNumber.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\n\n/\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********//\n  // -------------------------- private constants ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  /\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  //***********//\n  // --------------------- public stored properties -------------------- //\n  //**********//\n\n  /\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf;\n\n  /\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n\n    @dev\n    Increases as projects use their allowance.\n\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of overflow that project has in the specified terminal.\n  /\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n\n    @return The current total amount of overflow that project has across all terminals.\n  /\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal's currency.\n\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified _terminal.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _terminal.\n  /\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _overflow.\n  /\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  /\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Records newly contributed tokens to a project.\n\n    @dev\n    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The project's funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // If there's no amount being recorded, there's nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n\n    // If there's no weight, token count must be 0 so there's nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n\n    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the _amount.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as weight has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n\n  /\n    @notice\n    Records newly redeemed tokens of a project.\n\n    @dev\n    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n\n    // Scoped section prevents stack too deep. _reclaimedTokenAmount, _currentOverflow, and _totalSupply only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n\n      // Another scoped section prevents stack too deep. _token, _decimals, and _currency only used within scope.\n      {\n        // Get a reference to the terminal's tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n\n        // Get a reference to the terminal's decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n\n        // Get areference to the terminal's currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n\n        // Can't redeem more tokens that is in the supply.\n        if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();\n\n        if (_currentOverflow &gt; 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that'll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n\n    // The amount being reclaimed must be within the project's balance.\n    if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Remove the reclaimed funds from the project's balance.\n    if (reclaimAmount &gt; 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n\n  /\n    @notice\n    Records newly distributed funds for a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the _amount. This must match the project's current funding cycle's currency.\n\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to the balance's currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available.\n    if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n\n    // Removed the distributed funds from the project's token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n\n  /\n    @notice\n    Records newly used allowance funds of a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the _amount. Must match the currency of the overflow allowance.\n\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to this store's terminal's token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount &gt;\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n\n    // Update the project's balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n\n  /\n    @notice\n    Records newly added funds for the project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n\n  /\n    @notice\n    Records the migration of funds from this store.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n\n    @param _projectId The ID of the project being migrated.\n\n    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n\n  //*********//\n  // --------------------- private helper functions -------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n\n    @return The amount of overflowed tokens that can be reclaimed.\n  /\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n\n  /\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @param _fundingCycle The ID of the funding cycle to base the overflow on.\n    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n\n    @return overflow The overflow of funds, as a fixed point number with 18 decimals.\n  /\n  function _overflowDuring(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _balanceCurrency\n  ) private view returns (uint256) {\n    // Get the current balance of the project.\n    uint256 _balanceOf = balanceOf[_terminal][_projectId];\n\n    // If there's no balance, there's no overflow.\n    if (_balanceOf == 0) return 0;\n\n    // Get a reference to the distribution limit during the funding cycle.\n    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n\n    // Get a reference to the amount still distributable during the funding cycle.\n    uint256 _distributionLimitRemaining = _distributionLimit -\n      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n\n    // Convert the _distributionRemaining to be in terms of the provided currency.\n    if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)\n      _distributionLimitRemaining = PRBMath.mulDiv(\n        _distributionLimitRemaining,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // Overflow is the balance of this project minus the amount that can still be distributed.\n    return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n  }\n\n  /\n    @notice\n    Gets the amount that is currently overflowing across all of a project's terminals. \n\n    @dev\n    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.\n\n    @param _projectId The ID of the project to get the total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the overflow should be in terms of.\n\n    @return overflow The total overflow of a project's funds.\n  /\n  function _currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) private view returns (uint256) {\n    // Get a reference to the project's terminals.\n    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);\n\n    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.\n    uint256 _ethOverflow;\n\n    // Add the current ETH overflow for each terminal.\n    for (uint256 _i = 0; _i &lt; _terminals.length; _i++)\n      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);\n\n    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.\n    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH\n      ? _ethOverflow\n      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));\n\n    // Adjust the decimals of the fixed point number if needed to match the target decimals.\n    return\n      (_decimals == 18)\n        ? _totalOverflow18Decimal\n        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:07:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:07:11 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:07:17 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:07:17 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16003
completion_tokens: 362
total_tokens: 16365
cost: $-1.000000


[2024-01-09 17:07:17 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: 
The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` to prevent reentrant calls to functions that modify state. However, there are still functions that could potentially be exploited if not properly guarded. For instance, the `recordPaymentFrom`, `recordRedemptionFor`, and `recordDistributionFor` functions modify the state after external calls (e.g., calling the data source). If an attacker can manipulate the external call, they could re-enter the function and exploit the state changes.

RECOMMENDED MITIGATION:
Ensure that all state changes occur before any external calls. This way, even if an external call is made, the state cannot be manipulated by a reentrant call. Additionally, consider using checks-effects-interactions pattern consistently across all functions.
```

### VULNERABILITY: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: 
Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all arithmetic operations are safe. The contract performs several arithmetic operations, such as in `recordPaymentFrom`, `recordDistributionFor`, and `recordUsedAllowanceOf`. If any of these operations are not properly checked, they could lead to unexpected behavior.

RECOMMENDED MITIGATION:
Review all arithmetic operations to ensure they are safe. Consider using SafeMath libraries for clarity, even though Solidity 0.8.x has built-in checks. Explicitly check for conditions that could lead to underflows or overflows before performing operations.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: 
The contract relies on the `msg.sender` to be an instance of `IJBS

[2024-01-09 17:07:17 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: 
The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` to prevent reentrant calls to functions that modify state. However, there are still functions that could potentially be exploited if not properly guarded. For instance, the `recordPaymentFrom`, `recordRedemptionFor`, and `recordDistributionFor` functions modify the state after external calls (e.g., calling the data source). If an attacker can manipulate the external call, they could re-enter the function and exploit the state changes.

RECOMMENDED MITIGATION:
Ensure that all state changes occur before any external calls. This way, even if an external call is made, the state cannot be manipulated by a reentrant call. Additionally, consider using checks-effects-interactions pattern consistently across all functions.
```

### VULNERABILITY: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: 
Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all arithmetic operations are safe. The contract performs several arithmetic operations, such as in `recordPaymentFrom`, `recordDistributionFor`, and `recordUsedAllowanceOf`. If any of these operations are not properly checked, they could lead to unexpected behavior.

RECOMMENDED MITIGATION:
Review all arithmetic operations to ensure they are safe. Consider using SafeMath libraries for clarity, even though Solidity 0.8.x has built-in checks. Explicitly check for conditions that could lead to underflows or overflows before performing operations.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: 
The contract relies on the `msg.sender` to be an instance of `IJBS

[2024-01-09 17:07:17 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 17:07:17 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:07:17 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:07:17 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:07:28 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:07:28 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8061
completion_tokens: 890
total_tokens: 8951
cost: $-1.000000


[2024-01-09 17:07:28 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Based on the provided smart contract code for `JBSingleTokenPaymentTerminalStore`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, it is crucial to ensure that all external calls are properly guarded. Any function that modifies state and calls external contracts should be carefully reviewed to prevent reentrant attacks.

2. **Error Handling**:
   - The contract uses custom errors for various failure conditions. While this is a good practice for gas efficiency, it is essential to ensure that all error conditions are adequately tested and that the error messages provide sufficient context for debugging.

3. **Arithmetic Operations**:
   - The contract uses fixed-point arithmetic via the `PRBMath` library. While this library is designed to prevent overflow and underflow, it is essential to ensure that all arithmetic operations are thoroughly tested to avoid unexpected behavior due to precision issues.

4. **Access Control**:
   - The contract relies on the `msg.sender` to determine the caller's identity. It is important to ensure that only authorized contracts (i.e., `IJBSingleTokenPaymentTerminal`) can call certain functions. Any oversight in access control could lead to unauthorized access and manipulation of funds.

5. **Currency Mismatch**:
   - The contract checks for currency mismatches in several functions. It is crucial to ensure that these checks are comprehensive and that all currency conversions are handled correctly to avoid loss of funds.

6. **State Variable Visibility**:
   - Some state variables are public but may expose sensitive information. It is advisable to review the visibility of state variables to ensure that only necessary information is exposed to external contracts and users.

7. **Gas Limit and Loops**:
   - The contract contains loops (e.g., in `_currentTotalOverflowOf`) that iterate over arrays. If the size of these arrays can grow large, it could lead to exceeding the gas limit. This should be monitored and optimized if necessary.

8. **Fallback Function**:
   - The contract does not implement a fallback function. If the contract needs to receive Ether or handle unexpected calls, a fallback function should be implemented to manage such scenarios.

### Comprehensive Analysis Report:

The `JBSingleTokenPaymentTerminalStore` contract demonstrates a well-structured approach to managing funds and token distributions. However, several security vulnerabilities need to be addressed to enhance the contract's robustness:

- **Reentrancy Protection**: While the use of `ReentrancyGuard` is a positive step, it is essential to ensure that all external calls are properly guarded to prevent potential reentrancy attacks. This includes reviewing all functions that modify state and call external contracts.

- **Error Handling and Testing**: The use of custom errors is efficient, but thorough testing is necessary to ensure that all error conditions are handled gracefully. Developers should ensure that error messages provide sufficient context for debugging.

- **Arithmetic Precision**: The reliance on fixed-point arithmetic necessitates rigorous testing to avoid precision-related issues. Developers should ensure that all arithmetic operations are correctly implemented and tested.

- **Access Control**: The contract must enforce strict access control to prevent unauthorized access to sensitive functions. Developers should review the logic surrounding `msg.sender` to ensure only authorized contracts can interact with the contract.

- **Currency Handling**: The contract performs several currency checks, which are critical for maintaining the integrity of fund transfers. Developers should ensure that all currency conversions are handled correctly to prevent loss of funds.

- **State Variable Management**: The visibility of state variables should be reviewed to minimize exposure of sensitive information. Developers should implement appropriate access controls to protect sensitive data.

- **Gas Limit Considerations**: The potential for gas limit issues due to loops should be monitored. Developers should optimize loops and consider alternative approaches if necessary.

- **Fallback Function Implementation**: The absence of a fallback function may limit the contract's ability to handle unexpected calls or receive Ether. Developers should consider implementing a fallback function to manage such scenarios effectively.

In conclusion, while the `JBSingleTokenPaymentTerminalStore` contract is well-designed, addressing the identified vulnerabilities will significantly enhance its security and reliability. It is recommended that the development team conducts thorough testing, including unit tests and integration tests, to ensure that all functionalities work as intended and that security measures are effectively implemented.

[2024-01-09 17:07:28 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for `JBSingleTokenPaymentTerminalStore`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, it is crucial to ensure that all external calls are properly guarded. Any function that modifies state and calls external contracts should be carefully reviewed to prevent reentrant attacks.

2. **Error Handling**:
   - The contract uses custom errors for various failure conditions. While this is a good practice for gas efficiency, it is essential to ensure that all error conditions are adequately tested and that the error messages provide sufficient context for debugging.

3. **Arithmetic Operations**:
   - The contract uses fixed-point arithmetic via the `PRBMath` library. While this library is designed to prevent overflow and underflow, it is essential to ensure that all arithmetic operations are thoroughly tested to avoid unexpected behavior due to precision issues.

4. **Access Control**:
   - The contract relies on the `msg.sender` to determine the caller's identity. It is important to ensure that only authorized contracts (i.e., `IJBSingleTokenPaymentTerminal`) can call certain functions. Any oversight in access control could lead to unauthorized access and manipulation of funds.

5. **Currency Mismatch**:
   - The contract checks for currency mismatches in several functions. It is crucial to ensure that these checks are comprehensive and that all currency conversions are handled correctly to avoid loss of funds.

6. **State Variable Visibility**:
   - Some state variables are public but may expose sensitive information. It is advisable to review the visibility of state variables to ensure that only necessary information is exposed to external contracts and users.

7. **Gas Limit and Loops**:
   - The contract contains loops (e.g., in `_currentTotalOverflowOf`) that iterate over arrays. If the size of these arrays can grow large, it could lead to exceeding the gas limit. This should be monitored and optimized if necessary.

8. **Fallback Function**:
   - The contract does not implement a fallback function. If the contract needs to receive Ether or handle unexpected calls, a fallback function should be implemented to manage such scenarios.

### Comprehensive Analysis Report:

The `JBSingleTokenPaymentTerminalStore` contract demonstrates a well-structured approach to managing funds and token distributions. However, several security vulnerabilities need to be addressed to enhance the contract's robustness:

- **Reentrancy Protection**: While the use of `ReentrancyGuard` is a positive step, it is essential to ensure that all external calls are properly guarded to prevent potential reentrancy attacks. This includes reviewing all functions that modify state and call external contracts.

- **Error Handling and Testing**: The use of custom errors is efficient, but thorough testing is necessary to ensure that all error conditions are handled gracefully. Developers should ensure that error messages provide sufficient context for debugging.

- **Arithmetic Precision**: The reliance on fixed-point arithmetic necessitates rigorous testing to avoid precision-related issues. Developers should ensure that all arithmetic operations are correctly implemented and tested.

- **Access Control**: The contract must enforce strict access control to prevent unauthorized access to sensitive functions. Developers should review the logic surrounding `msg.sender` to ensure only authorized contracts can interact with the contract.

- **Currency Handling**: The contract performs several currency checks, which are critical for maintaining the integrity of fund transfers. Developers should ensure that all currency conversions are handled correctly to prevent loss of funds.

- **State Variable Management**: The visibility of state variables should be reviewed to minimize exposure of sensitive information. Developers should implement appropriate access controls to protect sensitive data.

- **Gas Limit Considerations**: The potential for gas limit issues due to loops should be monitored. Developers should optimize loops and consider alternative approaches if necessary.

- **Fallback Function Implementation**: The absence of a fallback function may limit the contract's ability to handle unexpected calls or receive Ether. Developers should consider implementing a fallback function to manage such scenarios effectively.

In conclusion, while the `JBSingleTokenPaymentTerminalStore` contract is well-designed, addressing the identified vulnerabilities will significantly enhance its security and reliability. It is recommended that the development team conducts thorough testing, including unit tests and integration tests, to ensure that all functionalities work as intended and that security measures are effectively implemented.

[2024-01-09 17:07:28 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 17:07:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBCurrencies.sol';\nimport './libraries/JBFixedPointNumber.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\n\n/\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********//\n  // -------------------------- private constants ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  /\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  //***********//\n  // --------------------- public stored properties -------------------- //\n  //**********//\n\n  /\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf;\n\n  /\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n\n    @dev\n    Increases as projects use their allowance.\n\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of overflow that project has in the specified terminal.\n  /\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n\n    @return The current total amount of overflow that project has across all terminals.\n  /\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal's currency.\n\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified _terminal.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _terminal.\n  /\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _overflow.\n  /\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  /\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Records newly contributed tokens to a project.\n\n    @dev\n    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The project's funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // If there's no amount being recorded, there's nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n\n    // If there's no weight, token count must be 0 so there's nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n\n    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the _amount.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as weight has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n\n  /\n    @notice\n    Records newly redeemed tokens of a project.\n\n    @dev\n    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n\n    // Scoped section prevents stack too deep. _reclaimedTokenAmount, _currentOverflow, and _totalSupply only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n\n      // Another scoped section prevents stack too deep. _token, _decimals, and _currency only used within scope.\n      {\n        // Get a reference to the terminal's tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n\n        // Get a reference to the terminal's decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n\n        // Get areference to the terminal's currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n\n        // Can't redeem more tokens that is in the supply.\n        if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();\n\n        if (_currentOverflow &gt; 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that'll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n\n    // The amount being reclaimed must be within the project's balance.\n    if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Remove the reclaimed funds from the project's balance.\n    if (reclaimAmount &gt; 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n\n  /\n    @notice\n    Records newly distributed funds for a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the _amount. This must match the project's current funding cycle's currency.\n\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to the balance's currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available.\n    if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n\n    // Removed the distributed funds from the project's token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n\n  /\n    @notice\n    Records newly used allowance funds of a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the _amount. Must match the currency of the overflow allowance.\n\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to this store's terminal's token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount &gt;\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n\n    // Update the project's balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n\n  /\n    @notice\n    Records newly added funds for the project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n\n  /\n    @notice\n    Records the migration of funds from this store.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n\n    @param _projectId The ID of the project being migrated.\n\n    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n\n  //*********//\n  // --------------------- private helper functions -------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n\n    @return The amount of overflowed tokens that can be reclaimed.\n  /\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n\n  /\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @param _fundingCycle The ID of the funding cycle to base the overflow on.\n    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n\n    @return overflow The overflow of funds, as a fixed point number with 18 decimals.\n  /\n  function _overflowDuring(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _balanceCurrency\n  ) private view returns (uint256) {\n    // Get the current balance of the project.\n    uint256 _balanceOf = balanceOf[_terminal][_projectId];\n\n    // If there's no balance, there's no overflow.\n    if (_balanceOf == 0) return 0;\n\n    // Get a reference to the distribution limit during the funding cycle.\n    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n\n    // Get a reference to the amount still distributable during the funding cycle.\n    uint256 _distributionLimitRemaining = _distributionLimit -\n      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n\n    // Convert the _distributionRemaining to be in terms of the provided currency.\n    if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)\n      _distributionLimitRemaining = PRBMath.mulDiv(\n        _distributionLimitRemaining,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // Overflow is the balance of this project minus the amount that can still be distributed.\n    return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n  }\n\n  /\n    @notice\n    Gets the amount that is currently overflowing across all of a project's terminals. \n\n    @dev\n    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.\n\n    @param _projectId The ID of the project to get the total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the overflow should be in terms of.\n\n    @return overflow The total overflow of a project's funds.\n  /\n  function _currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) private view returns (uint256) {\n    // Get a reference to the project's terminals.\n    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);\n\n    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.\n    uint256 _ethOverflow;\n\n    // Add the current ETH overflow for each terminal.\n    for (uint256 _i = 0; _i &lt; _terminals.length; _i++)\n      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);\n\n    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.\n    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH\n      ? _ethOverflow\n      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));\n\n    // Adjust the decimals of the fixed point number if needed to match the target decimals.\n    return\n      (_decimals == 18)\n        ? _totalOverflow18Decimal\n        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:07:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:07:28 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:07:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:07:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16003
completion_tokens: 362
total_tokens: 16365
cost: $-1.000000


[2024-01-09 17:07:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: 
The contract inherits from `ReentrancyGuard`, which is a good practice to prevent reentrancy attacks. However, it is crucial to ensure that all external calls are made after state changes. In the `recordRedemptionFor`, `recordDistributionFor`, and `recordUsedAllowanceOf` functions, the contract modifies the state (e.g., updating balances) after making external calls (e.g., calling the data source). If the data source is malicious, it could exploit this to re-enter the contract and manipulate the state.

RECOMMENDED MITIGATION:
Ensure that all state changes are made before any external calls. For example, in `recordRedemptionFor`, update the balance before calling the data source to prevent reentrancy.
```

### VULNERABILITY 2: Arithmetic Overflow/Underflow
```
DETAILED DESCRIPTION:
Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all arithmetic operations are safe. In functions like `recordPaymentFrom`, `recordDistributionFor`, and others, there are multiple arithmetic operations that could potentially lead to unexpected behavior if not handled correctly, especially when dealing with user inputs.

RECOMMENDED MITIGATION:
Use SafeMath or ensure that all arithmetic operations are validated before execution. For example, check that the resulting value of any addition or subtraction does not exceed the maximum or minimum limits of the data type.
```

### VULNERABILITY 3: Incorrect Currency Handling
```
DETAILED DESCRIPTION:
The contract relies on the currency being passed correctly in various functions. If a user or a malicious actor passes an incorrect currency, it could lead to unexpected behavior or loss of

[2024-01-09 17:07:35 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: 
The contract inherits from `ReentrancyGuard`, which is a good practice to prevent reentrancy attacks. However, it is crucial to ensure that all external calls are made after state changes. In the `recordRedemptionFor`, `recordDistributionFor`, and `recordUsedAllowanceOf` functions, the contract modifies the state (e.g., updating balances) after making external calls (e.g., calling the data source). If the data source is malicious, it could exploit this to re-enter the contract and manipulate the state.

RECOMMENDED MITIGATION:
Ensure that all state changes are made before any external calls. For example, in `recordRedemptionFor`, update the balance before calling the data source to prevent reentrancy.
```

### VULNERABILITY 2: Arithmetic Overflow/Underflow
```
DETAILED DESCRIPTION:
Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all arithmetic operations are safe. In functions like `recordPaymentFrom`, `recordDistributionFor`, and others, there are multiple arithmetic operations that could potentially lead to unexpected behavior if not handled correctly, especially when dealing with user inputs.

RECOMMENDED MITIGATION:
Use SafeMath or ensure that all arithmetic operations are validated before execution. For example, check that the resulting value of any addition or subtraction does not exceed the maximum or minimum limits of the data type.
```

### VULNERABILITY 3: Incorrect Currency Handling
```
DETAILED DESCRIPTION:
The contract relies on the currency being passed correctly in various functions. If a user or a malicious actor passes an incorrect currency, it could lead to unexpected behavior or loss of

[2024-01-09 17:07:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 17:07:36 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:07:36 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:07:36 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:07:45 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:07:45 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8061
completion_tokens: 788
total_tokens: 8849
cost: $-1.000000


[2024-01-09 17:07:45 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Based on the provided smart contract code for `JBSingleTokenPaymentTerminalStore`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which provides protection against reentrant calls, it is crucial to ensure that all external calls are properly guarded. If any function that modifies state variables calls an external contract without proper checks, it could lead to reentrancy attacks.

2. **Insufficient Input Validation**:
   - The contract relies on external contracts (like `IJBController`, `IJBFundingCycleStore`, etc.) for critical operations. If these contracts have vulnerabilities or do not validate inputs correctly, it could lead to unexpected behaviors or exploits.

3. **Arithmetic Overflow/Underflow**:
   - While Solidity 0.8.x has built-in overflow and underflow protection, it is essential to ensure that all arithmetic operations are correctly handled, especially in functions that involve financial calculations. Any oversight could lead to loss of funds.

4. **Access Control Issues**:
   - The contract does not explicitly define access control for certain functions. For instance, functions like `recordPaymentFrom`, `recordRedemptionFor`, etc., should ensure that only authorized terminals can invoke them. Lack of proper access control could lead to unauthorized actions.

5. **Currency Mismatch**:
   - The contract checks for currency mismatches in several functions. However, if the external contracts do not enforce currency consistency, it could lead to incorrect calculations and potential financial loss.

6. **Gas Limit and Loops**:
   - The use of loops (e.g., in `_currentTotalOverflowOf`) could lead to gas limit issues if the number of terminals grows significantly. This could result in failed transactions or denial of service.

7. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events. This lack of transparency could hinder tracking and auditing of contract activities, making it difficult to detect malicious activities or errors.

8. **Potential for Front-Running**:
   - Functions that involve financial transactions could be susceptible to front-running attacks. An attacker could observe pending transactions and submit their own transactions with higher gas prices to exploit the situation.

### Comprehensive Analysis Report:

The `JBSingleTokenPaymentTerminalStore` contract is a complex financial contract that manages the inflows and outflows of funds for projects. While it incorporates several best practices, including the use of OpenZeppelin's `ReentrancyGuard`, there are notable vulnerabilities that need to be addressed to ensure the contract's security and reliability.

1. **Reentrancy Protection**: While the contract uses `ReentrancyGuard`, it is essential to ensure that all external calls are properly managed to prevent potential reentrancy attacks.

2. **Input Validation and Access Control**: The reliance on external contracts necessitates rigorous input validation and access control mechanisms to prevent unauthorized access and ensure that only valid data is processed.

3. **Arithmetic Operations**: Although Solidity provides built-in protections, careful attention must be paid to arithmetic operations to avoid any unintended consequences.

4. **Event Emission**: Implementing event emissions for all state-changing functions will enhance transparency and facilitate better tracking of contract activities.

5. **Gas Limit Considerations**: The potential for gas limit issues due to loops should be mitigated by considering alternative designs or limiting the number of iterations.

6. **Front-Running Risks**: Strategies to mitigate front-running risks should be considered, especially for functions that involve financial transactions.

In conclusion, while the `JBSingleTokenPaymentTerminalStore` contract demonstrates a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough review and testing phase, including the implementation of best practices for security and access control, are recommended before deployment.

[2024-01-09 17:07:45 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for `JBSingleTokenPaymentTerminalStore`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract inherits from `ReentrancyGuard`, which provides protection against reentrant calls, it is crucial to ensure that all external calls are properly guarded. If any function that modifies state variables calls an external contract without proper checks, it could lead to reentrancy attacks.

2. **Insufficient Input Validation**:
   - The contract relies on external contracts (like `IJBController`, `IJBFundingCycleStore`, etc.) for critical operations. If these contracts have vulnerabilities or do not validate inputs correctly, it could lead to unexpected behaviors or exploits.

3. **Arithmetic Overflow/Underflow**:
   - While Solidity 0.8.x has built-in overflow and underflow protection, it is essential to ensure that all arithmetic operations are correctly handled, especially in functions that involve financial calculations. Any oversight could lead to loss of funds.

4. **Access Control Issues**:
   - The contract does not explicitly define access control for certain functions. For instance, functions like `recordPaymentFrom`, `recordRedemptionFor`, etc., should ensure that only authorized terminals can invoke them. Lack of proper access control could lead to unauthorized actions.

5. **Currency Mismatch**:
   - The contract checks for currency mismatches in several functions. However, if the external contracts do not enforce currency consistency, it could lead to incorrect calculations and potential financial loss.

6. **Gas Limit and Loops**:
   - The use of loops (e.g., in `_currentTotalOverflowOf`) could lead to gas limit issues if the number of terminals grows significantly. This could result in failed transactions or denial of service.

7. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events. This lack of transparency could hinder tracking and auditing of contract activities, making it difficult to detect malicious activities or errors.

8. **Potential for Front-Running**:
   - Functions that involve financial transactions could be susceptible to front-running attacks. An attacker could observe pending transactions and submit their own transactions with higher gas prices to exploit the situation.

### Comprehensive Analysis Report:

The `JBSingleTokenPaymentTerminalStore` contract is a complex financial contract that manages the inflows and outflows of funds for projects. While it incorporates several best practices, including the use of OpenZeppelin's `ReentrancyGuard`, there are notable vulnerabilities that need to be addressed to ensure the contract's security and reliability.

1. **Reentrancy Protection**: While the contract uses `ReentrancyGuard`, it is essential to ensure that all external calls are properly managed to prevent potential reentrancy attacks.

2. **Input Validation and Access Control**: The reliance on external contracts necessitates rigorous input validation and access control mechanisms to prevent unauthorized access and ensure that only valid data is processed.

3. **Arithmetic Operations**: Although Solidity provides built-in protections, careful attention must be paid to arithmetic operations to avoid any unintended consequences.

4. **Event Emission**: Implementing event emissions for all state-changing functions will enhance transparency and facilitate better tracking of contract activities.

5. **Gas Limit Considerations**: The potential for gas limit issues due to loops should be mitigated by considering alternative designs or limiting the number of iterations.

6. **Front-Running Risks**: Strategies to mitigate front-running risks should be considered, especially for functions that involve financial transactions.

In conclusion, while the `JBSingleTokenPaymentTerminalStore` contract demonstrates a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough review and testing phase, including the implementation of best practices for security and access control, are recommended before deployment.

[2024-01-09 17:07:48 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBCurrencies.sol';\nimport './libraries/JBFixedPointNumber.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\n\n/\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********//\n  // -------------------------- private constants ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  /\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //**********//\n  // ---------------- public immutable stored properties --------------- //\n  //*********//\n\n  /\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that exposes price feeds.\n  /\n  IJBPrices public immutable override prices;\n\n  //***********//\n  // --------------------- public stored properties -------------------- //\n  //**********//\n\n  /\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf;\n\n  /\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n\n    @dev\n    Increases as projects use their allowance.\n\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  /\n  mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //***********//\n  // ------------------------- external views -------------------------- //\n  //**********//\n\n  /\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of overflow that project has in the specified terminal.\n  /\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n\n    @return The current total amount of overflow that project has across all terminals.\n  /\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal's currency.\n\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified _terminal.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _terminal.\n  /\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided _overflow.\n  /\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount &gt; _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********//\n  // -------------------------- constructor ---------------------------- //\n  //*********//\n\n  /\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  /\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //**********//\n  // ---------------------- external transactions ---------------------- //\n  //*********//\n\n  /\n    @notice\n    Records newly contributed tokens to a project.\n\n    @dev\n    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The project's funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // If there's no amount being recorded, there's nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n\n    // If there's no weight, token count must be 0 so there's nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n\n    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the _amount.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as weight has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n\n  /\n    @notice\n    Records newly redeemed tokens of a project.\n\n    @dev\n    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  /\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n\n    // Scoped section prevents stack too deep. _reclaimedTokenAmount, _currentOverflow, and _totalSupply only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n\n      // Another scoped section prevents stack too deep. _token, _decimals, and _currency only used within scope.\n      {\n        // Get a reference to the terminal's tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n\n        // Get a reference to the terminal's decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n\n        // Get areference to the terminal's currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n\n        // Can't redeem more tokens that is in the supply.\n        if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();\n\n        if (_currentOverflow &gt; 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that'll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n\n    // The amount being reclaimed must be within the project's balance.\n    if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Remove the reclaimed funds from the project's balance.\n    if (reclaimAmount &gt; 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n\n  /\n    @notice\n    Records newly distributed funds for a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the _amount. This must match the project's current funding cycle's currency.\n\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to the balance's currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available.\n    if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n\n    // Removed the distributed funds from the project's token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n\n  /\n    @notice\n    Records newly used allowance funds of a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the _amount. Must match the currency of the overflow allowance.\n\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to this store's terminal's token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount &gt;\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n\n    // Update the project's balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n\n  /\n    @notice\n    Records newly added funds for the project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n\n  /\n    @notice\n    Records the migration of funds from this store.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n\n    @param _projectId The ID of the project being migrated.\n\n    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n\n  //*********//\n  // --------------------- private helper functions -------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n\n    @return The amount of overflowed tokens that can be reclaimed.\n  /\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n\n  /\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n    @param _fundingCycle The ID of the funding cycle to base the overflow on.\n    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.\n\n    @return overflow The overflow of funds, as a fixed point number with 18 decimals.\n  /\n  function _overflowDuring(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _balanceCurrency\n  ) private view returns (uint256) {\n    // Get the current balance of the project.\n    uint256 _balanceOf = balanceOf[_terminal][_projectId];\n\n    // If there's no balance, there's no overflow.\n    if (_balanceOf == 0) return 0;\n\n    // Get a reference to the distribution limit during the funding cycle.\n    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());\n\n    // Get a reference to the amount still distributable during the funding cycle.\n    uint256 _distributionLimitRemaining = _distributionLimit -\n      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];\n\n    // Convert the _distributionRemaining to be in terms of the provided currency.\n    if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)\n      _distributionLimitRemaining = PRBMath.mulDiv(\n        _distributionLimitRemaining,\n        10_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the _amount.value's fidelity as possible when converting.\n        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // Overflow is the balance of this project minus the amount that can still be distributed.\n    return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;\n  }\n\n  /\n    @notice\n    Gets the amount that is currently overflowing across all of a project's terminals. \n\n    @dev\n    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.\n\n    @param _projectId The ID of the project to get the total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the overflow should be in terms of.\n\n    @return overflow The total overflow of a project's funds.\n  /\n  function _currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) private view returns (uint256) {\n    // Get a reference to the project's terminals.\n    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);\n\n    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.\n    uint256 _ethOverflow;\n\n    // Add the current ETH overflow for each terminal.\n    for (uint256 _i = 0; _i &lt; _terminals.length; _i++)\n      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);\n\n    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.\n    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH\n      ? _ethOverflow\n      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));\n\n    // Adjust the decimals of the fixed point number if needed to match the target decimals.\n    return\n      (_decimals == 18)\n        ? _totalOverflow18Decimal\n        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);\n  }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 17:07:48 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/security/ReentrancyGuard.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBSingleTokenPaymentTerminalStore.sol'; import './libraries/JBConstants.sol'; import './libraries/JBCurrencies.sol'; import './libraries/JBFixedPointNumber.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; /**   @notice   Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal. @dev   Adheres to:   IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules. @dev   Inherits from -   ReentrancyGuard: Contract module that helps prevent reentrant calls to a function. */ contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {   // A library that parses the packed funding cycle metadata into a friendlier format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error CURRENCY_MISMATCH();   error DISTRIBUTION_AMOUNT_LIMIT_REACHED();   error FUNDING_CYCLE_PAYMENT_PAUSED();   error FUNDING_CYCLE_DISTRIBUTION_PAUSED();   error FUNDING_CYCLE_REDEEM_PAUSED();   error INADEQUATE_CONTROLLER_ALLOWANCE();   error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();   error INSUFFICIENT_TOKENS();   error INVALID_FUNDING_CYCLE();   error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED(); //***********//   // -------------------------- private constants ---------------------- //   //*************// /*     @notice     Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.    /   uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18; //***********//   // ---------------- public immutable stored properties --------------- //   //*************// /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that exposes price feeds.   /   IJBPrices public immutable override prices; //***********//   // --------------------- public stored properties -------------------- //   //*************// /**     @notice     The amount of tokens that each project has for each terminal, in terms of the terminal's token. @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the balance applies. _projectId The ID of the project to get the balance of.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; uint256)) public override balanceOf; /**     @notice     The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency. @dev Increases as projects use their preconfigured distribution limits.  @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the used distribution limit applies. _projectId The ID of the project to get the used distribution limit of. _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedDistributionLimitOf; /**     @notice     The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency. @dev Increases as projects use their allowance.  @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.  _terminal The terminal to which the overflow allowance applies. _projectId The ID of the project to get the used overflow allowance of. _configuration The configuration of the during which the allowance was used.  */   mapping(IJBSingleTokenPaymentTerminal =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)))     public     override usedOverflowAllowanceOf; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     Gets the current overflowed amount in a terminal for a specified project. @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for.  @return The current amount of overflow that project has in the specified terminal.  */   function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)     external     view     override     returns (uint256)   {     // Return the overflow during the project's current funding cycle.     return       _overflowDuring(         _terminal,         _projectId,         fundingCycleStore.currentOf(_projectId),         _terminal.currency()       );   } /**     @notice     Gets the current overflowed amount for a specified project across all terminals. @param _projectId The ID of the project to get total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the total overflow should be in terms of.  @return The current total amount of overflow that project has across all terminals.  */   function currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) external view override returns (uint256) {     return _currentTotalOverflowOf(_projectId, _decimals, _currency);   } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.  @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.  @param _terminal The terminal from which the reclaimable amount would come. @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.  */   function currentReclaimableOverflowOf(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     uint256 _tokenCount,     bool _useTotalOverflow   ) external view override returns (uint256) {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get the amount of current overflow. // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal. uint256 _currentOverflow = _useTotalOverflow   ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())   : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());  // If there's no overflow, there's no reclaimable overflow. if (_currentOverflow == 0) return 0;  // Get the number of outstanding tokens the project has. uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))   .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());  // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(     _projectId,     _fundingCycle,     _tokenCount,     _totalSupply,     _currentOverflow   );  } /**     @notice     The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with, as a fixed point number.  @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.  */   function currentReclaimableOverflowOf(     uint256 _projectId,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) external view override returns (uint256) {     // If there's no overflow, there's no reclaimable overflow.     if (_overflow == 0) return 0; // Can't redeem more tokens that is in the supply. if (_tokenCount &gt; _totalSupply) return 0;  // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Return the reclaimable overflow amount. return   _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);  } //***********//   // -------------------------- constructor ---------------------------- //   //*************// /*     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _prices A contract that exposes price feeds.   /   constructor(     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBPrices _prices   ) {     directory = _directory;     fundingCycleStore = _fundingCycleStore;     prices = _prices;   } //***********//   // ---------------------- external transactions ---------------------- //   //*************// /**     @notice     Records newly contributed tokens to a project. @dev Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.  @param _payer The original address that sent the payment to the terminal. @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount. @param _projectId The ID of the project being paid. @param _baseWeightCurrency The currency to base token issuance on. @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment. @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The project's funding cycle during which payment was made. @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordPaymentFrom(     address _payer,     JBTokenAmount calldata _amount,     uint256 _projectId,     uint256 _baseWeightCurrency,     address _beneficiary,     string calldata _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 tokenCount,       IJBPayDelegate delegate,       string memory memo     )   {     // Get a reference to the current funding cycle for the project.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The project must have a funding cycle configured. if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();  // Must not be paused. if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();  // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals. uint256 _weight;  // If the funding cycle has configured a data source, use it to derive a weight and memo. if (fundingCycle.useDataSourceForPay()) {   // Create the params that'll be sent to the data source.   JBPayParamsData memory _data = JBPayParamsData(     IJBSingleTokenPaymentTerminal(msg.sender),     _payer,     _amount,     _projectId,     fundingCycle.configuration,     _beneficiary,     fundingCycle.weight,     fundingCycle.reservedRate(),     _memo,     _metadata   );   (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(     _data   ); } // Otherwise use the funding cycle's weight else {   _weight = fundingCycle.weight;   memo = _memo; }  // If there's no amount being recorded, there's nothing left to do. if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);  // Add the amount to the token balance of the project. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +   _amount.value;  // If there's no weight, token count must be 0 so there's nothing left to do. if (_weight == 0) return (fundingCycle, 0, delegate, memo);  // Get a reference to the number of decimals in the amount. (prevents stack too deep). uint256 _decimals = _amount.decimals;  // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor. // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`. uint256 _weightRatio = _amount.currency == _baseWeightCurrency   ? 10**_decimals   : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);  // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has. tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);  } /**     @notice     Records newly redeemed tokens of a project. @dev Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.  @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.  @param _holder The account that is having its tokens redeemed. @param _projectId The ID of the project to which the tokens being redeemed belong. @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals. @param _memo A memo to pass along to the emitted event. @param _metadata Bytes to send along to the data source, if one is provided.  @return fundingCycle The funding cycle during which the redemption was made. @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals. @return delegate A delegate contract to use for subsequent calls. @return memo A memo that should be passed along to the emitted event.  */   function recordRedemptionFor(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string memory _memo,     bytes memory _metadata   )     external     override     nonReentrant     returns (       JBFundingCycle memory fundingCycle,       uint256 reclaimAmount,       IJBRedemptionDelegate delegate,       string memory memo     )   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();  // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope. {   // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.   JBTokenAmount memory _reclaimedTokenAmount;   uint256 _currentOverflow;   uint256 _totalSupply;    // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.   {     // Get a reference to the terminal's tokens.     address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();      // Get a reference to the terminal's decimals.     uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();      // Get areference to the terminal's currency.     uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();      // Get the amount of current overflow.     // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.     _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()       ? _currentTotalOverflowOf(_projectId, _decimals, _currency)       : _overflowDuring(         IJBSingleTokenPaymentTerminal(msg.sender),         _projectId,         fundingCycle,         _currency       );      // Get the number of outstanding tokens the project has.     _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(       _projectId,       fundingCycle.reservedRate()     );      // Can't redeem more tokens that is in the supply.     if (_tokenCount &gt; _totalSupply) revert INSUFFICIENT_TOKENS();      if (_currentOverflow &gt; 0)       // Calculate reclaim amount using the current overflow amount.       reclaimAmount = _reclaimableOverflowDuring(         _projectId,         fundingCycle,         _tokenCount,         _totalSupply,         _currentOverflow       );      _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);   }    // If the funding cycle has configured a data source, use it to derive a claim amount and memo.   if (fundingCycle.useDataSourceForRedeem()) {     // Create the params that'll be sent to the data source.     JBRedeemParamsData memory _data = JBRedeemParamsData(       IJBSingleTokenPaymentTerminal(msg.sender),       _holder,       _projectId,       fundingCycle.configuration,       _tokenCount,       _totalSupply,       _currentOverflow,       _reclaimedTokenAmount,       fundingCycle.useTotalOverflowForRedemptions(),       fundingCycle.redemptionRate(),       fundingCycle.ballotRedemptionRate(),       _memo,       _metadata     );     (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())       .redeemParams(_data);   } else {     memo = _memo;   } }  // The amount being reclaimed must be within the project's balance. if (reclaimAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Remove the reclaimed funds from the project's balance. if (reclaimAmount &gt; 0)   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -     reclaimAmount;  } /**     @notice     Records newly distributed funds for a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project that is having funds distributed. @param _amount The amount to use from the distribution limit, as a fixed point number. @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.  @return fundingCycle The funding cycle during which the distribution was made. @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordDistributionFor(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // The funding cycle must not be configured to have distributions paused. if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();  // The new total amount that has been distributed during this funding cycle. uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.number] + _amount;  // Amount must be within what is still distributable. (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the distribution limit. if (_newUsedDistributionLimitOf &gt; _distributionLimitOf || _distributionLimitOf == 0)   revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();  // Make sure the currencies match. if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to the balance's currency. distributedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available. if (distributedAmount &gt; balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])   revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the new amount. usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.number ] = _newUsedDistributionLimitOf;  // Removed the distributed funds from the project's token balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   distributedAmount;  } /**     @notice     Records newly used allowance funds of a project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to use the allowance of. @param _amount The amount to use from the allowance, as a fixed point number.  @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.  @return fundingCycle The funding cycle during which the overflow allowance is being used. @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordUsedAllowanceOf(     uint256 _projectId,     uint256 _amount,     uint256 _currency   )     external     override     nonReentrant     returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)   {     // Get a reference to the project's current funding cycle.     fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to the new used overflow allowance for this funding cycle configuration. uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[   IJBSingleTokenPaymentTerminal(msg.sender) ][_projectId][fundingCycle.configuration] + _amount;  // There must be sufficient allowance available. (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(   directory.controllerOf(_projectId) ).overflowAllowanceOf(     _projectId,     fundingCycle.configuration,     IJBSingleTokenPaymentTerminal(msg.sender),     IJBSingleTokenPaymentTerminal(msg.sender).token()   );  // Make sure the new used amount is within the allowance. if (_newUsedOverflowAllowanceOf &gt; _overflowAllowanceOf || _overflowAllowanceOf == 0)   revert INADEQUATE_CONTROLLER_ALLOWANCE();  // Make sure the currencies match. if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();  // Get a reference to the terminal's currency. uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();  // Convert the amount to this store's terminal's token. usedAmount = (_currency == _balanceCurrency)   ? _amount   : PRBMath.mulDiv(     _amount,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // The amount being distributed must be available in the overflow. if (   usedAmount &gt;   _overflowDuring(     IJBSingleTokenPaymentTerminal(msg.sender),     _projectId,     fundingCycle,     _balanceCurrency   ) ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();  // Store the incremented value. usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][   fundingCycle.configuration ] = _newUsedOverflowAllowanceOf;  // Update the project's balance. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =   balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -   usedAmount;  } /**     @notice     Records newly added funds for the project. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal.  @param _projectId The ID of the project to which the funds being added belong. @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {     // Increment the balance.     balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =       balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +       _amount;   } /**     @notice     Records the migration of funds from this store. @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.  @param _projectId The ID of the project being migrated.  @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.  */   function recordMigration(uint256 _projectId)     external     override     nonReentrant     returns (uint256 balance)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Migration must be allowed. if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();  // Return the current balance. balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];  // Set the balance to 0. balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;  } //***********//   // --------------------- private helper functions -------------------- //   //*************// /**     @notice     The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified. @dev  If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.  @param _projectId The ID of the project to get the reclaimable overflow amount for. @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated. @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals. @param _overflow The amount of overflow to make the calculation with.  @return The amount of overflowed tokens that can be reclaimed.  */   function _reclaimableOverflowDuring(     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _tokenCount,     uint256 _totalSupply,     uint256 _overflow   ) private view returns (uint256) {     // If the amount being redeemed is the total supply, return the rest of the overflow.     if (_tokenCount == _totalSupply) return _overflow; // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot. uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==   JBBallotState.Active   ? _fundingCycle.ballotRedemptionRate()   : _fundingCycle.redemptionRate();  // If the redemption rate is 0, nothing is claimable. if (_redemptionRate == 0) return 0;  // Get a reference to the linear proportion. uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary. if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;  return   PRBMath.mulDiv(     _base,     _redemptionRate +       PRBMath.mulDiv(         _tokenCount,         JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,         _totalSupply       ),     JBConstants.MAX_REDEMPTION_RATE   );  } /**     @notice     Gets the amount that is overflowing when measured from the specified funding cycle. @dev This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.  @param _terminal The terminal for which the overflow is being calculated. @param _projectId The ID of the project to get overflow for. @param _fundingCycle The ID of the funding cycle to base the overflow on. @param _balanceCurrency The currency that the stored balance is expected to be in terms of.  @return overflow The overflow of funds, as a fixed point number with 18 decimals.  */   function _overflowDuring(     IJBSingleTokenPaymentTerminal _terminal,     uint256 _projectId,     JBFundingCycle memory _fundingCycle,     uint256 _balanceCurrency   ) private view returns (uint256) {     // Get the current balance of the project.     uint256 _balanceOf = balanceOf[_terminal][_projectId]; // If there's no balance, there's no overflow. if (_balanceOf == 0) return 0;  // Get a reference to the distribution limit during the funding cycle. (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(   directory.controllerOf(_projectId) ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());  // Get a reference to the amount still distributable during the funding cycle. uint256 _distributionLimitRemaining = _distributionLimit -   usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];  // Convert the _distributionRemaining to be in terms of the provided currency. if (_distributionLimitRemaining != 0 &amp;&amp; _distributionLimitCurrency != _balanceCurrency)   _distributionLimitRemaining = PRBMath.mulDiv(     _distributionLimitRemaining,     10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.     prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)   );  // Overflow is the balance of this project minus the amount that can still be distributed. return _balanceOf &gt; _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;  } /**     @notice     Gets the amount that is currently overflowing across all of a project's terminals.  @dev This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.  @param _projectId The ID of the project to get the total overflow for. @param _decimals The number of decimals that the fixed point overflow should include. @param _currency The currency that the overflow should be in terms of.  @return overflow The total overflow of a project's funds.  */   function _currentTotalOverflowOf(     uint256 _projectId,     uint256 _decimals,     uint256 _currency   ) private view returns (uint256) {     // Get a reference to the project's terminals.     IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId); // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals. uint256 _ethOverflow;  // Add the current ETH overflow for each terminal. for (uint256 _i = 0; _i &lt; _terminals.length; _i++)   _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);  // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals. uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH   ? _ethOverflow   : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));  // Adjust the decimals of the fixed point number if needed to match the target decimals. return   (_decimals == 18)     ? _totalOverflow18Decimal     : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);  } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:07:48 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-01-09 17:07:51 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:07:51 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15937
completion_tokens: 1
total_tokens: 15938
cost: $0.047815


[2024-01-09 17:07:51 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBSingleTokenPaymentTerminalStore.sol';
import './libraries/JBConstants.sol';
import './libraries/JBCurrencies.sol';
import './libraries/JBFixedPointNumber.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';

/**
  @notice
  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.

  @dev
  Adheres to:
  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.

  @dev
  Inherits from -
  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.
*/
contract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {
  // A library that parses the packed funding cycle metadata into a friendlier format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error CURRENCY_MISMATCH();
  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();
  error FUNDING_CYCLE_PAYMENT_PAUSED();
  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();
  error FUNDING_CYCLE_REDEEM_PAUSED();
  error INADEQUATE_CONTROLLER_ALLOWANCE();
  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();
  error INSUFFICIENT_TOKENS();
  error INVALID_FUNDING_CYCLE();
  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

  //*********************************************************************//
  // -------------------------- private constants ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. 
  */
  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;

  //*********************************************************************//
  // ---------------- public immutable stored properties --------------- //
  //*********************************************************************//

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that exposes price feeds.
  */
  IJBPrices public immutable override prices;

  //*********************************************************************//
  // --------------------- public stored properties -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of tokens that each project has for each terminal, in terms of the terminal's token.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the balance applies.
    _projectId The ID of the project to get the balance of.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;

  /**
    @notice
    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.

    @dev
    Increases as projects use their preconfigured distribution limits.

    @dev
    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the used distribution limit applies.
    _projectId The ID of the project to get the used distribution limit of.
    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedDistributionLimitOf;

  /**
    @notice
    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.

    @dev
    Increases as projects use their allowance.

    @dev
    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.

    _terminal The terminal to which the overflow allowance applies.
    _projectId The ID of the project to get the used overflow allowance of.
    _configuration The configuration of the during which the allowance was used.
  */
  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))
    public
    override usedOverflowAllowanceOf;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    Gets the current overflowed amount in a terminal for a specified project.

    @dev
    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.

    @return The current amount of overflow that project has in the specified terminal.
  */
  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)
    external
    view
    override
    returns (uint256)
  {
    // Return the overflow during the project's current funding cycle.
    return
      _overflowDuring(
        _terminal,
        _projectId,
        fundingCycleStore.currentOf(_projectId),
        _terminal.currency()
      );
  }

  /**
    @notice
    Gets the current overflowed amount for a specified project across all terminals.

    @param _projectId The ID of the project to get total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the total overflow should be in terms of.

    @return The current total amount of overflow that project has across all terminals.
  */
  function currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) external view override returns (uint256) {
    return _currentTotalOverflowOf(_projectId, _decimals, _currency);
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @dev
    The current reclaimable overflow is returned in terms of the specified terminal's currency.

    @dev
    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.

    @param _terminal The terminal from which the reclaimable amount would come.
    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.
  */
  function currentReclaimableOverflowOf(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    uint256 _tokenCount,
    bool _useTotalOverflow
  ) external view override returns (uint256) {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get the amount of current overflow.
    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.
    uint256 _currentOverflow = _useTotalOverflow
      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())
      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());

    // If there's no overflow, there's no reclaimable overflow.
    if (_currentOverflow == 0) return 0;

    // Get the number of outstanding tokens the project has.
    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))
      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(
        _projectId,
        _fundingCycle,
        _tokenCount,
        _totalSupply,
        _currentOverflow
      );
  }

  /**
    @notice
    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.

    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.
  */
  function currentReclaimableOverflowOf(
    uint256 _projectId,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) external view override returns (uint256) {
    // If there's no overflow, there's no reclaimable overflow.
    if (_overflow == 0) return 0;

    // Can't redeem more tokens that is in the supply.
    if (_tokenCount > _totalSupply) return 0;

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Return the reclaimable overflow amount.
    return
      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);
  }

  //*********************************************************************//
  // -------------------------- constructor ---------------------------- //
  //*********************************************************************//

  /**
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _prices A contract that exposes price feeds.
  */
  constructor(
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBPrices _prices
  ) {
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    prices = _prices;
  }

  //*********************************************************************//
  // ---------------------- external transactions ---------------------- //
  //*********************************************************************//

  /**
    @notice
    Records newly contributed tokens to a project.

    @dev
    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.

    @param _payer The original address that sent the payment to the terminal.
    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.
    @param _projectId The ID of the project being paid.
    @param _baseWeightCurrency The currency to base token issuance on.
    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.
    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The project's funding cycle during which payment was made.
    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordPaymentFrom(
    address _payer,
    JBTokenAmount calldata _amount,
    uint256 _projectId,
    uint256 _baseWeightCurrency,
    address _beneficiary,
    string calldata _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 tokenCount,
      IJBPayDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the current funding cycle for the project.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The project must have a funding cycle configured.
    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();

    // Must not be paused.
    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();

    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.
    uint256 _weight;

    // If the funding cycle has configured a data source, use it to derive a weight and memo.
    if (fundingCycle.useDataSourceForPay()) {
      // Create the params that'll be sent to the data source.
      JBPayParamsData memory _data = JBPayParamsData(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _payer,
        _amount,
        _projectId,
        fundingCycle.configuration,
        _beneficiary,
        fundingCycle.weight,
        fundingCycle.reservedRate(),
        _memo,
        _metadata
      );
      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(
        _data
      );
    }
    // Otherwise use the funding cycle's weight
    else {
      _weight = fundingCycle.weight;
      memo = _memo;
    }

    // If there's no amount being recorded, there's nothing left to do.
    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);

    // Add the amount to the token balance of the project.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount.value;

    // If there's no weight, token count must be 0 so there's nothing left to do.
    if (_weight == 0) return (fundingCycle, 0, delegate, memo);

    // Get a reference to the number of decimals in the amount. (prevents stack too deep).
    uint256 _decimals = _amount.decimals;

    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.
    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.
    uint256 _weightRatio = _amount.currency == _baseWeightCurrency
      ? 10**_decimals
      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);

    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.
    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);
  }

  /**
    @notice
    Records newly redeemed tokens of a project.

    @dev
    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.

    @param _holder The account that is having its tokens redeemed.
    @param _projectId The ID of the project to which the tokens being redeemed belong.
    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
    @param _memo A memo to pass along to the emitted event.
    @param _metadata Bytes to send along to the data source, if one is provided.

    @return fundingCycle The funding cycle during which the redemption was made.
    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.
    @return delegate A delegate contract to use for subsequent calls.
    @return memo A memo that should be passed along to the emitted event.
  */
  function recordRedemptionFor(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string memory _memo,
    bytes memory _metadata
  )
    external
    override
    nonReentrant
    returns (
      JBFundingCycle memory fundingCycle,
      uint256 reclaimAmount,
      IJBRedemptionDelegate delegate,
      string memory memo
    )
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();

    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.
    {
      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.
      JBTokenAmount memory _reclaimedTokenAmount;
      uint256 _currentOverflow;
      uint256 _totalSupply;

      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.
      {
        // Get a reference to the terminal's tokens.
        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();

        // Get a reference to the terminal's decimals.
        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();

        // Get areference to the terminal's currency.
        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

        // Get the amount of current overflow.
        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.
        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()
          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)
          : _overflowDuring(
            IJBSingleTokenPaymentTerminal(msg.sender),
            _projectId,
            fundingCycle,
            _currency
          );

        // Get the number of outstanding tokens the project has.
        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(
          _projectId,
          fundingCycle.reservedRate()
        );

        // Can't redeem more tokens that is in the supply.
        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();

        if (_currentOverflow > 0)
          // Calculate reclaim amount using the current overflow amount.
          reclaimAmount = _reclaimableOverflowDuring(
            _projectId,
            fundingCycle,
            _tokenCount,
            _totalSupply,
            _currentOverflow
          );

        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);
      }

      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.
      if (fundingCycle.useDataSourceForRedeem()) {
        // Create the params that'll be sent to the data source.
        JBRedeemParamsData memory _data = JBRedeemParamsData(
          IJBSingleTokenPaymentTerminal(msg.sender),
          _holder,
          _projectId,
          fundingCycle.configuration,
          _tokenCount,
          _totalSupply,
          _currentOverflow,
          _reclaimedTokenAmount,
          fundingCycle.useTotalOverflowForRedemptions(),
          fundingCycle.redemptionRate(),
          fundingCycle.ballotRedemptionRate(),
          _memo,
          _metadata
        );
        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())
          .redeemParams(_data);
      } else {
        memo = _memo;
      }
    }

    // The amount being reclaimed must be within the project's balance.
    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Remove the reclaimed funds from the project's balance.
    if (reclaimAmount > 0)
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
        reclaimAmount;
  }

  /**
    @notice
    Records newly distributed funds for a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project that is having funds distributed.
    @param _amount The amount to use from the distribution limit, as a fixed point number.
    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.

    @return fundingCycle The funding cycle during which the distribution was made.
    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordDistributionFor(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The funding cycle must not be configured to have distributions paused.
    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();

    // The new total amount that has been distributed during this funding cycle.
    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.number] + _amount;

    // Amount must be within what is still distributable.
    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the distribution limit.
    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)
      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();

    // Make sure the currencies match.
    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to the balance's currency.
    distributedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available.
    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])
      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the new amount.
    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.number
    ] = _newUsedDistributionLimitOf;

    // Removed the distributed funds from the project's token balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      distributedAmount;
  }

  /**
    @notice
    Records newly used allowance funds of a project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to use the allowance of.
    @param _amount The amount to use from the allowance, as a fixed point number. 
    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.

    @return fundingCycle The funding cycle during which the overflow allowance is being used.
    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordUsedAllowanceOf(
    uint256 _projectId,
    uint256 _amount,
    uint256 _currency
  )
    external
    override
    nonReentrant
    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)
  {
    // Get a reference to the project's current funding cycle.
    fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to the new used overflow allowance for this funding cycle configuration.
    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[
      IJBSingleTokenPaymentTerminal(msg.sender)
    ][_projectId][fundingCycle.configuration] + _amount;

    // There must be sufficient allowance available.
    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).overflowAllowanceOf(
        _projectId,
        fundingCycle.configuration,
        IJBSingleTokenPaymentTerminal(msg.sender),
        IJBSingleTokenPaymentTerminal(msg.sender).token()
      );

    // Make sure the new used amount is within the allowance.
    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)
      revert INADEQUATE_CONTROLLER_ALLOWANCE();

    // Make sure the currencies match.
    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();

    // Get a reference to the terminal's currency.
    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();

    // Convert the amount to this store's terminal's token.
    usedAmount = (_currency == _balanceCurrency)
      ? _amount
      : PRBMath.mulDiv(
        _amount,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // The amount being distributed must be available in the overflow.
    if (
      usedAmount >
      _overflowDuring(
        IJBSingleTokenPaymentTerminal(msg.sender),
        _projectId,
        fundingCycle,
        _balanceCurrency
      )
    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();

    // Store the incremented value.
    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][
      fundingCycle.configuration
    ] = _newUsedOverflowAllowanceOf;

    // Update the project's balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -
      usedAmount;
  }

  /**
    @notice
    Records newly added funds for the project.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. 

    @param _projectId The ID of the project to which the funds being added belong.
    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {
    // Increment the balance.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =
      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +
      _amount;
  }

  /**
    @notice
    Records the migration of funds from this store.

    @dev
    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.

    @param _projectId The ID of the project being migrated.

    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.
  */
  function recordMigration(uint256 _projectId)
    external
    override
    nonReentrant
    returns (uint256 balance)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();

    // Return the current balance.
    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];

    // Set the balance to 0.
    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;
  }

  //*********************************************************************//
  // --------------------- private helper functions -------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.

    @dev 
    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.

    @param _projectId The ID of the project to get the reclaimable overflow amount for.
    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.
    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.
    @param _overflow The amount of overflow to make the calculation with.

    @return The amount of overflowed tokens that can be reclaimed.
  */
  function _reclaimableOverflowDuring(
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _tokenCount,
    uint256 _totalSupply,
    uint256 _overflow
  ) private view returns (uint256) {
    // If the amount being redeemed is the total supply, return the rest of the overflow.
    if (_tokenCount == _totalSupply) return _overflow;

    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.
    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==
      JBBallotState.Active
      ? _fundingCycle.ballotRedemptionRate()
      : _fundingCycle.redemptionRate();

    // If the redemption rate is 0, nothing is claimable.
    if (_redemptionRate == 0) return 0;

    // Get a reference to the linear proportion.
    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);

    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.
    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;

    return
      PRBMath.mulDiv(
        _base,
        _redemptionRate +
          PRBMath.mulDiv(
            _tokenCount,
            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,
            _totalSupply
          ),
        JBConstants.MAX_REDEMPTION_RATE
      );
  }

  /**
    @notice
    Gets the amount that is overflowing when measured from the specified funding cycle.

    @dev
    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribution limit.

    @param _terminal The terminal for which the overflow is being calculated.
    @param _projectId The ID of the project to get overflow for.
    @param _fundingCycle The ID of the funding cycle to base the overflow on.
    @param _balanceCurrency The currency that the stored balance is expected to be in terms of.

    @return overflow The overflow of funds, as a fixed point number with 18 decimals.
  */
  function _overflowDuring(
    IJBSingleTokenPaymentTerminal _terminal,
    uint256 _projectId,
    JBFundingCycle memory _fundingCycle,
    uint256 _balanceCurrency
  ) private view returns (uint256) {
    // Get the current balance of the project.
    uint256 _balanceOf = balanceOf[_terminal][_projectId];

    // If there's no balance, there's no overflow.
    if (_balanceOf == 0) return 0;

    // Get a reference to the distribution limit during the funding cycle.
    (uint256 _distributionLimit, uint256 _distributionLimitCurrency) = IJBController(
      directory.controllerOf(_projectId)
    ).distributionLimitOf(_projectId, _fundingCycle.configuration, _terminal, _terminal.token());

    // Get a reference to the amount still distributable during the funding cycle.
    uint256 _distributionLimitRemaining = _distributionLimit -
      usedDistributionLimitOf[_terminal][_projectId][_fundingCycle.number];

    // Convert the _distributionRemaining to be in terms of the provided currency.
    if (_distributionLimitRemaining != 0 && _distributionLimitCurrency != _balanceCurrency)
      _distributionLimitRemaining = PRBMath.mulDiv(
        _distributionLimitRemaining,
        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.
        prices.priceFor(_distributionLimitCurrency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)
      );

    // Overflow is the balance of this project minus the amount that can still be distributed.
    return _balanceOf > _distributionLimitRemaining ? _balanceOf - _distributionLimitRemaining : 0;
  }

  /**
    @notice
    Gets the amount that is currently overflowing across all of a project's terminals. 

    @dev
    This amount changes as the value of the balances changes in relation to the currency being used to measure the project's distribution limits.

    @param _projectId The ID of the project to get the total overflow for.
    @param _decimals The number of decimals that the fixed point overflow should include.
    @param _currency The currency that the overflow should be in terms of.

    @return overflow The total overflow of a project's funds.
  */
  function _currentTotalOverflowOf(
    uint256 _projectId,
    uint256 _decimals,
    uint256 _currency
  ) private view returns (uint256) {
    // Get a reference to the project's terminals.
    IJBPaymentTerminal[] memory _terminals = directory.terminalsOf(_projectId);

    // Keep a reference to the ETH overflow across all terminals, as a fixed point number with 18 decimals.
    uint256 _ethOverflow;

    // Add the current ETH overflow for each terminal.
    for (uint256 _i = 0; _i < _terminals.length; _i++)
      _ethOverflow = _ethOverflow + _terminals[_i].currentEthOverflowOf(_projectId);

    // Convert the ETH overflow to the specified currency if needed, maintaining a fixed point number with 18 decimals.
    uint256 _totalOverflow18Decimal = _currency == JBCurrencies.ETH
      ? _ethOverflow
      : PRBMath.mulDiv(_ethOverflow, 10**18, prices.priceFor(JBCurrencies.ETH, _currency, 18));

    // Adjust the decimals of the fixed point number if needed to match the target decimals.
    return
      (_decimals == 18)
        ? _totalOverflow18Decimal
        : JBFixedPointNumber.adjustDecimals(_totalOverflow18Decimal, 18, _decimals);
  }
}
.]

###

[2024-01-09 17:07:51 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 17:07:51 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=18

**num_self_reflections**=1

**num_prompt_tokens**=128568

**num_completion_tokens**=4004

**num_total_tokens**=132572

**duration**=69.00s

ChatDev Starts (20240901170642)

ChatDev Ends (20240901170751)



